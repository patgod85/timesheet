// resources (93):
//  [string] [unknown#1] -> 0.css
//  [array] components/basis/src/basis/ui/templates/field/Textarea.tmpl -> s.tmpl
//  [array] js/module/agenda/template/item.tmpl -> 1.tmpl
//  [array] components/basis/src/basis/ui/templates/button/Button.tmpl -> a.tmpl
//  [array] components/basis/src/basis/ui/templates/button/ButtonPanel.tmpl -> b.tmpl
//  [array] components/basis/src/basis/ui/templates/button/ButtonGroup.tmpl -> c.tmpl
//  [array] js/module/toolbox/teams/template/list.tmpl -> 2.tmpl
//  [array] js/module/toolbox/teams/template/item.tmpl -> 3.tmpl
//  [array] js/module/team/template/index.tmpl -> 9.tmpl
//  [array] components/basis/src/basis/ui/templates/calendar/Calendar.tmpl -> d.tmpl
//  [array] components/basis/src/basis/ui/templates/calendar/Section.tmpl -> e.tmpl
//  [array] components/basis/src/basis/ui/templates/calendar/SectionMonth.tmpl -> f.tmpl
//  [array] components/basis/src/basis/ui/templates/calendar/Node.tmpl -> g.tmpl
//  [array] js/module/toolbox/template/index.tmpl -> 4.tmpl
//  [array] components/basis/src/basis/ui/templates/popup/Popup.tmpl -> h.tmpl
//  [array] components/basis/src/basis/ui/templates/popup/Balloon.tmpl -> i.tmpl
//  [array] components/basis/src/basis/ui/templates/popup/popupManager.tmpl -> j.tmpl
//  [array] js/module/employee/template/index.tmpl -> 8.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Example.tmpl -> k.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Description.tmpl -> l.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Counter.tmpl -> m.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Field.tmpl -> n.tmpl
//  [array] components/basis/src/basis/ui/templates/field/File.tmpl -> o.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Hidden.tmpl -> p.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Text.tmpl -> q.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Password.tmpl -> r.tmpl
//  [array] js/module/agenda/template/index.tmpl -> 0.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Checkbox.tmpl -> t.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Label.tmpl -> u.tmpl
//  [array] components/basis/src/basis/ui/templates/field/RadioGroup.tmpl -> v.tmpl
//  [array] components/basis/src/basis/ui/templates/field/RadioGroupItem.tmpl -> w.tmpl
//  [array] components/basis/src/basis/ui/templates/field/CheckGroup.tmpl -> x.tmpl
//  [array] components/basis/src/basis/ui/templates/field/CheckGroupItem.tmpl -> y.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Select.tmpl -> z.tmpl
//  [array] components/basis/src/basis/ui/templates/field/SelectItem.tmpl -> 10.tmpl
//  [array] components/basis/src/basis/ui/templates/field/Combobox.tmpl -> 11.tmpl
//  [array] components/basis/src/basis/ui/templates/field/ComboboxItem.tmpl -> 12.tmpl
//  [array] components/basis/src/basis/ui/templates/field/ComboboxDropdownList.tmpl -> 13.tmpl
//  [array] components/basis/src/basis/ui/templates/field/MatchInput.tmpl -> 14.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-text.tmpl -> 15.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-password.tmpl -> 16.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-textarea.tmpl -> 17.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-checkbox.tmpl -> 18.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-radio.tmpl -> 19.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-select.tmpl -> 1a.tmpl
//  [array] components/basis/src/basis/ui/templates/field/native-type-file.tmpl -> 1b.tmpl
//  [array] js/module/user/template/index.tmpl -> 5.tmpl
//  [array] js/module/day/template/index.tmpl -> 6.tmpl
//  [array] js/module/month/template/index.tmpl -> 7.tmpl
//  [object] components/basis/src/basis/ui/field.l10n -> 2.l10n
//  [object] components/basis/src/basis/ui/calendar.l10n -> 0.l10n
//  [object] components/basis/src/basis/ui/templates/field/Counter.l10n -> 1.l10n
//  [function] components/basis/src/basis/l10n.js -> 2.js
//  [function] js/module/public-holidays/index.js -> u.js
//  [function] components/basis/src/basis/entity.js -> e.js
//  [function] components/basis/src/basis/data/dataset.js -> f.js
//  [function] components/basis/src/basis/net/service.js -> g.js
//  [function] components/basis/src/basis/net/action.js -> h.js
//  [function] components/moment/moment.js -> v.js
//  [function] js/module/toolbox/index.js -> w.js
//  [function] components/basis/src/basis/ui/button.js -> i.js
//  [function] components/basis/src/basis/event.js -> 3.js
//  [function] components/basis/src/basis/data.js -> 4.js
//  [function] components/basis/src/basis/dom/wrapper.js -> 5.js
//  [function] js/module/toolbox/teams/index.js -> x.js
//  [function] components/basis/src/basis/dom.js -> j.js
//  [function] components/basis/src/basis/template.js -> 6.js
//  [function] components/basis/src/basis/template/html.js -> 7.js
//  [function] js/module/toolbox/calendar/index.js -> y.js
//  [function] components/basis/src/basis/ui/calendar.js -> k.js
//  [function] components/basis/src/basis/date.js -> l.js
//  [function] components/basis/src/basis/dom/event.js -> 8.js
//  [function] components/basis/src/basis/template/htmlfgen.js -> 9.js
//  [function] ../../components/moment/moment.js -> s.js
//  [function] components/basis/src/basis/net/ajax.js -> a.js
//  [function] components/basis/src/basis/ua.js -> b.js
//  [function] components/basis/src/basis/net.js -> c.js
//  [function] js/module/user/index.js -> z.js
//  [function] components/basis/src/basis/ui/field.js -> m.js
//  [function] components/basis/src/basis/data/value.js -> n.js
//  [function] components/basis/src/basis/ui/popup.js -> o.js
//  [function] components/basis/src/basis/ui.js -> 1.js
//  [function] js/module/team/index.js -> 10.js
//  [function] js/module/month/index.js -> 11.js
//  [function] js/module/day/index.js -> 12.js
//  [function] components/basis/src/basis/layout.js -> q.js
//  [function] components/basis/src/basis/dom/computedStyle.js -> r.js
//  [function] js/module/employee/index.js -> 13.js
//  [function] components/basis/src/basis/router.js -> d.js
//  [function] js/module/agenda/index.js -> t.js
//  [function] js/module/pages/index.js -> 14.js
//  [function] js/app.js -> 0.js
//  [function] components/basis/src/basis/cssom.js -> p.js
//
// filelist (1): 
//   js/app.js
(function(){
"use strict";

var __namespace_map__ = {"0.js":"app","1.js":"basis.ui","2.js":"basis.l10n","3.js":"basis.event","4.js":"basis.data","5.js":"basis.dom.wrapper","6.js":"basis.template","7.js":"basis.template.html","8.js":"basis.dom.event","9.js":"basis.template.htmlfgen","a.js":"basis.net.ajax","b.js":"basis.ua","c.js":"basis.net","d.js":"basis.router","e.js":"basis.entity","f.js":"basis.data.dataset","g.js":"basis.net.service","h.js":"basis.net.action","i.js":"basis.ui.button","j.js":"basis.dom","k.js":"basis.ui.calendar","l.js":"basis.date","m.js":"basis.ui.field","n.js":"basis.data.value","o.js":"basis.ui.popup","p.js":"basis.cssom","q.js":"basis.layout","r.js":"basis.dom.computedStyle"};
var __resources__ = {
  "0.css": "",
  "s.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus" ], "textarea", [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup", "keyup updateSymbolsLeft" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change", "change updateSymbolsLeft" ], [ 6, "input", "input updateSymbolsLeft" ] ], [ 8, 1, [ "counter" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "1.tmpl": [ [ 1, 0, [ "element" ], "li", [ 4, 0, 0, "agenda_li" ], [ 1, 0, 0, "span", [ 4, [ [ "type_", "id" ] ], 0, "agenda_box" ], [ 1, 0, 0, "span" ] ], [ 3, 0, 0, " - " ], [ 3, 1, [ "name" ] ], [ 3, 0, 0, " " ], [ 1, 0, 0, "button", [ 6, "click", "applyType" ], [ 3, 0, 0, "apply for selected days" ] ] ] ],
  "a.tmpl": [ [ 1, 0, [ "element" ], "button", [ 4, [ [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Button" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 6, "click" ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Button-Back" ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Button-Caption" ], [ 3, 1, [ "caption" ] ] ] ] ],
  "b.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "", "disabled", 0 ] ], 0, "Basis-ButtonPanel" ], [ 1, 0, [ "childNodesElement", "content" ], "div", [ 4, 0, 0, "Basis-ButtonPanel-Content" ] ] ] ],
  "c.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, 0, 0, "Basis-ButtonGroup" ] ] ],
  "2.tmpl": [ [ 1, 0, [ "element" ], "div", [ 2, 0, 0, "id", "mylist" ], [ 1, 0, 0, "h2", [ 3, 0, 0, "Teams" ] ], [ 1, 1, [ "childNodesElement" ], "ul" ] ] ],
  "3.tmpl": [ [ 1, 0, [ "element" ], "li", [ 3, 1, [ "name" ] ], [ 3, 0, 0, " " ], [ 1, 0, 0, "button", [ 6, "click", "selectTeam" ], [ 3, 0, 0, "details" ] ] ] ],
  "9.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, 0, 0, "team" ], [ 1, 0, 0, "h1", [ 3, 0, 0, "Team " ], [ 3, 1, [ "code" ] ] ], [ 1, 1, [ "childNodesElement" ], "div" ] ] ],
  "d.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Calendar" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-Header" ], [ 1, 1, [ "sectionTabs" ], "div", [ 4, 0, 0, "Basis-Calendar-SectionTabs" ] ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-Body" ], [ 1, 0, 0, "span", [ 6, "click", "movePrev" ], [ 4, 0, 0, "Basis-Calendar-ButtonPrevPeriod" ], [ 1, 0, 0, "span", [ 3, 0, 0, "‹" ] ] ], [ 1, 0, 0, "span", [ 6, "click", "moveNext" ], [ 4, 0, 0, "Basis-Calendar-ButtonNextPeriod" ], [ 1, 0, 0, "span", [ 3, 0, 0, "›" ] ] ], [ 1, 0, [ "content", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-Calendar-Content" ] ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-Footer" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-Footer-Date" ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-Footer-Label" ], [ 3, "l10n:today@0.l10n", 0 ], [ 3, 0, 0, ":" ] ], [ 1, 0, 0, "span", [ 6, "click", "selectToday" ], [ 4, 0, 0, "Basis-Calendar-Footer-Value" ], [ 3, 1, [ "today" ] ] ] ] ] ] ],
  "e.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "Basis-Calendar-Section-", "sectionName", 0, [ "Month", "Year", "YearDecade", "Century", "YearQuarter", "Quarter" ] ], [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Calendar-Section" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-SectionTitle" ], [ 3, 1, [ "title" ] ] ], [ 1, 1, [ "childNodesElement" ], "div", [ 4, 0, 0, "Basis-Calendar-SectionContent" ] ] ], [ 1, 1, [ "tabElement" ], "div", [ 4, [ [ "", "selected", 0 ] ], 0, "Basis-Calendar-SectionTab" ], [ 6, "click", "select" ], [ 3, 1, [ "tabTitle" ] ] ] ],
  "f.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Calendar-Section Basis-Calendar-Section-Month" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-SectionTitle" ], [ 3, 1, [ "title" ] ], [ 3, 0, 0, " " ], [ 3, 1, [ "year" ] ] ], [ 1, 0, [ "content", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-Calendar-SectionContent" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays" ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.mon@0.l10n", 0 ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.tue@0.l10n", 0 ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.wed@0.l10n", 0 ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.thr@0.l10n", 0 ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.fri@0.l10n", 0 ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.sat@0.l10n", 0 ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-Calendar-MonthWeekDays-Day" ], [ 3, "l10n:day2.sun@0.l10n", 0 ] ] ] ] ], [ 1, 1, [ "tabElement" ], "div", [ 4, [ [ "", "selected", 0 ] ], 0, "Basis-Calendar-SectionTab" ], [ 6, "click", "select" ], [ 3, 1, [ "tabTitle" ] ] ] ],
  "g.tmpl": [ [ 1, 0, [ "element" ], "a", [ 4, [ [ "", "nodePeriodName", 0, [ "day", "month", "year", "decade", "quarter" ] ], [ "", "selected", 0 ], [ "", "disabled", 0 ], [ "", "before", 0 ], [ "", "after", 0 ] ], 0, "Basis-Calendar-Node" ], [ 6, "click" ], [ 3, 1, [ "title" ] ] ] ],
  "4.tmpl": [ [ 1, 0, [ "element" ], "div", [ 1, 0, 0, "div", [ 2, 0, 0, "id", "sidebar" ], [ 8, 1, [ "calendar" ] ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "float_left" ], [ 8, 1, [ "button" ] ] ], [ 1, 0, 0, "div", [ 2, 0, 0, "id", "content" ], [ 8, 1, [ "teamsList" ] ] ] ] ],
  "h.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "popup-", "orientation", 0, [ "v-left-top", "v-right-top", "v-center-top", "v-left-center", "v-right-center", "v-center-center", "v-left-bottom", "v-right-bottom", "v-center-bottom", "h-left-top", "h-right-top", "h-center-top", "h-left-center", "h-right-center", "h-center-center", "h-left-bottom", "h-right-bottom", "h-center-bottom" ] ], [ "", "anim:visible", 2, [ "visible", "hidden" ] ], [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Popup hidden" ], [ 1, 0, [ "content", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-Popup-Content" ] ] ] ],
  "i.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "mode-", "orientation", 0, [ "v-left-top", "v-right-top", "v-center-top", "v-left-center", "v-right-center", "v-center-center", "v-left-bottom", "v-right-bottom", "v-center-bottom", "h-left-top", "h-right-top", "h-center-top", "h-left-center", "h-right-center", "h-center-center", "h-left-bottom", "h-right-bottom", "h-center-bottom" ] ], [ "", "anim:visible", 2, [ "visible", "hidden" ] ], [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Balloon hidden" ], [ 6, "click" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Balloon-Canvas" ], [ 1, 0, 0, "div", [ 4, 0, 0, "corner-left-top" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "corner-right-top" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "side-top" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "side-left" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "side-right" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "content" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "corner-left-bottom" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "corner-right-bottom" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "side-bottom" ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "tail" ] ] ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Balloon-Layout" ], [ 1, 0, [ "content", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-Balloon-Content" ] ] ] ] ],
  "j.tmpl": [ [ 1, 0, [ "element" ], "div", [ 2, 0, 0, "id", "Basis-PopupStack" ], [ 4, [ [ "", "hasChildren", 0 ] ], 0, "" ] ] ],
  "8.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, 0, 0, "employee" ], [ 1, 0, 0, "div", [ 4, 0, 0, "name" ], [ 3, 1, [ "name" ] ] ], [ 1, 1, [ "childNodesElement" ], "div" ] ] ],
  "k.tmpl": [ [ 1, 0, [ "element" ], "span", [ 4, 0, 0, "Basis-Field-Sample" ], [ 3, 1, [ "example" ] ] ] ],
  "l.tmpl": [ [ 1, 0, [ "element" ], "span", [ 4, 0, 0, "Basis-Field-Description" ], [ 3, 1, [ "description" ] ] ] ],
  "m.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, 0, 0, "Basis-Field-LengthCounter" ], [ 3, "l10n:symbolsLeft@1.l10n", 0 ], [ 3, 0, 0, ": " ], [ 3, 1, [ "availChars" ] ] ] ],
  "n.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 8, 1, [ "fieldPlace" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "o.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "file" ], [ 4, 0, 0, "native-type-file" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 6, "change" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "p.tmpl": [ [ 1, 1, [ "field", "element" ], "input", [ 2, 0, 0, "type", "hidden" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 6, "change" ] ] ],
  "q.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "text" ], [ 4, 0, 0, "native-type-text" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "maxlength" ], [ 0 ] ], 0, "maxlength", "{maxlength}" ], [ 2, [ [ "autocomplete" ], [ 0 ] ], 0, "autocomplete", "{autocomplete}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "input" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "r.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "password" ], [ 4, 0, 0, "native-type-password" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "maxlength" ], [ 0 ] ], 0, "maxlength", "{maxlength}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "input" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "0.tmpl": [ [ 1, 0, [ "element" ], "div", [ 1, 0, 0, "h2", [ 3, 0, 0, "Agenda" ] ], [ 1, 1, [ "childNodesElement" ], "ul" ] ] ],
  "t.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field-Checkbox indeterminate" ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, 0, "label", [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "checkbox" ], [ 4, 0, 0, "native-type-checkbox" ], [ 2, [ [ "checked" ], [ 0 ] ], 0, "checked", "{checked}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "indeterminate" ], [ 0 ] ], 0, "indeterminate", "{indeterminate}" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ] ], [ 1, 0, 0, "span", [ 3, 1, [ "titleText" ] ] ] ] ] ] ],
  "u.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate Basis-Field-Label" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 1, [ "field" ], "label", [ 3, 1, [ "value" ] ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "v.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-RadioGroup" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "w.tmpl": [ [ 1, 0, [ "element" ], "label", [ 4, [ [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-RadioGroup-Item" ], [ 6, "click", "select" ], [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "radio" ], [ 4, 0, 0, "native-type-radio" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "checked" ], [ 0 ] ], 0, "checked", "{checked}" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ] ], [ 1, 1, [ "content" ], "span", [ 3, 1, [ "title" ] ] ] ] ],
  "x.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-CheckGroup" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "y.tmpl": [ [ 1, 0, [ "element" ], "label", [ 4, [ [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-CheckGroup-Item" ], [ 6, "click", "select" ], [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "checkbox" ], [ 4, 0, 0, "native-type-checkbox" ], [ 2, [ [ "checked" ], [ 0 ] ], 0, "checked", "{checked}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "indeterminate" ], [ 0 ] ], 0, "indeterminate", "{indeterminate}" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ] ], [ 1, 1, [ "content" ], "span", [ 3, 1, [ "title" ] ] ] ] ],
  "z.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus", "childNodesElement" ], "select", [ 4, [ [ "", "disabled", 0 ], [ "", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Select indeterminate" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "multiple" ], [ 0 ] ], 0, "multiple", "{multiple}" ], [ 6, "change" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "keydown" ], [ 6, "focus" ], [ 6, "blur" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "10.tmpl": [ [ 1, 1, [ "field", "element" ], "option", [ 4, 0, 0, "Basis-Select-Item" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "selected" ], [ 0 ] ], 0, "selected", "{selected}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 3, 1, [ "title" ] ] ] ],
  "11.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, "content", 0, "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus" ], "span", [ 4, [ [ "Basis-DropdownList-", "opened", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-DropdownList" ], [ 6, "click", "togglePopup" ], [ 6, "keyup" ], [ 6, "keydown" ], [ 6, "keypressed" ], [ 6, "focus" ], [ 6, "blur" ], [ 2, 0, 0, "tabindex", "0" ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-DropdownList-Caption" ], [ 8, 1, [ "captionItem" ] ] ], [ 1, 0, 0, "span", [ 4, 0, 0, "Basis-DropdownList-Trigger" ] ], [ 8, 1, [ "hiddenField" ] ] ], [ 1, 0, [ "content", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-DropdownList-PopupContent" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "12.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Combobox-Item" ], [ 6, "click", "select" ], [ 3, 1, [ "title" ] ] ] ],
  "13.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "popup-", "orientation", 0, [ "v-left-top", "v-right-top", "v-center-top", "v-left-center", "v-right-center", "v-center-center", "v-left-bottom", "v-right-bottom", "v-center-bottom", "h-left-top", "h-right-top", "h-center-top", "h-left-center", "h-right-center", "h-center-center", "h-left-bottom", "h-right-bottom", "h-center-bottom" ] ], [ "", "anim:visible", 2, [ "visible", "hidden" ] ], [ "", "selected", 0 ], [ "", "disabled", 0 ] ], 0, "Basis-Popup hidden Basis-DropdownList-Popup" ], [ 1, 0, [ "content", "childNodesElement" ], "div", [ 4, 0, 0, "Basis-Popup-Content" ] ] ] ],
  "14.tmpl": [ [ 1, 1, [ "sampleContainer", "element" ], "div", [ 4, [ [ "", "disabled", 0 ], [ "", "focused", 0 ], [ "Basis-Field__", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Field Basis-Field__indeterminate Basis-MatchInput" ], [ 2, [ [ "error" ], [ 0 ] ], 0, "title", "{error}" ], [ 1, 0, 0, "div", [ 4, 0, 0, "Basis-Field-Title" ], [ 1, 0, 0, "label", [ 1, 1, [ "title" ], "span", [ 3, 1, [ "titleText" ] ] ] ] ], [ 1, 1, [ "content" ], "div", [ 4, 0, 0, "Basis-Field-Container" ], [ 1, 0, [ "field", "focus" ], "input", [ 2, 0, 0, "type", "text" ], [ 4, 0, 0, "native-type-text" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "maxlength" ], [ 0 ] ], 0, "maxlength", "{maxlength}" ], [ 2, [ [ "autocomplete" ], [ 0 ] ], 0, "autocomplete", "{autocomplete}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "input" ] ] ], [ 8, 1, [ "description" ] ], [ 8, 1, [ "example" ] ] ] ],
  "15.tmpl": [ [ 1, 0, [ "field", "focus", "element" ], "input", [ 2, 0, 0, "type", "text" ], [ 4, 0, 0, "native-type-text" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "maxlength" ], [ 0 ] ], 0, "maxlength", "{maxlength}" ], [ 2, [ [ "autocomplete" ], [ 0 ] ], 0, "autocomplete", "{autocomplete}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "input" ] ] ],
  "16.tmpl": [ [ 1, 0, [ "field", "focus", "element" ], "input", [ 2, 0, 0, "type", "password" ], [ 4, 0, 0, "native-type-password" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "maxlength" ], [ 0 ] ], 0, "maxlength", "{maxlength}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "input" ] ] ],
  "17.tmpl": [ [ 1, 0, [ "field", "focus", "element" ], "textarea", [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "placeholder" ], [ 0 ] ], 0, "placeholder", "{placeholder}" ], [ 6, "keydown" ], [ 6, "keyup", "keyup updateSymbolsLeft" ], [ 6, "keypress" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change", "change updateSymbolsLeft" ], [ 6, "input", "input updateSymbolsLeft" ] ] ],
  "18.tmpl": [ [ 1, 0, [ "field", "focus", "element" ], "input", [ 2, 0, 0, "type", "checkbox" ], [ 4, 0, 0, "native-type-checkbox" ], [ 2, [ [ "checked" ], [ 0 ] ], 0, "checked", "{checked}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "readonly" ], [ 0 ] ], 0, "readonly", "{readonly}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "indeterminate" ], [ 0 ] ], 0, "indeterminate", "{indeterminate}" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ] ] ],
  "19.tmpl": [ [ 1, 0, [ "field", "focus", "element" ], "input", [ 2, 0, 0, "type", "radio" ], [ 4, 0, 0, "native-type-radio" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "value" ], [ 0 ] ], 0, "value", "{value}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "checked" ], [ 0 ] ], 0, "checked", "{checked}" ], [ 6, "focus" ], [ 6, "blur" ], [ 6, "change" ], [ 6, "keydown" ], [ 6, "keyup" ], [ 6, "keypress" ] ] ],
  "1a.tmpl": [ [ 1, 0, [ "field", "focus", "childNodesElement", "element" ], "select", [ 4, [ [ "", "disabled", 0 ], [ "", "validity", 1, [ "indeterminate", "valid", "invalid" ] ] ], 0, "Basis-Select indeterminate" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 2, [ [ "multiple" ], [ 0 ] ], 0, "multiple", "{multiple}" ], [ 6, "change" ], [ 6, "keyup" ], [ 6, "keypress" ], [ 6, "keydown" ], [ 6, "focus" ], [ 6, "blur" ] ] ],
  "1b.tmpl": [ [ 1, 0, [ "field", "focus", "element" ], "input", [ 2, 0, 0, "type", "file" ], [ 4, 0, 0, "native-type-file" ], [ 2, [ [ "name" ], [ 0 ] ], 0, "name", "{name}" ], [ 2, [ [ "disabled" ], [ 0 ] ], 0, "disabled", "{disabled}" ], [ 6, "change" ] ] ],
  "5.tmpl": [ [ 1, 0, [ "element" ], "div", [ 1, 0, 0, "p", [ 3, 0, 0, "You are currently logged in as " ], [ 1, 0, 0, "span", [ 2, 0, 0, "id", "username" ], [ 3, 1, [ "loggedInAs" ] ] ] ], [ 1, 0, 0, "p", [ 4, 0, 0, "lead" ], [ 3, 0, 0, "Say something worthwhile here." ] ], [ 1, 0, 0, "div", [ 5, [ [ [ "loginDisplay" ], [ 0 ], "display" ] ], 0 ], [ 8, 1, [ "username" ] ], [ 8, 1, [ "password" ] ], [ 8, 1, [ "button" ] ] ] ] ],
  "6.tmpl": [ [ 1, 0, [ "element" ], "td", [ 4, [ [ "", "weekend" ], [ "type_", "type" ], [ "", "checked" ] ], 0, "day" ], [ 6, "click", "dayClick" ], [ 1, 0, 0, "span", [ 3, 1, [ "title" ] ] ] ] ],
  "7.tmpl": [ [ 1, 0, [ "element" ], "div", [ 4, [ [ "", "isActive" ] ], 0, "" ], [ 1, 0, 0, "div", [ 4, 0, 0, "month_title" ], [ 1, 0, 0, "p", [ 3, 1, [ "name" ] ], [ 3, 0, 0, " - " ], [ 3, 1, [ "year" ] ] ], [ 1, 0, 0, "p", [ 3, 0, 0, "working scheme: 5/2" ] ], [ 1, 0, 0, "p", [ 3, 0, 0, "working days: " ], [ 3, 1, [ "workingDays" ] ] ] ], [ 1, 0, 0, "table", [ 4, 0, 0, "month" ], [ 1, 0, 0, "tbody", [ 1, 1, [ "childNodesElement" ], "tr" ] ] ] ] ],
  "2.l10n": {
    "en-US": {
      validator: {
        regExpWrongFormat: "The value has wrong format.",
        required: "The field is required and must have a value.",
        numberWrongFormat: "The value has wrong format of number.",
        currencyWrongFormat: "The value has wrong format of currency.",
        currencyMustBeGreaterZero: "The value must be greater than zero.",
        emailWrongFormat: "The value has a wrong format of e-mail.",
        urlWrongFormat: "The value has a wrong format of URL.",
        minLengthError: "The value must be longer than {0} symbols.",
        maxLengthError: "The value must be shorter than {0} symbols."
      }
    },
    "ru-RU": {
      validator: {
        regExpWrongFormat: "Значение имеет неверный формат.",
        required: "Поле не должно оставаться пустым.",
        numberWrongFormat: "Поле имеет неверный формат числа.",
        currencyWrongFormat: "Поле имеет неверный формат суммы.",
        currencyMustBeGreaterZero: "Сумма должна быть больше нуля.",
        emailWrongFormat: "Поле имеет неверный формат e-mail.",
        urlWrongFormat: "Поле имеет неверный формат URL.",
        minLengthError: "Значение не должно быть короче {0} символов.",
        maxLengthError: "Значение не должно быть длиннее {0} символов."
      }
    },
    "uk-UA": {
      validator: {
        regExpWrongFormat: "Значення має невірний формат.",
        required: "Поле не повинно бути пустим.",
        numberWrongFormat: "Поле має невірний формат числа.",
        currencyWrongFormat: "Поле має невірний формат суми.",
        currencyMustBeGreaterZero: "Сума повинна бути більше нуля.",
        emailWrongFormat: "Поле має невірний формат e-mail.",
        urlWrongFormat: "Поле має невірний формат URL.",
        minLengthError: "Значення не повинно бути коротше {0} символів.",
        maxLengthError: "Значення не має бути довшим {0} символів."
      }
    }
  },
  "0.l10n": {
    "en-US": {
      quarter: "Quarter",
      today: "Today",
      selected: "Selected",
      month: {
        jan: "January",
        feb: "February",
        mar: "March",
        apr: "April",
        may: "May",
        jun: "June",
        jul: "July",
        aug: "August",
        sep: "September",
        oct: "October",
        nov: "November",
        dec: "December"
      },
      monthShort: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      },
      day: {
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thr: "Thursday",
        fri: "Friday",
        sat: "Saturday",
        sun: "Sunday"
      },
      day2: {
        mon: "Mo",
        tue: "Tu",
        wed: "We",
        thr: "Th",
        fri: "Fr",
        sat: "Sa",
        sun: "Su"
      },
      day3: {
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thr: "Thr",
        fri: "Fri",
        sat: "Sat",
        sun: "Sun"
      }
    },
    "ru-RU": {
      quarter: "Квартал",
      today: "Сегодня",
      selected: "Выбрано",
      month: {
        jan: "Январь",
        feb: "Февраль",
        mar: "Март",
        apr: "Апрель",
        may: "Май",
        jun: "Июнь",
        jul: "Июль",
        aug: "Август",
        sep: "Сентябрь",
        oct: "Октябрь",
        nov: "Ноябрь",
        dec: "Декабрь"
      },
      monthShort: {
        jan: "Янв",
        feb: "Фев",
        mar: "Мар",
        apr: "Апр",
        may: "Май",
        jun: "Июн",
        jul: "Июл",
        aug: "Авг",
        sep: "Сен",
        oct: "Окт",
        nov: "Ноя",
        dec: "Дек"
      },
      day: {
        mon: "Понедельник",
        tue: "Вторник",
        wed: "Среда",
        thr: "Четверг",
        fri: "Пятница",
        sat: "Суббота",
        sun: "Воскресенье"
      },
      day2: {
        mon: "Пн",
        tue: "Вт",
        wed: "Ср",
        thr: "Чт",
        fri: "Пт",
        sat: "Сб",
        sun: "Вс"
      },
      day3: {
        mon: "Пн",
        tue: "Вт",
        wed: "Ср",
        thr: "Чт",
        fri: "Пт",
        sat: "Сб",
        sun: "Вс"
      }
    },
    "uk-UA": {
      quarter: "Квартал",
      today: "Сьогодні",
      selected: "Вибрані",
      month: {
        jan: "Січня",
        feb: "Лютого",
        mar: "Березня",
        apr: "Квітня",
        may: "Травня",
        jun: "Червня",
        jul: "Липня",
        aug: "Серпня",
        sep: "Вересня",
        oct: "Жовтня",
        nov: "Листопада",
        dec: "Грудня"
      },
      monthShort: {
        jan: "Січ",
        feb: "Лют",
        mar: "Бер",
        apr: "Кві",
        may: "Тра",
        jun: "Чер",
        jul: "Лип",
        aug: "Сер",
        sep: "Вер",
        oct: "Жов",
        nov: "Лис",
        dec: "Гру"
      },
      day: {
        mon: "Понеділок",
        tue: "Вівторок",
        wed: "Середа",
        thr: "Четвер",
        fri: "П'ятниця",
        sat: "Субота",
        sun: "Неділя"
      },
      day2: {
        mon: "Пн",
        tue: "Вт",
        wed: "Ср",
        thr: "Чт",
        fri: "Пт",
        sat: "Сб",
        sun: "Нд"
      },
      day3: {
        mon: "Пн",
        tue: "Вт",
        wed: "Ср",
        thr: "Чт",
        fri: "Пт",
        sat: "Сб",
        sun: "Нд"
      }
    }
  },
  "1.l10n": {
    "en-US": {
      symbolsLeft: "Symbols left"
    },
    "ru-RU": {
      symbolsLeft: "Осталось символов"
    },
    "uk-UA": {
      symbolsLeft: "Залишилося символів"
    }
  },
  "2.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    var namespace = this.path;
    var Class = basis.Class;
    var Emitter = basis.event.Emitter;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    basis.resource.extensions[".l10n"] = function(content, url) {
      return resolveDictionary(url).update(basis.resource.extensions[".json"](content, url));
    };
    function ownKeys(object) {
      var result = [];
      for (var key in object) if (hasOwnProperty.call(object, key)) result.push(key);
      return result;
    }
    var tokenIndex = [];
    var tokenComputeFn = {};
    var tokenComputes = {};
    var updateToken = basis.Token.prototype.set;
    var ComputeToken = Class(basis.Token, {
      className: namespace + ".ComputeToken",
      init: function(value, token) {
        token.computeTokens[this.basisObjectId] = this;
        this.token = token;
        basis.Token.prototype.init.call(this, value);
      },
      get: function() {
        var key = this.token.type == "plural" ? cultures[currentCulture].plural(this.value) : this.value;
        return this.token.dictionary.getValue(this.token.name + "." + key);
      },
      toString: function() {
        return this.get();
      },
      destroy: function() {
        delete this.token.computeTokens[this.basisObjectId];
        this.token = null;
        basis.Token.prototype.destroy.call(this);
      }
    });
    var Token = Class(basis.Token, {
      className: namespace + ".Token",
      index: NaN,
      dictionary: null,
      name: "",
      type: "default",
      computeTokens: null,
      init: function(dictionary, tokenName, type, value) {
        basis.Token.prototype.init.call(this, value);
        this.index = tokenIndex.push(this) - 1;
        this.name = tokenName;
        this.dictionary = dictionary;
        this.computeTokens = {};
        if (type) this.setType(type); else this.apply();
      },
      toString: function() {
        return this.get();
      },
      apply: function() {
        for (var key in this.computeTokens) this.computeTokens[key].apply();
        basis.Token.prototype.apply.call(this);
      },
      set: function() {
        basis.dev.warn("basis.l10n: Value for l10n token can't be set directly, but through dictionary update only");
      },
      setType: function(type) {
        if (type != "plural" && (!basis.l10n.enableMarkup || type != "markup")) type = "default";
        if (this.type != type) {
          this.type = type;
          this.apply();
        }
      },
      compute: function(events, getter) {
        if (arguments.length == 1) {
          getter = events;
          events = "";
        }
        getter = basis.getter(getter);
        events = String(events).trim().split(/\s+|\s*,\s*/).sort();
        var tokenId = this.basisObjectId;
        var enumId = events.concat(tokenId, getter[basis.getter.ID]).join("_");
        if (tokenComputeFn[enumId]) return tokenComputeFn[enumId];
        var token = this;
        var objectTokenMap = {};
        var updateValue = function(object) {
          updateToken.call(this, getter(object));
        };
        var handler = {
          destroy: function(object) {
            delete objectTokenMap[object.basisObjectId];
            this.destroy();
          }
        };
        for (var i = 0, eventName; eventName = events[i]; i++) if (eventName != "destroy") handler[eventName] = updateValue;
        return tokenComputeFn[enumId] = function(object) {
          if (object instanceof Emitter == false) throw "basis.l10n.Token#compute: object must be an instanceof Emitter";
          var objectId = object.basisObjectId;
          var computeToken = objectTokenMap[objectId];
          if (!computeToken) {
            computeToken = objectTokenMap[objectId] = new ComputeToken(getter(object), token);
            object.addHandler(handler, computeToken);
          }
          return computeToken;
        };
      },
      computeToken: function(value) {
        return new ComputeToken(value, this);
      },
      token: function(name) {
        if (this.type == "plural") name = cultures[currentCulture].plural(name);
        if (this.dictionary) return this.dictionary.token(this.name + "." + name);
      },
      destroy: function() {
        for (var key in this.computeTokens) this.computeTokens[key].destroy();
        this.computeTokens = null;
        this.value = null;
        basis.Token.prototype.destroy.call(this);
      }
    });
    function resolveToken(path) {
      if (path.charAt(0) == "#") {
        return tokenIndex[parseInt(path.substr(1), 36)];
      } else {
        var parts = path.match(/^(.+?)@(.+)$/);
        if (parts) return resolveDictionary(basis.path.resolve(parts[2])).token(parts[1]);
        basis.dev.warn("basis.l10n.token accepts token references in format `token.path@path/to/dict.l10n` only");
      }
    }
    var dictionaries = [];
    var dictionaryByUrl = {};
    var createDictionaryNotifier = new basis.Token;
    function walkTokens(dictionary, culture, tokens, path) {
      var cultureValues = dictionary.cultureValues[culture];
      path = path ? path + "." : "";
      for (var name in tokens) if (hasOwnProperty.call(tokens, name)) {
        var tokenName = path + name;
        var tokenValue = tokens[name];
        cultureValues[tokenName] = tokenValue;
        if (tokenValue && (typeof tokenValue == "object" || Array.isArray(tokenValue))) walkTokens(dictionary, culture, tokenValue, tokenName);
      }
    }
    var Dictionary = Class(null, {
      className: namespace + ".Dictionary",
      tokens: null,
      types: null,
      cultureValues: null,
      index: NaN,
      resource: null,
      init: function(content) {
        this.tokens = {};
        this.types = {};
        this.cultureValues = {};
        this.index = dictionaries.push(this) - 1;
        if (basis.resource.isResource(content)) {
          var resource = content;
          this.resource = resource;
          if (!dictionaryByUrl[resource.url]) {
            dictionaryByUrl[resource.url] = this;
            createDictionaryNotifier.set(resource.url);
          }
          resource.fetch();
        } else {
          basis.dev.warn("Use object as content of dictionary is experimental and not production-ready");
          this.update(content || {});
        }
      },
      update: function(data) {
        if (!data) data = {};
        this.cultureValues = {};
        for (var culture in data) if (!/^_|_$/.test(culture)) {
          this.cultureValues[culture] = {};
          walkTokens(this, culture, data[culture]);
        }
        this.types = data._meta && data._meta.type || {};
        for (var key in this.tokens) this.tokens[key].setType(this.types[key]);
        this.syncValues();
        return this;
      },
      syncValues: function() {
        for (var tokenName in this.tokens) updateToken.call(this.tokens[tokenName], this.getValue(tokenName));
      },
      getValue: function(tokenName) {
        var fallback = cultureFallback[currentCulture] || [];
        for (var i = 0, cultureName; cultureName = fallback[i]; i++) {
          var cultureValues = this.cultureValues[cultureName];
          if (cultureValues && tokenName in cultureValues) return cultureValues[tokenName];
        }
      },
      getCultureValue: function(culture, tokenName) {
        return this.cultureValues[culture] && this.cultureValues[culture][tokenName];
      },
      token: function(tokenName) {
        var token = this.tokens[tokenName];
        if (!token) {
          token = this.tokens[tokenName] = new Token(this, tokenName, this.types[tokenName], this.getValue(tokenName));
        }
        return token;
      },
      destroy: function() {
        this.tokens = null;
        this.cultureValues = null;
        basis.array.remove(dictionaries, this);
        if (this.resource) {
          delete dictionaryByUrl[this.resource.url];
          this.resource = null;
        }
      }
    });
    function resolveDictionary(source) {
      var dictionary;
      if (typeof source == "string") {
        var location = source;
        var extname = basis.path.extname(location);
        if (extname != ".l10n") location = basis.path.dirname(location) + "/" + basis.path.basename(location, extname) + ".l10n";
        source = basis.resource(location);
      }
      if (basis.resource.isResource(source)) dictionary = dictionaryByUrl[source.url];
      return dictionary || new Dictionary(source);
    }
    function getDictionaries() {
      return dictionaries.slice(0);
    }
    var cultureList = [];
    var currentCulture = null;
    var cultures = {};
    var cultureFallback = {};
    var pluralFormsMap = {};
    var pluralForms = [ [ 1, function(n) {
      return 0;
    } ], [ 2, function(n) {
      return n == 1 || n % 10 == 1 ? 0 : 1;
    } ], [ 2, function(n) {
      return n == 0 ? 0 : 1;
    } ], [ 2, function(n) {
      return n == 1 ? 0 : 1;
    } ], [ 2, function(n) {
      return n == 0 || n == 1 ? 0 : 1;
    } ], [ 2, function(n) {
      return n % 10 != 1 || n % 100 == 11 ? 1 : 0;
    } ], [ 3, function(n) {
      return n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
    } ], [ 3, function(n) {
      return n % 10 == 1 && n % 100 != 11 ? 0 : n != 0 ? 1 : 2;
    } ], [ 3, function(n) {
      return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
    } ], [ 3, function(n) {
      return n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
    } ], [ 3, function(n) {
      return n == 0 ? 0 : n == 1 ? 1 : 2;
    } ], [ 3, function(n) {
      return n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2;
    } ], [ 3, function(n) {
      return n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;
    } ], [ 3, function(n) {
      return n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;
    } ], [ 4, function(n) {
      return n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3;
    } ], [ 4, function(n) {
      return n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3;
    } ], [ 4, function(n) {
      return n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0;
    } ], [ 4, function(n) {
      return n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3;
    } ], [ 4, function(n) {
      return n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3;
    } ], [ 5, function(n) {
      return n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4;
    } ], [ 6, function(n) {
      return n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
    } ] ];
    [ "ay bo cgg dz fa id ja jbo ka kk km ko ky lo ms my sah su th tt ug vi wo zh", "mk", "jv", "af an ast az bg bn brx ca da de doi el en eo es es-AR et eu ff fi fo fur fy gl gu ha he hi hne hu hy ia it kn ku lb mai ml mn mni mr nah nap nb ne nl nn no nso or pa pap pms ps pt rm rw sat sco sd se si so son sq sv sw ta te tk ur yo", "ach ak am arn br fil fr gun ln mfe mg mi oc pt-BR tg ti tr uz wa zh", "is", "csb", "lv", "lt", "be bs hr ru sr uk", "mnk", "ro", "pl", "cs sk", "cy", "kw", "sl", "mt", "gd", "ga", "ar" ].forEach(function(langs, idx) {
      langs.split(" ").forEach(function(lang) {
        pluralFormsMap[lang] = this;
      }, pluralForms[idx]);
    });
    var Culture = basis.Class(null, {
      className: namespace + ".Culture",
      name: "",
      pluralForm: null,
      init: function(name, pluralForm) {
        this.name = name;
        if (!cultures[name]) cultures[name] = this;
        this.pluralForm = pluralForm || pluralFormsMap[name] || pluralFormsMap[name.split("-")[0]] || pluralForms[0];
      },
      plural: function(value) {
        return Number(this.pluralForm[1](Math.abs(parseInt(value, 10))));
      }
    });
    function resolveCulture(name, pluralForm) {
      if (name && !cultures[name]) cultures[name] = new Culture(name, pluralForm);
      return cultures[name || currentCulture];
    }
    basis.object.extend(resolveCulture, new basis.Token);
    resolveCulture.set = setCulture;
    function getCulture() {
      return currentCulture;
    }
    function setCulture(culture) {
      if (!culture) return;
      if (currentCulture != culture) {
        if (cultureList.indexOf(culture) == -1) {
          basis.dev.warn("basis.l10n.setCulture: culture `" + culture + "` not in the list, the culture isn't changed");
          return;
        }
        currentCulture = culture;
        for (var i = 0, dictionary; dictionary = dictionaries[i]; i++) dictionary.syncValues();
        basis.Token.prototype.set.call(resolveCulture, culture);
      }
    }
    function getCultureList() {
      return cultureList.slice(0);
    }
    function setCultureList(list) {
      if (typeof list == "string") list = list.trim().split(" ");
      if (!list.length) {
        basis.dev.warn("basis.l10n.setCultureList: culture list can't be empty, the culture list isn't changed");
        return;
      }
      var cultures = {};
      var cultureRow;
      var baseCulture;
      cultureFallback = {};
      for (var i = 0, culture, cultureName; culture = list[i]; i++) {
        cultureRow = culture.split("/");
        if (cultureRow.length > 2) {
          basis.dev.warn("basis.l10n.setCultureList: only one fallback culture can be set for certain culture, try to set `" + culture + "`; other cultures except first one was ignored");
          cultureRow = cultureRow.slice(0, 2);
        }
        cultureName = cultureRow[0];
        if (!baseCulture) baseCulture = cultureName;
        cultures[cultureName] = resolveCulture(cultureName);
        cultureFallback[cultureName] = cultureRow;
      }
      for (var cultureName in cultureFallback) {
        cultureFallback[cultureName] = basis.array.flatten(cultureFallback[cultureName].map(function(name) {
          return cultureFallback[name];
        })).concat(baseCulture).filter(function(item, idx, array) {
          return !idx || array.lastIndexOf(item, idx - 1) == -1;
        });
      }
      cultureList = basis.object.keys(cultures);
      if (currentCulture in cultures == false) setCulture(baseCulture);
    }
    function onCultureChange(fn, context, fire) {
      resolveCulture.attach(fn, context);
      if (fire) fn.call(context, currentCulture);
    }
    setCultureList("en-US");
    setCulture("en-US");
    module.exports = {
      ComputeToken: ComputeToken,
      Token: Token,
      token: resolveToken,
      Dictionary: Dictionary,
      dictionary: resolveDictionary,
      getDictionaries: getDictionaries,
      addCreateDictionaryHandler: createDictionaryNotifier.attach.bind(createDictionaryNotifier),
      removeCreateDictionaryHandler: createDictionaryNotifier.detach.bind(createDictionaryNotifier),
      Culture: Culture,
      culture: resolveCulture,
      getCulture: getCulture,
      setCulture: setCulture,
      getCultureList: getCultureList,
      setCultureList: setCultureList,
      pluralForms: pluralForms,
      onCultureChange: onCultureChange
    };
  },
  "u.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    basis.require("./e.js");
    basis.require("./g.js");
    var moment = basis.require("./v.js");
    var momentDate = moment();
    var monthsSource = [];
    var daysSource = [];
    var daysInYear = 365;
    for (var i = 0; i < 12; i++) {
      monthsSource.push({
        monthId: parseInt(momentDate.month(i).format("M"), 10),
        title: momentDate.month(i).format("MMMM")
      });
    }
    for (i = 0; i < daysInYear; i++) {
      daysSource.push({
        id: i,
        monthId: parseInt(momentDate.dayOfYear(i).format("M"), 10),
        title: momentDate.dayOfYear(i).format("DD"),
        isHoliday: false
      });
    }
    var Month = basis.entity.createType({
      name: "Month",
      fields: {
        monthId: basis.entity.IntId,
        title: String
      },
      all: {
        syncAction: function() {
          this.sync(monthsSource && monthsSource.map(this.wrapper.reader));
        }
      }
    });
    var Day = basis.entity.createType({
      name: "Day",
      autoDelegate: true,
      fields: {
        id: basis.entity.IntId,
        group: "Month",
        title: String,
        isHoliday: Boolean,
        isWeekend: Boolean
      },
      aliases: {
        monthId: "group"
      },
      all: {
        syncAction: function() {
          this.sync(daysSource && daysSource.map(this.wrapper.reader));
        }
      }
    });
    module.exports = basis.ui.Node.subclass({
      name: "PublicHolidaysYear",
      container: document.getElementById("placeHolder"),
      template: '<div class="days-list"><div{childNodesElement}/><div class="clearfix"></div></div>',
      dataSource: Day.all,
      active: true,
      selection: {
        multiple: true
      },
      childClass: {
        template: '<div class="day {selected} {isHoliday} {isWeekend}" event-click="select">' + "{title}" + "</div>",
        action: {
          select: function(event) {
            this.select(event.ctrlKey || event.metaKey);
          }
        },
        binding: {
          title: "data:",
          isHoliday: "data:",
          isWeekend: "data:"
        }
      },
      sorting: "data.id",
      grouping: {
        dataSource: Month.all,
        active: true,
        rule: "data.group",
        childClass: {
          template: '<div class="month">' + '<div class="month-Title" event-click="selectAll" title="Click to select all users in group">' + "{title}" + "</div>" + "</div>",
          action: {
            selectAll: function() {
              this.parentNode.owner.selection.set(this.nodes);
            }
          },
          binding: {
            title: "data:"
          }
        }
      },
      handler: {
        update: function() {
          var year = parseInt(this.data.year, 10);
          var momentDate = moment().date(1).month(0).year(year);
          daysSource = [];
          while (momentDate.format("YYYY") == year) {
            daysSource.push({
              id: momentDate.format("DDD"),
              monthId: parseInt(momentDate.format("M"), 10),
              title: momentDate.format("DD"),
              isHoliday: this.data.publicHolidays.hasOwnProperty(momentDate.format("YYYY-MM-DD")),
              isWeekend: [ 6, 7 ].indexOf(parseInt(momentDate.format("E"), 10)) >= 0
            });
            momentDate.add(1, "d");
          }
          Day.all.sync(daysSource && daysSource.map(Day.all.wrapper.reader));
        }
      }
    });
  },
  "e.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./4.js");
    basis.require("./f.js");
    var namespace = this.path;
    var Class = basis.Class;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var keys = basis.object.keys;
    var extend = basis.object.extend;
    var complete = basis.object.complete;
    var $self = basis.fn.$self;
    var getter = basis.getter;
    var arrayFrom = basis.array.from;
    var Emitter = basis.event.Emitter;
    var createEvent = basis.event.create;
    var DataObject = basis.data.Object;
    var Slot = basis.data.Slot;
    var Dataset = basis.data.Dataset;
    var Filter = basis.data.dataset.Filter;
    var Split = basis.data.dataset.Split;
    var NULL_INFO = {};
    var entityTypes = [];
    var isKeyType = {
      string: true,
      number: true
    };
    var NumericId = function(value) {
      return isNaN(value) ? null : Number(value);
    };
    var NumberId = function(value) {
      return isNaN(value) ? null : Number(value);
    };
    var IntId = function(value) {
      return isNaN(value) ? null : parseInt(value, 10);
    };
    var StringId = function(value) {
      return value == null ? null : String(value);
    };
    var untitledNames = {};
    function getUntitledName(name) {
      untitledNames[name] = untitledNames[name] || 0;
      return name + untitledNames[name]++;
    }
    var namedTypes = {};
    var namedIndexes = {};
    var deferredTypeDef = {};
    var TYPE_DEFINITION_PLACEHOLDER = function TYPE_DEFINITION_PLACEHOLDER() {};
    function resolveType(typeName, type) {
      var list = deferredTypeDef[typeName];
      if (list) {
        for (var i = 0, def; def = list[i]; i++) {
          var typeHost = def[0];
          var fieldName = def[1];
          typeHost[fieldName] = type;
        }
        delete deferredTypeDef[typeName];
      }
      namedTypes[typeName] = type;
    }
    function getTypeByName(typeName, typeHost, field) {
      if (namedTypes[typeName]) return namedTypes[typeName];
      var list = deferredTypeDef[typeName];
      if (!list) list = deferredTypeDef[typeName] = [];
      list.push([ typeHost, field ]);
      return function(value, oldValue) {
        var Type = namedTypes[typeName];
        if (Type) return Type(value, oldValue);
        if (arguments.length) basis.dev.warn(namespace + ": type `" + typeName + "` is not defined for " + field + ", but function called");
      };
    }
    function validateScheme() {
      for (var typeName in deferredTypeDef) basis.dev.warn(namespace + ": type `" + typeName + "` is not defined, but used by " + deferredTypeDef[typeName].length + " type(s)");
    }
    var warnPropertyAccess = function() {
      try {
        if (Object.defineProperty) {
          var obj = {};
          Object.defineProperty(obj, "x", {
            get: function() {
              return true;
            }
          });
          if (obj.x) {
            return function(object, name, value, warning) {
              Object.defineProperty(object, name, {
                get: function() {
                  basis.dev.warn(warning);
                  return value;
                },
                set: function(newValue) {
                  value = newValue;
                }
              });
            };
          }
        }
      } catch (e) {}
      return function() {};
    }();
    var Index = Class(null, {
      className: namespace + ".Index",
      items: null,
      init: function(fn) {
        this.items = {};
      },
      get: function(value, checkType) {
        var item = hasOwnProperty.call(this.items, value) && this.items[value];
        if (item && (!checkType || item.entityType === checkType)) return item;
      },
      add: function(value, newItem) {
        if (newItem) {
          var curItem = this.get(value);
          if (!curItem) {
            this.items[value] = newItem;
            return true;
          }
          if (curItem !== newItem) throw "basis.entity: Value `" + value + "` for index is already occupied";
        }
      },
      remove: function(value, item) {
        if (this.items[value] === item) {
          delete this.items[value];
          return true;
        }
      },
      destroy: function() {
        this.items = null;
      }
    });
    function CalculateField() {
      var names = arrayFrom(arguments);
      var calcFn = names.pop();
      var foo = names[0];
      var bar = names[1];
      var baz = names[2];
      var result;
      if (typeof calcFn != "function") throw "Last argument for calculate field constructor must be a function";
      switch (names.length) {
        case 0:
          result = function() {
            return calcFn();
          };
          break;
        case 1:
          result = function(delta, data, oldValue) {
            if (foo in delta) return calcFn(data[foo]);
            return oldValue;
          };
          break;
        case 2:
          result = function(delta, data, oldValue) {
            if (foo in delta || bar in delta) return calcFn(data[foo], data[bar]);
            return oldValue;
          };
          break;
        case 3:
          result = function(delta, data, oldValue) {
            if (foo in delta || bar in delta || baz in delta) return calcFn(data[foo], data[bar], data[baz]);
            return oldValue;
          };
          break;
        default:
          result = function(delta, data, oldValue) {
            var changed = false;
            var args = [];
            for (var i = 0, name; name = names[i]; i++) {
              changed = changed || name in delta;
              args.push(data[name]);
            }
            if (changed) return calcFn.apply(null, args);
            return oldValue;
          };
      }
      result = Function("calcFn", "names", "return " + result.toString().replace(/(foo|bar|baz)/g, function(m, w) {
        return '"' + names[w == "foo" ? 0 : w == "bar" ? 1 : 2] + '"';
      }).replace(/\[\"([^"]+)\"\]/g, ".$1"))(calcFn, names);
      result.args = names;
      result.calc = result;
      return result;
    }
    function ConcatStringField(name) {
      if (arguments.length == 1) return function(delta, data, oldValue) {
        if (name in delta) return data[name] != null ? String(data[name]) : null;
        return oldValue;
      };
      return CalculateField.apply(null, arrayFrom(arguments).concat(function() {
        for (var i = arguments.length - 1; i >= 0; i--) if (arguments[i] == null) return null;
        return Array.prototype.join.call(arguments, "-");
      }));
    }
    var ENTITYSET_WRAP_METHOD = function(superClass, method) {
      return function(data) {
        return superClass.prototype[method].call(this, data && data.map(this.wrapper));
      };
    };
    var ENTITYSET_INIT_METHOD = function(superClass, name) {
      return function() {
        if (!this.name) this.name = getUntitledName(name);
        superClass.prototype.init.call(this);
      };
    };
    var ENTITYSET_SYNC_METHOD = function(superClass) {
      return function(data) {
        var destroyItems = basis.object.slice(this.items_);
        var inserted = [];
        var deleted = [];
        if (data) {
          Dataset.setAccumulateState(true);
          for (var i = 0; i < data.length; i++) {
            var entity = this.wrapper(data[i]);
            if (entity) destroyItems[entity.basisObjectId] = false;
          }
          Dataset.setAccumulateState(false);
        }
        for (var key in this.items_) if (key in destroyItems == false) inserted.push(this.items_[key]);
        for (var key in destroyItems) if (destroyItems[key]) deleted.push(destroyItems[key]);
        if (deleted.length && this.wrapper.all) this.wrapper.all.emit_itemsChanged({
          deleted: deleted
        });
        Dataset.setAccumulateState(true);
        for (var i = 0; i < deleted.length; i++) deleted[i].destroy();
        Dataset.setAccumulateState(false);
        return inserted.length ? inserted : null;
      };
    };
    var EntitySet = Class(Dataset, {
      className: namespace + ".EntitySet",
      name: null,
      wrapper: $self,
      init: ENTITYSET_INIT_METHOD(Dataset, "EntitySet"),
      sync: ENTITYSET_SYNC_METHOD(Dataset),
      set: ENTITYSET_WRAP_METHOD(Dataset, "set"),
      add: ENTITYSET_WRAP_METHOD(Dataset, "add"),
      remove: ENTITYSET_WRAP_METHOD(Dataset, "remove"),
      destroy: function() {
        Dataset.prototype.destroy.call(this);
        this.wrapper = null;
      }
    });
    var ReadOnlyEntitySet = Class(EntitySet, {
      className: namespace + ".ReadOnlyEntitySet",
      set: basis.fn.$false,
      add: basis.fn.$false,
      remove: basis.fn.$false,
      clear: basis.fn.$false
    });
    var EntityCollection = Class(Filter, {
      className: namespace + ".EntityCollection",
      name: null,
      init: ENTITYSET_INIT_METHOD(Filter, "EntityCollection"),
      sync: ENTITYSET_SYNC_METHOD(Filter)
    });
    var EntityGrouping = Class(Split, {
      className: namespace + ".EntityGrouping",
      name: null,
      subsetClass: ReadOnlyEntitySet,
      init: ENTITYSET_INIT_METHOD(Split, "EntityGrouping"),
      sync: ENTITYSET_SYNC_METHOD(Split),
      getSubset: function(object, autocreate) {
        var group = Split.prototype.getSubset.call(this, object, autocreate);
        if (group && group.dataset) group.dataset.wrapper = this.wrapper;
        return group;
      }
    });
    var EntitySetWrapper = function(wrapper, name) {
      if (this instanceof EntitySetWrapper) {
        if (!wrapper) wrapper = $self;
        if (!name || namedTypes[name]) {
          if (namedTypes[name]) basis.dev.warn(namespace + ": Duplicate entity set type name `" + this.name + "`, name ignored");
          name = getUntitledName("UntitledEntitySetType");
        }
        var entitySetType = new EntitySetConstructor({
          entitySetClass: {
            className: namespace + ".EntitySet(" + (typeof wrapper == "string" ? wrapper : (wrapper.type || wrapper).name || "UnknownType") + ")",
            name: "Set of {" + (typeof wrapper == "string" ? wrapper : (wrapper.type || wrapper).name || "UnknownType") + "}",
            wrapper: wrapper
          }
        });
        var EntitySetClass = entitySetType.entitySetClass;
        var result = function(data, entitySet) {
          if (data != null) {
            if (entitySet instanceof EntitySet == false) entitySet = entitySetType.createEntitySet();
            entitySet.set(data instanceof Dataset ? data.getItems() : arrayFrom(data));
            return entitySet;
          } else return null;
        };
        if (typeof wrapper == "string") EntitySetClass.prototype.wrapper = getTypeByName(wrapper, EntitySetClass.prototype, "wrapper");
        resolveType(name, result);
        extend(result, {
          type: entitySetType,
          typeName: name,
          toString: function() {
            return name + "()";
          },
          reader: function(data) {
            if (Array.isArray(data)) {
              var wrapper = EntitySetClass.prototype.wrapper;
              return data.map(wrapper.reader || wrapper);
            }
            return data;
          },
          extendClass: function(source) {
            EntitySetClass.extend.call(EntitySetClass, source);
            return result;
          },
          extendReader: function(extReader) {
            var reader = result.reader;
            result.reader = function(data) {
              if (Array.isArray(data)) extReader(data);
              return reader(data);
            };
            return result;
          },
          entitySetType: entitySetType,
          extend: function() {
            basis.dev.warn("basis.entity: EntitySetType.extend() is deprecated, use EntitySetType.extendClass() instead.");
            return EntitySetClass.extend.apply(EntitySetClass, arguments);
          }
        });
        warnPropertyAccess(result, "entitySetType", entitySetType, "basis.entity: EntitySetType.entitySetType is deprecated, use EntitySetType.type instead.");
        return result;
      }
    };
    EntitySetWrapper.className = namespace + ".EntitySetWrapper";
    var EntitySetConstructor = Class(null, {
      className: namespace + ".EntitySetConstructor",
      entitySetClass: EntitySet,
      extendConstructor_: true,
      createEntitySet: function() {
        return new this.entitySetClass;
      }
    });
    var EntityTypeWrapper = function(config) {
      if (this instanceof EntityTypeWrapper) {
        var result;
        if (config.singleton) result = function(data) {
          var entity = entityType.get();
          if (entity) {
            if (data) entity.update(data);
          } else entity = new EntityClass(data || {});
          return entity;
        }; else result = function(data, entity) {
          if (data != null) {
            if (!entity || entity.entityType !== entityType) entity = null;
            if (data === entity || data.entityType === entityType) return data;
            var idValue;
            var idField = entityType.idField;
            if (isKeyType[typeof data]) {
              if (!idField) {
                if (entityType.compositeKey) basis.dev.warn("basis.entity: Entity type `" + entityType.name + "` wrapper was invoked with " + typeof data + " value as index, but entity type index is composite and consists of [" + keys(entityType.idFields).join(", ") + "] fields"); else basis.dev.warn("basis.entity: Entity type `" + entityType.name + "` wrapper was invoked with " + typeof data + " value as index, but entity type has no index");
                return;
              }
              if (entity = entityType.index.get(data, entityType)) return entity;
              idValue = data;
              data = {};
              data[idField] = idValue;
            } else {
              if (entityType.compositeKey) idValue = entityType.compositeKey(data, data);
              if (idValue != null) entity = entityType.index.get(idValue, entityType);
            }
            if (entity && entity.entityType === entityType) entity.update(data); else entity = new EntityClass(data);
            return entity;
          }
        };
        var entityType = new EntityTypeConstructor(config || {}, result);
        var EntityClass = entityType.entityClass;
        var name = entityType.name;
        resolveType(name, result);
        extend(result, {
          all: entityType.all,
          type: entityType,
          typeName: name,
          toString: function() {
            return name + "()";
          },
          get: function(data) {
            return entityType.get(data);
          },
          getSlot: function(id, defaults) {
            return entityType.getSlot(id, defaults);
          },
          reader: function(data) {
            return entityType.reader(data);
          },
          extendClass: function(source) {
            EntityClass.extend.call(EntityClass, source);
            return result;
          },
          extendReader: function(extReader) {
            var reader = result.reader;
            result.reader = function(data) {
              if (data && typeof data == "object") extReader(data);
              return reader(data);
            };
            return result;
          },
          entityType: entityType,
          extend: function() {
            basis.dev.warn("basis.entity: EntityType.extend() is deprecated, use EntityType.extendClass() instead.");
            return EntityClass.extend.apply(EntityClass, arguments);
          }
        });
        warnPropertyAccess(result, "entityType", entityType, "basis.entity: EntityType.entityType is deprecated, use EntityType.type instead.");
        return result;
      }
    };
    EntityTypeWrapper.className = namespace + ".EntityTypeWrapper";
    var fieldDestroyHandlers = {};
    var dataBuilderFactory = {};
    var calcFieldWrapper = function(value, oldValue) {
      basis.dev.warn("Calculate fields are readonly");
      return oldValue;
    };
    function getDataBuilder(defaults, fields) {
      var args = [ "has" ];
      var values = [ hasOwnProperty ];
      var obj = [];
      for (var key in defaults) if (hasOwnProperty.call(defaults, key)) {
        var name = "v" + obj.length;
        var fname = "f" + obj.length;
        var value = defaults[key];
        args.push(name, fname);
        values.push(value, fields[key]);
        obj.push('"' + key + '":' + 'has.call(data,"' + key + '")' + "?" + fname + '(data["' + key + '"],' + name + ")" + ":" + name + (typeof value == "function" ? "(data)" : ""));
      }
      var code = obj.sort().join(",");
      var fn = dataBuilderFactory[code];
      if (!fn) fn = dataBuilderFactory[code] = new Function(args, "return function(data){" + "return {" + code + "};" + "};");
      return fn.apply(null, values);
    }
    function arrayField(newArray, oldArray) {
      if (!Array.isArray(newArray)) return null;
      if (!Array.isArray(oldArray) || newArray.length != oldArray.length) return newArray || null;
      for (var i = 0; i < newArray.length; i++) if (newArray[i] !== oldArray[i]) return newArray;
      return oldArray;
    }
    var reIsoStringSplit = /\D/;
    var reIsoTimezoneDesignator = /(.{10,})([\-\+]\d{1,2}):?(\d{1,2})?$/;
    var fromISOString = function() {
      function fastDateParse(y, m, d, h, i, s, ms) {
        var date = new Date(y, m - 1, d, h || 0, 0, s || 0, ms ? ms.substr(0, 3) : 0);
        date.setMinutes((i || 0) - tz - date.getTimezoneOffset());
        return date;
      }
      var tz;
      return function(isoDateString) {
        tz = 0;
        return fastDateParse.apply(null, String(isoDateString || "").replace(reIsoTimezoneDesignator, function(m, pre, h, i) {
          tz = i ? h * 60 + i * 1 : h * 1;
          return pre;
        }).split(reIsoStringSplit));
      };
    }();
    function dateField(value, oldValue) {
      if (typeof value == "string" && value) return fromISOString(value);
      if (typeof value == "number" && isNaN(value) == false) return new Date(value);
      if (value == null) return null;
      if (value && value.constructor === Date) return value;
      basis.dev.warn("basis.entity: Bad value for Date field, value ignored");
      return oldValue;
    }
    function addField(entityType, name, config) {
      entityType.aliases[name] = name;
      if (typeof config == "string" || Array.isArray(config) || typeof config == "function" && config.calc !== config) {
        config = {
          type: config
        };
      } else {
        config = config ? basis.object.slice(config) : {};
      }
      if ("type" in config) {
        if (typeof config.type == "string") config.type = getTypeByName(config.type, entityType.fields, name);
        if (Array.isArray(config.type)) {
          var values = config.type.slice();
          if (!values.length) basis.dev.warn("Empty array set as type definition for " + entityType.name + "#field." + name + ", is it a bug?");
          if (values.length == 1) {
            config.type = basis.fn.$const(values[0]);
            config.defValue = values[0];
          } else {
            config.type = function(value, oldValue) {
              var exists = values.indexOf(value) != -1;
              if (!exists) basis.dev.warn("Set value that not in list for " + entityType.name + "#field." + name + " (new value ignored).\nVariants:", values, "\nIgnored value:", value);
              return exists ? value : oldValue;
            };
            config.defValue = values.indexOf(config.defValue) != -1 ? config.defValue : values[0];
          }
        }
        if (config.type === Array) config.type = arrayField;
        if (config.type === Date) config.type = dateField;
        if (typeof config.type != "function") {
          basis.dev.warn("EntityType " + entityType.name + ": Field wrapper for `" + name + "` field is not a function. Field wrapper has been ignored. Wrapper: ", config.type);
          config.type = null;
        }
      }
      var wrapper = config.type || $self;
      if (config.id || config.index || [ NumericId, NumberId, IntId, StringId ].indexOf(wrapper) != -1) entityType.idFields[name] = config;
      if (config.calc) {
        addCalcField(entityType, name, config.calc);
        entityType.fields[name] = calcFieldWrapper;
      } else entityType.fields[name] = wrapper;
      entityType.defaults[name] = "defValue" in config ? config.defValue : wrapper();
      if (!fieldDestroyHandlers[name]) fieldDestroyHandlers[name] = {
        destroy: function() {
          this.set(name, null);
        }
      };
    }
    function addFieldAlias(entityType, alias, name) {
      if (name in entityType.fields == false) {
        basis.dev.warn("Can't add alias `" + alias + "` for non-exists field `" + name + "`");
        return;
      }
      if (alias in entityType.aliases) {
        basis.dev.warn("Alias `" + alias + "` already exists");
        return;
      }
      entityType.aliases[alias] = name;
    }
    function addCalcField(entityType, name, wrapper) {
      if (!entityType.calcs) entityType.calcs = [];
      var calcs = entityType.calcs;
      var deps = entityType.deps;
      var calcArgs = wrapper.args || [];
      var calcConfig = {
        args: calcArgs,
        wrapper: wrapper
      };
      var before = entityType.calcs.length;
      var after = 0;
      if (calcArgs) for (var i = 0, calc; calc = calcs[i]; i++) if (calcArgs.indexOf(calc.key) != -1) after = i + 1;
      if (name) {
        calcConfig.key = name;
        for (var i = 0, calc; calc = calcs[i]; i++) if (calc.args.indexOf(name) != -1) {
          before = i;
          break;
        }
        if (after > before) {
          basis.dev.warn("Can't add calculate field `" + name + "`, because recursion");
          return;
        }
        deps[name] = calcArgs.reduce(function(res, ref) {
          var items = deps[ref] || [ ref ];
          for (var i = 0; i < items.length; i++) basis.array.add(res, items[i]);
          return res;
        }, []);
        for (var ref in deps) {
          var idx = deps[ref].indexOf(name);
          if (idx != -1) Array.prototype.splice.apply(deps[ref], [ idx, 1 ].concat(deps[name]));
        }
      } else {
        before = after;
      }
      calcs.splice(Math.min(before, after), 0, calcConfig);
    }
    function getFieldGetter(name) {
      return function(real) {
        if (real && this.modified && name in this.modified) return this.modified[name];
        return this.data[name];
      };
    }
    function getFieldSetter(name) {
      return function(value, rollback) {
        return this.set(name, value, rollback);
      };
    }
    var EntityTypeConstructor = Class(null, {
      className: namespace + ".EntityType",
      wrapper: null,
      all: null,
      fields: null,
      idField: null,
      idFields: null,
      defaults: null,
      aliases: null,
      slots: null,
      singleton: false,
      index: null,
      indexes: null,
      entityClass: null,
      init: function(config, wrapper) {
        this.name = config.name;
        if (!this.name || namedTypes[this.name]) {
          if (namedTypes[this.name]) basis.dev.warn(namespace + ": Duplicate type name `" + this.name + "`, name ignored");
          this.name = getUntitledName("UntitledEntityType");
        }
        this.fields = {};
        this.deps = {};
        this.idFields = {};
        this.defaults = {};
        this.aliases = {};
        this.slots = {};
        var index = config.index;
        if (index) {
          if (index instanceof Index) this.index = index; else basis.dev.warn("index must be instanceof basis.entity.Index");
        }
        this.wrapper = wrapper;
        if ("all" in config == false || config.all || config.singleton) this.all = new ReadOnlyEntitySet(basis.object.complete({
          wrapper: wrapper
        }, config.all));
        this.singleton = !!config.singleton;
        if (this.singleton) {
          var singletonInstance;
          this.get = function() {
            return singletonInstance;
          };
          this.all.addHandler({
            itemsChanged: function(sender, delta) {
              singletonInstance = delta.inserted ? delta.inserted[0] : null;
            }
          }, this);
        }
        for (var key in config.fields) addField(this, key, config.fields[key]);
        for (var key in config.aliases) addFieldAlias(this, key, config.aliases[key]);
        if (config.constrains) config.constrains.forEach(function(item) {
          addCalcField(this, null, item);
        }, this);
        var idFields = keys(this.idFields);
        var indexes = {};
        if (idFields.length) {
          for (var field in this.idFields) {
            var fieldCfg = this.idFields[field];
            var index = fieldCfg.index;
            var indexDescriptor;
            if (!index || index instanceof Index == false) {
              if (typeof index == "string") {
                if (index in namedIndexes == false) namedIndexes[index] = new Index;
                index = namedIndexes[index];
              } else {
                if (!this.index) this.index = new Index;
                index = this.index;
              }
            }
            indexDescriptor = indexes[index.basisObjectId];
            if (!indexDescriptor) indexDescriptor = indexes[index.basisObjectId] = {
              index: index,
              fields: []
            };
            indexDescriptor.fields.push(field);
            this.idFields[field] = indexDescriptor;
          }
          if (this.index && this.index.basisObjectId in indexes == false) {
            basis.dev.warn("basis.entity: entity index is not used for any field, index ignored");
            this.index = null;
          }
          for (var id in indexes) {
            var indexDescriptor = indexes[id];
            indexDescriptor.property = "__id__" + id;
            indexDescriptor.compositeKey = ConcatStringField.apply(null, indexDescriptor.fields);
            if (indexDescriptor.fields.length == 1) indexDescriptor.idField = indexDescriptor.fields[0];
          }
          var indexesKeys = keys(indexes);
          var primaryIndex = indexes[this.index ? this.index.basisObjectId : indexesKeys[0]];
          this.index = primaryIndex.index;
          this.idField = primaryIndex.idField;
          this.compositeKey = primaryIndex.compositeKey;
          this.idProperty = primaryIndex.property;
          this.indexes = indexes;
        } else {
          if (this.index) {
            basis.dev.warn("basis.entity: entity has no any id field, index ignored");
            this.index = null;
          }
        }
        var initDelta = {};
        for (var key in this.defaults) initDelta[key] = undefined;
        this.entityClass = createEntityClass(this, this.all, this.fields, this.slots);
        this.entityClass.extend({
          entityType: this,
          type: wrapper,
          typeName: this.name,
          state: config.state || this.entityClass.prototype.state,
          generateData: getDataBuilder(this.defaults, this.fields),
          initDelta: initDelta
        });
        for (var name in this.fields) {
          this.entityClass.prototype["get_" + name] = getFieldGetter(name);
          if (this.fields[name] !== calcFieldWrapper) this.entityClass.prototype["set_" + name] = getFieldSetter(name);
        }
        entityTypes.push(this);
      },
      reader: function(data) {
        var result = {};
        if (isKeyType[typeof data]) return this.idField ? data : null;
        if (!data || data == null) return null;
        for (var key in data) {
          var fieldKey = this.aliases[key];
          if (fieldKey) {
            var reader = this.fields[fieldKey].reader;
            result[fieldKey] = reader ? reader(data[key]) : data[key];
          }
        }
        return result;
      },
      get: function(entityOrData) {
        var id = this.getId(entityOrData);
        if (this.index && id != null) return this.index.get(id, this);
      },
      getId: function(entityOrData) {
        if (this.compositeKey && entityOrData != null) {
          if (isKeyType[typeof entityOrData]) return entityOrData;
          if (entityOrData && entityOrData.entityType === this) return entityOrData[this.idProperty];
          if (entityOrData instanceof DataObject) entityOrData = entityOrData.data;
          if (this.compositeKey) return this.compositeKey(entityOrData, entityOrData);
        }
      },
      getSlot: function(data) {
        var id = this.getId(data);
        if (id != null) {
          var slot = hasOwnProperty.call(this.slots, id) && this.slots[id];
          if (!slot) {
            if (isKeyType[typeof data]) {
              var tmp = {};
              if (this.idField) tmp[this.idField] = data;
              data = tmp;
            }
            slot = this.slots[id] = new Slot({
              delegate: this.get(id) || null,
              data: data
            });
          }
          return slot;
        }
      }
    });
    function entityWarn(entity, message) {
      basis.dev.warn("[basis.entity " + entity.entityType.name + "#" + entity.basisObjectId + "] " + message, entity);
    }
    var BaseEntity = Class(DataObject, {
      className: namespace + ".BaseEntity",
      target: true,
      setDelegate: function() {},
      extendConstructor_: false,
      fieldHandlers_: null,
      modified: null,
      emit_rollbackUpdate: createEvent("rollbackUpdate")
    });
    var createEntityClass = function(entityType, all, fields, slots) {
      function calc(entity, delta, rollbackDelta) {
        var calcs = entityType.calcs;
        var data = entity.data;
        var updated = false;
        try {
          if (calcs) {
            for (var i = 0, calc; calc = calcs[i]; i++) {
              var key = calc.key;
              var oldValue = data[key];
              var newValue = calc.wrapper(delta, data, oldValue);
              if (key && newValue !== oldValue) {
                delta[key] = oldValue;
                data[key] = newValue;
                updated = true;
              }
            }
          }
          for (var id in entityType.indexes) {
            var indexDescriptor = entityType.indexes[id];
            var curId = entity[indexDescriptor.property];
            var newId = curId;
            if (indexDescriptor.compositeKey) newId = indexDescriptor.compositeKey(delta, data, curId);
            if (newId !== curId) {
              updateIndex(indexDescriptor.index, entity, curId, newId);
              entity[indexDescriptor.property] = newId;
            }
          }
          return updated;
        } catch (e) {
          entityWarn(entity, "(rollback changes) Exception on field calcs: " + (e && e.message || e));
          for (var key in delta) entity.data[key] = delta[key];
          if (rollbackDelta && !entity.modified) entity.modified = rollbackDelta;
        }
      }
      function updateIndex(index, entity, curValue, newValue) {
        if (newValue != null) {
          index.add(newValue, entity);
          if (hasOwnProperty.call(slots, newValue)) slots[newValue].setDelegate(entity);
        }
        if (curValue != null) {
          index.remove(curValue, entity);
          if (hasOwnProperty.call(slots, curValue)) slots[curValue].setDelegate();
        }
      }
      return Class(BaseEntity, {
        className: entityType.name,
        init: function(data) {
          this.delegate = null;
          this.data = this.generateData(data);
          BaseEntity.prototype.init.call(this);
          for (var key in data) if (key in fields == false) entityWarn(this, 'Field "' + key + '" is not defined, value has been ignored.');
          var value;
          for (var key in this.data) {
            value = this.data[key];
            if (value && value !== this && value instanceof Emitter) {
              value.addHandler(fieldDestroyHandlers[key], this);
              if (!this.fieldHandlers_) this.fieldHandlers_ = {};
              this.fieldHandlers_[key] = true;
            }
          }
          calc(this, this.initDelta);
          if (all) all.emit_itemsChanged({
            inserted: [ this ]
          });
        },
        toString: function() {
          return "[object " + this.constructor.className + "(" + this.entityType.name + ")]";
        },
        getId: function() {
          return this[entityType.idProperty];
        },
        get: function(key, real) {
          if (real && this.modified && key in this.modified) return this.modified[key];
          return this.data[key];
        },
        set: function(key, value, rollback, silent_) {
          var valueWrapper = fields[key];
          if (!valueWrapper) {
            entityWarn(this, 'Field "' + key + '" is not defined, value has been ignored.');
            return false;
          }
          var result;
          var rollbackData = this.modified;
          if (valueWrapper === arrayField && rollbackData && key in rollbackData) value = arrayField(value, rollbackData[key]);
          var newValue = valueWrapper(value, this.data[key]);
          var curValue = this.data[key];
          var valueChanged = newValue !== curValue && (!newValue || !curValue || newValue.constructor !== Date || curValue.constructor !== Date || +newValue !== +curValue);
          if (valueChanged) updateField : {
            result = {};
            if (!entityType.idFields[key]) {
              if (rollback) {
                if (!rollbackData) this.modified = rollbackData = {};
                if (key in rollbackData === false) {
                  result.rollback = {
                    key: key,
                    value: undefined
                  };
                  rollbackData[key] = curValue;
                } else {
                  if (rollbackData[key] === newValue) {
                    result.rollback = {
                      key: key,
                      value: newValue
                    };
                    delete rollbackData[key];
                    if (!keys(rollbackData).length) this.modified = null;
                  }
                }
              } else {
                if (rollbackData && key in rollbackData) {
                  if (rollbackData[key] !== newValue) {
                    result.rollback = {
                      key: key,
                      value: rollbackData[key]
                    };
                    rollbackData[key] = newValue;
                    break updateField;
                  } else return false;
                }
              }
            }
            this.data[key] = newValue;
            if (this.fieldHandlers_ && this.fieldHandlers_[key]) {
              curValue.removeHandler(fieldDestroyHandlers[key], this);
              this.fieldHandlers_[key] = false;
            }
            if (newValue && newValue !== this && newValue instanceof Emitter) {
              newValue.addHandler(fieldDestroyHandlers[key], this);
              if (!this.fieldHandlers_) this.fieldHandlers_ = {};
              this.fieldHandlers_[key] = true;
            }
            result.key = key;
            result.value = curValue;
            result.delta = {};
            result.delta[key] = curValue;
          } else {
            if (!rollback && rollbackData && key in rollbackData) {
              result = {
                rollback: {
                  key: key,
                  value: rollbackData[key]
                }
              };
              delete rollbackData[key];
              if (!keys(rollbackData).length) this.modified = null;
            }
          }
          if (!silent_ && result) {
            var update = result.key;
            var delta = result.delta || {};
            var rollbackDelta;
            if (result.rollback) {
              rollbackDelta = {};
              rollbackDelta[result.rollback.key] = result.rollback.value;
            }
            if (calc(this, delta, rollbackDelta)) update = true;
            if (update) {
              this.emit_update(delta);
              result.delta = delta;
            }
            if (rollbackDelta) this.emit_rollbackUpdate(rollbackDelta);
          }
          return result || false;
        },
        update: function(data, rollback) {
          var update = false;
          var delta = {};
          if (data) {
            var rollbackDelta;
            var setResult;
            for (var key in data) {
              if (setResult = this.set(key, data[key], rollback, true)) {
                if (setResult.key) {
                  update = true;
                  delta[setResult.key] = setResult.value;
                }
                if (setResult.rollback) {
                  if (!rollbackDelta) rollbackDelta = {};
                  rollbackDelta[setResult.rollback.key] = setResult.rollback.value;
                }
              }
            }
            if (calc(this, delta, rollbackDelta)) update = true;
            if (update) this.emit_update(delta);
            if (rollbackDelta) this.emit_rollbackUpdate(rollbackDelta);
          }
          return update ? delta : false;
        },
        generateData: function() {
          return {};
        },
        reset: function() {
          this.update(this.generateData({}));
        },
        clear: function() {
          var data = {};
          for (var key in this.data) data[key] = undefined;
          return this.update(data);
        },
        commit: function(data) {
          var rollbackData = this.modified;
          this.modified = null;
          if (data) this.update(data);
          if (rollbackData) this.emit_rollbackUpdate(rollbackData);
        },
        rollback: function(keys) {
          var rollbackData = this.modified;
          if (rollbackData && keys) {
            if (!Array.isArray(keys)) keys = [ keys ];
            rollbackData = basis.object.slice(rollbackData, keys.reduce(function(res, item) {
              return res.concat(entityType.deps[item] || item);
            }, []));
          }
          this.update(rollbackData, true);
        },
        destroy: function() {
          if (this.fieldHandlers_) {
            for (var key in this.fieldHandlers_) if (this.fieldHandlers_[key]) this.data[key].removeHandler(fieldDestroyHandlers[key], this);
            this.fieldHandlers_ = null;
          }
          for (var key in entityType.indexes) {
            var indexDescriptor = entityType.indexes[key];
            var id = this[indexDescriptor.property];
            if (id != null) updateIndex(indexDescriptor.index, this, id, null);
          }
          if (all && all.has(this)) all.emit_itemsChanged({
            deleted: [ this ]
          });
          DataObject.prototype.destroy.call(this);
          this.data = NULL_INFO;
          this.modified = null;
        }
      });
    };
    function isEntity(value) {
      return value && value instanceof BaseEntity;
    }
    function createType(configOrName, fields) {
      if (this instanceof createType) basis.dev.warn("`new` operator was used with basis.entity.createType, it's a mistake");
      var config = configOrName || {};
      if (typeof configOrName == "string") {
        config = {
          name: config,
          fields: fields || {}
        };
      } else {
        if (fields) config = basis.object.merge(config, {
          fields: fields
        });
      }
      return new EntityTypeWrapper(config);
    }
    function createSetType(nameOrWrapper, wrapper) {
      if (this instanceof createSetType) basis.dev.warn("`new` operator was used with basis.entity.createSetType, it's a mistake");
      return arguments.length > 1 ? new EntitySetWrapper(wrapper, nameOrWrapper) : new EntitySetWrapper(nameOrWrapper);
    }
    module.exports = {
      isEntity: isEntity,
      createType: createType,
      createSetType: createSetType,
      validate: validateScheme,
      getTypeByName: function(typeName) {
        return namedTypes[typeName];
      },
      getIndexByName: function(name) {
        return namedIndexes[name];
      },
      get: function(typeName, value) {
        var Type = namedTypes[typeName];
        if (Type) return Type.get(value);
      },
      resolve: function(typeName, value) {
        var Type = namedTypes[typeName];
        if (Type) return Type(value);
      },
      getByIndex: function(indexName, id) {
        if (indexName in namedIndexes) return namedIndexes[indexName].get(id); else basis.dev.warn("basis.entity: index with name `" + indexName + "` doesn't exists");
      },
      NumericId: NumericId,
      NumberId: NumberId,
      IntId: IntId,
      StringId: StringId,
      Index: Index,
      CalculateField: CalculateField,
      ConcatStringField: ConcatStringField,
      calc: CalculateField,
      EntityType: EntityTypeWrapper,
      Entity: createEntityClass,
      BaseEntity: BaseEntity,
      EntitySetType: EntitySetWrapper,
      EntitySet: EntitySet,
      ReadOnlyEntitySet: ReadOnlyEntitySet,
      Collection: EntityCollection,
      Grouping: EntityGrouping
    };
  },
  "f.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./4.js");
    var namespace = this.path;
    var Class = basis.Class;
    var oneFunctionProperty = Class.oneFunctionProperty;
    var extend = basis.object.extend;
    var values = basis.object.values;
    var getter = basis.getter;
    var $self = basis.fn.$self;
    var $true = basis.fn.$true;
    var $false = basis.fn.$false;
    var $undef = basis.fn.$undef;
    var arrayFrom = basis.array.from;
    var createEvent = basis.event.create;
    var SUBSCRIPTION = basis.data.SUBSCRIPTION;
    var DataObject = basis.data.Object;
    var KeyObjectMap = basis.data.KeyObjectMap;
    var ReadOnlyDataset = basis.data.ReadOnlyDataset;
    var Dataset = basis.data.Dataset;
    var DatasetWrapper = basis.data.DatasetWrapper;
    var setAccumulateState = Dataset.setAccumulateState;
    SUBSCRIPTION.add("SOURCE", {
      sourceChanged: function(object, oldSource) {
        if (oldSource) SUBSCRIPTION.unlink("source", object, oldSource);
        if (object.source) SUBSCRIPTION.link("source", object, object.source);
      },
      sourcesChanged: function(object, delta) {
        var array;
        if (array = delta.inserted) for (var i = 0, item; item = array[i]; i++) SUBSCRIPTION.link("source", object, array[i]);
        if (array = delta.deleted) for (var i = 0, item; item = array[i]; i++) SUBSCRIPTION.unlink("source", object, array[i]);
      }
    }, function(action, object) {
      var sources = object.sources || (object.source ? [ object.source ] : []);
      for (var i = 0, source; source = sources[i++]; ) action("source", object, source);
    });
    SUBSCRIPTION.addProperty("minuend");
    SUBSCRIPTION.addProperty("subtrahend");
    function getDelta(inserted, deleted) {
      var delta = {};
      var result;
      if (inserted && inserted.length) result = delta.inserted = inserted;
      if (deleted && deleted.length) result = delta.deleted = deleted;
      if (result) return delta;
    }
    function createRuleEvents(fn, events) {
      return function createRuleEventsExtend(events) {
        if (!events) return null;
        if (events.__extend__) return events;
        if (typeof events != "string" && !Array.isArray(events)) events = null;
        return extend(basis.event.createHandler(events, fn), {
          __extend__: createRuleEventsExtend
        });
      }(events);
    }
    function createKeyMap(config, keyGetter, ItemClass, SubsetClass) {
      return new KeyObjectMap(extend({
        keyGetter: keyGetter,
        itemClass: ItemClass,
        create: function(key, object) {
          var datasetWrapper = KeyObjectMap.prototype.create.call(this, key, object);
          datasetWrapper.ruleValue = key;
          datasetWrapper.setDataset(new SubsetClass({
            ruleValue: key
          }));
          return datasetWrapper;
        }
      }, config));
    }
    var MERGE_DATASET_HANDLER = {
      itemsChanged: function(source, delta) {
        var memberMap = this.members_;
        var updated = {};
        var object;
        var objectId;
        if (delta.inserted) {
          for (var i = 0; object = delta.inserted[i]; i++) {
            objectId = object.basisObjectId;
            if (memberMap[objectId]) {
              memberMap[objectId].count++;
            } else {
              memberMap[objectId] = {
                count: 1,
                object: object
              };
            }
            updated[objectId] = memberMap[objectId];
          }
        }
        if (delta.deleted) {
          for (var i = 0; object = delta.deleted[i]; i++) {
            objectId = object.basisObjectId;
            updated[objectId] = memberMap[objectId];
            memberMap[objectId].count--;
          }
        }
        this.applyRule(updated);
      }
    };
    var Merge = Class(ReadOnlyDataset, {
      className: namespace + ".Merge",
      subscribeTo: SUBSCRIPTION.SOURCE,
      emit_sourcesChanged: createEvent("sourcesChanged", "delta"),
      sources: null,
      sourceValues_: null,
      sourcesMap_: null,
      sourceDelta_: null,
      rule: function(count, sourceCount) {
        return count > 0;
      },
      emit_ruleChanged: createEvent("ruleChanged", "oldRule"),
      listen: {
        source: MERGE_DATASET_HANDLER,
        sourceValue: {
          destroy: function(sender) {
            this.removeSource(sender);
          }
        }
      },
      init: function() {
        ReadOnlyDataset.prototype.init.call(this);
        var sources = this.sources;
        this.sources = [];
        this.sourcesMap_ = {};
        this.sourceValues_ = [];
        if (sources) this.setSources(sources);
      },
      setRule: function(rule) {
        rule = getter(rule || Merge.UNION);
        if (this.rule !== rule) {
          var oldRule = this.rule;
          this.rule = rule;
          this.emit_ruleChanged(oldRule);
          return this.applyRule();
        }
      },
      applyRule: function(scope) {
        var memberMap = this.members_;
        var rule = this.rule;
        var sourceCount = this.sources.length;
        var inserted = [];
        var deleted = [];
        var memberCounter;
        var isMember;
        var delta;
        if (!scope) scope = memberMap;
        for (var objectId in scope) {
          memberCounter = memberMap[objectId];
          isMember = sourceCount && memberCounter.count && rule(memberCounter.count, sourceCount);
          if (isMember != objectId in this.items_) {
            if (isMember) inserted.push(memberCounter.object); else deleted.push(memberCounter.object);
          }
          if (memberCounter.count == 0) delete memberMap[objectId];
        }
        if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
        return delta;
      },
      addDataset_: function(dataset) {
        this.sources.push(dataset);
        if (this.listen.source) dataset.addHandler(this.listen.source, this);
        var memberMap = this.members_;
        for (var objectId in dataset.items_) {
          if (memberMap[objectId]) {
            memberMap[objectId].count++;
          } else {
            memberMap[objectId] = {
              count: 1,
              object: dataset.items_[objectId]
            };
          }
        }
        return true;
      },
      removeDataset_: function(dataset) {
        basis.array.remove(this.sources, dataset);
        if (this.listen.source) dataset.removeHandler(this.listen.source, this);
        var memberMap = this.members_;
        for (var objectId in dataset.items_) memberMap[objectId].count--;
      },
      updateDataset_: function(source) {
        var merge = this.owner;
        var sourcesMap_ = merge.sourcesMap_;
        var dataset = basis.data.resolveDataset(this, merge.updateDataset_, source, "adapter");
        var inserted;
        var deleted;
        var delta;
        if (this.dataset === dataset) return;
        if (dataset) {
          var count = (sourcesMap_[dataset.basisObjectId] || 0) + 1;
          sourcesMap_[dataset.basisObjectId] = count;
          if (count == 1) {
            merge.addDataset_(dataset);
            inserted = [ dataset ];
          }
        }
        if (this.dataset) {
          var count = (sourcesMap_[this.dataset.basisObjectId] || 0) - 1;
          sourcesMap_[this.dataset.basisObjectId] = count;
          if (count == 0) {
            merge.removeDataset_(this.dataset);
            deleted = [ this.dataset ];
          }
        }
        this.dataset = dataset;
        merge.applyRule();
        if (delta = getDelta(inserted, deleted)) {
          var setSourcesTransaction = merge.sourceDelta_;
          if (setSourcesTransaction) {
            if (delta.inserted) delta.inserted.forEach(function(source) {
              if (!basis.array.remove(this.deleted, source)) basis.array.add(this.inserted, source);
            }, setSourcesTransaction);
            if (delta.deleted) delta.deleted.forEach(function(source) {
              if (!basis.array.remove(this.inserted, source)) basis.array.add(this.deleted, source);
            }, setSourcesTransaction);
          } else {
            merge.emit_sourcesChanged(delta);
          }
        }
        return delta;
      },
      getSourceValues: function() {
        return this.sourceValues_.map(function(item) {
          return item.source;
        });
      },
      addSource: function(source) {
        if (!source || typeof source != "object" && typeof source != "function") {
          basis.dev.warn(this.constructor.className + ".addSource: value should be a dataset instance or to be able to resolve in dataset");
          return;
        }
        if (this.hasSource(source)) {
          basis.dev.warn(this.constructor.className + ".addSource: value is already in source list");
          return;
        }
        var sourceInfo = {
          owner: this,
          source: source,
          adapter: null,
          dataset: null
        };
        this.sourceValues_.push(sourceInfo);
        this.updateDataset_.call(sourceInfo, source);
        if (this.listen.sourceValue && source instanceof basis.event.Emitter) source.addHandler(this.listen.sourceValue, this);
      },
      removeSource: function(source) {
        for (var i = 0, sourceInfo; sourceInfo = this.sourceValues_[i]; i++) if (sourceInfo.source === source) {
          if (this.listen.sourceValue && source instanceof basis.event.Emitter) source.removeHandler(this.listen.sourceValue, this);
          this.updateDataset_.call(sourceInfo, null);
          this.sourceValues_.splice(i, 1);
          return;
        }
        basis.dev.warn(this.constructor.className + ".removeSource: source value isn't found in source list");
      },
      hasSource: function(source) {
        for (var i = 0, sourceInfo; sourceInfo = this.sourceValues_[i]; i++) if (sourceInfo.source === source) return true;
        return false;
      },
      setSources: function(sources) {
        var exists = this.sourceValues_.map(function(sourceInfo) {
          return sourceInfo.source;
        });
        var inserted = [];
        var deleted = [];
        var delta;
        if (!sources) sources = [];
        this.sourceDelta_ = {
          inserted: inserted,
          deleted: deleted
        };
        for (var i = 0; i < sources.length; i++) {
          var source = sources[i];
          if (!basis.array.remove(exists, source)) this.addSource(source);
        }
        exists.forEach(this.removeSource, this);
        this.sourceDelta_ = null;
        if (delta = getDelta(inserted, deleted)) this.emit_sourcesChanged(delta);
        return delta;
      },
      destroy: function() {
        this.setSources();
        ReadOnlyDataset.prototype.destroy.call(this);
        this.sourceValues_ = null;
        this.sourcesMap_ = null;
        this.sourceDelta_ = null;
        this.sources = null;
      }
    });
    Merge.UNION = Merge.prototype.rule;
    Merge.INTERSECTION = function(count, sourceCount) {
      return count == sourceCount;
    };
    Merge.DIFFERENCE = function(count, sourceCount) {
      return count == 1;
    };
    Merge.MORE_THAN_ONE_INCLUDE = function(count, sourceCount) {
      return sourceCount == 1 || count > 1;
    };
    Merge.AT_LEAST_ONE_EXCLUDE = function(count, sourceCount) {
      return sourceCount == 1 || count < sourceCount;
    };
    var datasetAbsentFilter = function(item) {
      return !this.has(item);
    };
    var SUBTRACTDATASET_MINUEND_HANDLER = {
      itemsChanged: function(dataset, delta) {
        if (!this.subtrahend) return;
        var newDelta = getDelta(delta.inserted && delta.inserted.filter(datasetAbsentFilter, this.subtrahend), delta.deleted && delta.deleted.filter(this.has, this));
        if (newDelta) this.emit_itemsChanged(newDelta);
      },
      destroy: function() {
        if (!this.minuendAdapter_) this.setMinuend(null);
      }
    };
    var SUBTRACTDATASET_SUBTRAHEND_HANDLER = {
      itemsChanged: function(dataset, delta) {
        if (!this.minuend) return;
        var newDelta = getDelta(delta.deleted && delta.deleted.filter(this.minuend.has, this.minuend), delta.inserted && delta.inserted.filter(this.has, this));
        if (newDelta) this.emit_itemsChanged(newDelta);
      },
      destroy: function() {
        if (!this.subtrahendAdapter_) this.setSubtrahend(null);
      }
    };
    var Subtract = Class(ReadOnlyDataset, {
      className: namespace + ".Subtract",
      subscribeTo: SUBSCRIPTION.MINUEND + SUBSCRIPTION.SUBTRAHEND,
      minuend: null,
      minuendAdapter_: null,
      emit_minuendChanged: createEvent("minuendChanged", "oldMinuend"),
      subtrahend: null,
      subtrahendAdapter_: null,
      emit_subtrahendChanged: createEvent("subtrahendChanged", "oldSubtrahend"),
      listen: {
        minuend: SUBTRACTDATASET_MINUEND_HANDLER,
        subtrahend: SUBTRACTDATASET_SUBTRAHEND_HANDLER
      },
      init: function() {
        ReadOnlyDataset.prototype.init.call(this);
        var minuend = this.minuend;
        var subtrahend = this.subtrahend;
        this.minuend = null;
        this.subtrahend = null;
        if (minuend || subtrahend) this.setOperands(minuend, subtrahend);
      },
      setOperands: function(minuend, subtrahend) {
        var delta;
        var operandsChanged = false;
        minuend = basis.data.resolveDataset(this, this.setMinuend, minuend, "minuendAdapter_");
        subtrahend = basis.data.resolveDataset(this, this.setSubtrahend, subtrahend, "subtrahendAdapter_");
        var oldMinuend = this.minuend;
        var oldSubtrahend = this.subtrahend;
        if (oldMinuend !== minuend) {
          operandsChanged = true;
          this.minuend = minuend;
          var listenHandler = this.listen.minuend;
          if (listenHandler) {
            if (oldMinuend) oldMinuend.removeHandler(listenHandler, this);
            if (minuend) minuend.addHandler(listenHandler, this);
          }
          this.emit_minuendChanged(oldMinuend);
        }
        if (oldSubtrahend !== subtrahend) {
          operandsChanged = true;
          this.subtrahend = subtrahend;
          var listenHandler = this.listen.subtrahend;
          if (listenHandler) {
            if (oldSubtrahend) oldSubtrahend.removeHandler(listenHandler, this);
            if (subtrahend) subtrahend.addHandler(listenHandler, this);
          }
          this.emit_subtrahendChanged(oldSubtrahend);
        }
        if (!operandsChanged) return false;
        if (!minuend || !subtrahend) {
          if (this.itemCount) this.emit_itemsChanged(delta = {
            deleted: this.getItems()
          });
        } else {
          var deleted = [];
          var inserted = [];
          for (var key in this.items_) if (!minuend.items_[key] || subtrahend.items_[key]) deleted.push(this.items_[key]);
          for (var key in minuend.items_) if (!this.items_[key] && !subtrahend.items_[key]) inserted.push(minuend.items_[key]);
          if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
        }
        return delta;
      },
      setMinuend: function(minuend) {
        return this.setOperands(minuend, this.subtrahendAdapter_ ? this.subtrahendAdapter_.source : this.subtrahend);
      },
      setSubtrahend: function(subtrahend) {
        return this.setOperands(this.minuendAdapter_ ? this.minuendAdapter_.source : this.minuend, subtrahend);
      },
      destroy: function() {
        this.setOperands();
        ReadOnlyDataset.prototype.destroy.call(this);
      }
    });
    var SourceDataset = Class(ReadOnlyDataset, {
      className: namespace + ".SourceDataset",
      subscribeTo: SUBSCRIPTION.SOURCE,
      source: null,
      emit_sourceChanged: createEvent("sourceChanged", "oldSource"),
      sourceAdapter_: null,
      sourceMap_: null,
      listen: {
        source: {
          destroy: function() {
            if (!this.sourceAdapter_) this.setSource();
          }
        }
      },
      init: function() {
        this.sourceMap_ = {};
        ReadOnlyDataset.prototype.init.call(this);
        var source = this.source;
        if (source) {
          this.source = null;
          this.setSource(source);
        }
      },
      setSource: function(source) {
        source = basis.data.resolveDataset(this, this.setSource, source, "sourceAdapter_");
        if (this.source !== source) {
          var oldSource = this.source;
          var listenHandler = this.listen.source;
          this.source = source;
          if (listenHandler) {
            var itemsChangedHandler = listenHandler.itemsChanged;
            setAccumulateState(true);
            if (oldSource) {
              oldSource.removeHandler(listenHandler, this);
              if (itemsChangedHandler) itemsChangedHandler.call(this, oldSource, {
                deleted: oldSource.getItems()
              });
            }
            if (source) {
              source.addHandler(listenHandler, this);
              if (itemsChangedHandler) itemsChangedHandler.call(this, source, {
                inserted: source.getItems()
              });
            }
            setAccumulateState(false);
          }
          this.emit_sourceChanged(oldSource);
        }
      },
      destroy: function() {
        this.setSource();
        ReadOnlyDataset.prototype.destroy.call(this);
        this.sourceMap_ = null;
      }
    });
    var MAPFILTER_SOURCEOBJECT_UPDATE = function(sourceObject) {
      var newMember = this.map ? this.map(sourceObject) : object;
      if (newMember instanceof DataObject == false || this.filter(newMember)) newMember = null;
      var sourceMap = this.sourceMap_[sourceObject.basisObjectId];
      var curMember = sourceMap.member;
      if (curMember !== newMember) {
        var memberMap = this.members_;
        var delta;
        var inserted;
        var deleted;
        sourceMap.member = newMember;
        if (curMember) {
          var curMemberId = curMember.basisObjectId;
          if (this.removeMemberRef) this.removeMemberRef(curMember, sourceObject);
          if (--memberMap[curMemberId] == 0) {
            delete memberMap[curMemberId];
            deleted = [ curMember ];
          }
        }
        if (newMember) {
          var newMemberId = newMember.basisObjectId;
          if (this.addMemberRef) this.addMemberRef(newMember, sourceObject);
          if (memberMap[newMemberId]) {
            memberMap[newMemberId]++;
          } else {
            memberMap[newMemberId] = 1;
            inserted = [ newMember ];
          }
        }
        if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
      }
    };
    var MAPFILTER_SOURCE_HANDLER = {
      itemsChanged: function(source, delta) {
        var sourceMap = this.sourceMap_;
        var memberMap = this.members_;
        var inserted = [];
        var deleted = [];
        var sourceObject;
        var sourceObjectId;
        var member;
        var updateHandler = this.ruleEvents;
        setAccumulateState(true);
        if (delta.inserted) {
          for (var i = 0; sourceObject = delta.inserted[i]; i++) {
            member = this.map ? this.map(sourceObject) : sourceObject;
            if (member instanceof DataObject == false || this.filter(member)) member = null;
            if (updateHandler) sourceObject.addHandler(updateHandler, this);
            sourceMap[sourceObject.basisObjectId] = {
              sourceObject: sourceObject,
              member: member
            };
            if (member) {
              var memberId = member.basisObjectId;
              if (memberMap[memberId]) {
                memberMap[memberId]++;
              } else {
                memberMap[memberId] = 1;
                inserted.push(member);
              }
              if (this.addMemberRef) this.addMemberRef(member, sourceObject);
            }
          }
        }
        if (delta.deleted) {
          for (var i = 0; sourceObject = delta.deleted[i]; i++) {
            sourceObjectId = sourceObject.basisObjectId;
            member = sourceMap[sourceObjectId].member;
            if (updateHandler) sourceObject.removeHandler(updateHandler, this);
            delete sourceMap[sourceObjectId];
            if (member) {
              var memberId = member.basisObjectId;
              if (--memberMap[memberId] == 0) {
                delete memberMap[memberId];
                deleted.push(member);
              }
              if (this.removeMemberRef) this.removeMemberRef(member, sourceObject);
            }
          }
        }
        setAccumulateState(false);
        if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
      }
    };
    var MapFilter = Class(SourceDataset, {
      className: namespace + ".MapFilter",
      map: $self,
      filter: $false,
      rule: getter($true),
      emit_ruleChanged: createEvent("ruleChanged", "oldRule"),
      ruleEvents: createRuleEvents(MAPFILTER_SOURCEOBJECT_UPDATE, "update"),
      addMemberRef: null,
      removeMemberRef: null,
      listen: {
        source: MAPFILTER_SOURCE_HANDLER
      },
      setMap: function(map) {
        if (typeof map != "function") map = $self;
        if (this.map !== map) {
          this.map = map;
          return this.applyRule();
        }
      },
      setFilter: function(filter) {
        if (typeof filter != "function") filter = $false;
        if (this.filter !== filter) {
          this.filter = filter;
          return this.applyRule();
        }
      },
      setRule: function(rule) {
        rule = getter(rule || $true);
        if (this.rule !== rule) {
          var oldRule = this.rule;
          this.rule = rule;
          this.emit_ruleChanged(oldRule);
          return this.applyRule();
        }
      },
      applyRule: function() {
        var sourceMap = this.sourceMap_;
        var memberMap = this.members_;
        var curMember;
        var newMember;
        var curMemberId;
        var newMemberId;
        var sourceObject;
        var sourceObjectInfo;
        var inserted = [];
        var deleted = [];
        var delta;
        for (var sourceObjectId in sourceMap) {
          sourceObjectInfo = sourceMap[sourceObjectId];
          sourceObject = sourceObjectInfo.sourceObject;
          curMember = sourceObjectInfo.member;
          newMember = this.map ? this.map(sourceObject) : sourceObject;
          if (newMember instanceof DataObject == false || this.filter(newMember)) newMember = null;
          if (curMember != newMember) {
            sourceObjectInfo.member = newMember;
            if (curMember) {
              curMemberId = curMember.basisObjectId;
              if (this.removeMemberRef) this.removeMemberRef(curMember, sourceObject);
              memberMap[curMemberId]--;
            }
            if (newMember) {
              newMemberId = newMember.basisObjectId;
              if (this.addMemberRef) this.addMemberRef(newMember, sourceObject);
              if (newMemberId in memberMap) {
                memberMap[newMemberId]++;
              } else {
                memberMap[newMemberId] = 1;
                inserted.push(newMember);
              }
            }
          }
        }
        for (curMemberId in this.items_) if (memberMap[curMemberId] == 0) {
          delete memberMap[curMemberId];
          deleted.push(this.items_[curMemberId]);
        }
        if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
        return delta;
      }
    });
    var Filter = Class(MapFilter, {
      className: namespace + ".Filter",
      filter: function(object) {
        return !this.rule(object);
      }
    });
    var Split = Class(MapFilter, {
      className: namespace + ".Split",
      subsetClass: ReadOnlyDataset,
      subsetWrapperClass: DatasetWrapper,
      keyMap: null,
      map: function(sourceObject) {
        return this.keyMap.resolve(sourceObject);
      },
      rule: getter($undef),
      setRule: function(rule) {
        rule = getter(rule || $undef);
        if (this.rule !== rule) {
          var oldRule = this.rule;
          this.rule = rule;
          this.keyMap.keyGetter = rule;
          this.emit_ruleChanged(oldRule);
          return this.applyRule();
        }
      },
      addMemberRef: function(wrapper, sourceObject) {
        wrapper.dataset.emit_itemsChanged({
          inserted: [ sourceObject ]
        });
      },
      removeMemberRef: function(wrapper, sourceObject) {
        wrapper.dataset.emit_itemsChanged({
          deleted: [ sourceObject ]
        });
      },
      init: function() {
        if (!this.keyMap || this.keyMap instanceof KeyObjectMap == false) this.keyMap = createKeyMap(this.keyMap, this.rule, this.subsetWrapperClass, this.subsetClass);
        MapFilter.prototype.init.call(this);
      },
      getSubset: function(data, autocreate) {
        return this.keyMap.get(data, autocreate);
      },
      destroy: function() {
        MapFilter.prototype.destroy.call(this);
        this.keyMap.destroy();
        this.keyMap = null;
      }
    });
    function binarySearchPos(array, map) {
      if (!array.length) return 0;
      var value = map.value;
      var id = map.object.basisObjectId;
      var cmpValue;
      var cmpId;
      var pos;
      var item;
      var l = 0;
      var r = array.length - 1;
      do {
        pos = l + r >> 1;
        item = array[pos];
        cmpValue = item.value;
        if (value < cmpValue) r = pos - 1; else if (value > cmpValue) l = pos + 1; else {
          cmpId = item.object.basisObjectId;
          if (id < cmpId) r = pos - 1; else if (id > cmpId) l = pos + 1; else return pos;
        }
      } while (l <= r);
      return pos + (cmpValue == value ? cmpId < id : cmpValue < value);
    }
    var SLICE_SOURCEOBJECT_UPDATE = function(sourceObject) {
      var sourceObjectInfo = this.sourceMap_[sourceObject.basisObjectId];
      var newValue = this.rule(sourceObject);
      var index = this.index_;
      if (newValue !== sourceObjectInfo.value) {
        var pos = binarySearchPos(index, sourceObjectInfo);
        var prev = index[pos - 1];
        var next = index[pos + 1];
        sourceObjectInfo.value = newValue;
        if (prev && (prev.value > newValue || prev.value == newValue && prev.object.basisObjectId > sourceObjectInfo.object.basisObjectId) || next && (next.value < newValue || next.value == newValue && next.object.basisObjectId < sourceObjectInfo.object.basisObjectId)) {
          index.splice(pos, 1);
          index.splice(binarySearchPos(index, sourceObjectInfo), 0, sourceObjectInfo);
          this.applyRule();
        }
      }
    };
    function sliceIndexSort(a, b) {
      return +(a.value > b.value) || -(a.value < b.value) || a.object.basisObjectId - b.object.basisObjectId;
    }
    var SLICE_SOURCE_HANDLER = {
      itemsChanged: function(source, delta) {
        var sourceMap = this.sourceMap_;
        var index = this.index_;
        var updateHandler = this.ruleEvents;
        var dropIndex = false;
        var buildIndex = false;
        var sourceObjectInfo;
        var inserted = delta.inserted;
        var deleted = delta.deleted;
        if (deleted) {
          if (deleted.length > index.length - deleted.length) {
            dropIndex = true;
            buildIndex = deleted.length != index.length;
            index.length = 0;
          }
          for (var i = 0, sourceObject; sourceObject = deleted[i]; i++) {
            if (!dropIndex) {
              sourceObjectInfo = sourceMap[sourceObject.basisObjectId];
              index.splice(binarySearchPos(index, sourceObjectInfo), 1);
            }
            delete sourceMap[sourceObject.basisObjectId];
            if (updateHandler) sourceObject.removeHandler(updateHandler, this);
          }
          if (buildIndex) for (var key in sourceMap) {
            sourceObjectInfo = sourceMap[key];
            index.splice(binarySearchPos(index, sourceObjectInfo), 0, sourceObjectInfo);
          }
        }
        if (inserted) {
          buildIndex = !index.length;
          for (var i = 0, sourceObject; sourceObject = inserted[i]; i++) {
            sourceObjectInfo = {
              object: sourceObject,
              value: this.rule(sourceObject)
            };
            sourceMap[sourceObject.basisObjectId] = sourceObjectInfo;
            if (!buildIndex) index.splice(binarySearchPos(index, sourceObjectInfo), 0, sourceObjectInfo); else index.push(sourceObjectInfo);
            if (updateHandler) sourceObject.addHandler(updateHandler, this);
          }
          if (buildIndex) index.sort(sliceIndexSort);
        }
        this.applyRule();
      }
    };
    var Slice = Class(SourceDataset, {
      className: namespace + ".Slice",
      rule: getter($true),
      emit_ruleChanged: createEvent("ruleChanged", "oldRule", "oldOrderDesc"),
      ruleEvents: createRuleEvents(SLICE_SOURCEOBJECT_UPDATE, "update"),
      index_: null,
      orderDesc: false,
      offset: 0,
      limit: 10,
      listen: {
        source: SLICE_SOURCE_HANDLER
      },
      emit_rangeChanged: createEvent("rangeChanged", "oldOffset", "oldLimit"),
      init: function() {
        this.index_ = [];
        SourceDataset.prototype.init.call(this);
      },
      setRange: function(offset, limit) {
        var oldOffset = this.offset;
        var oldLimit = this.limit;
        var delta = false;
        if (oldOffset != offset || oldLimit != limit) {
          this.offset = offset;
          this.limit = limit;
          delta = this.applyRule();
          this.emit_rangeChanged(oldOffset, oldLimit);
        }
        return delta;
      },
      setOffset: function(offset) {
        return this.setRange(offset, this.limit);
      },
      setLimit: function(limit) {
        return this.setRange(this.offset, limit);
      },
      setRule: function(rule, orderDesc) {
        rule = getter(rule || $true);
        orderDesc = !!orderDesc;
        if (this.rule != rule || this.orderDesc != orderDesc) {
          var oldRule = this.rule;
          var oldOrderDesc = this.orderDesc;
          if (this.rule != rule) {
            var index = this.index_;
            for (var i = 0; i < index.length; i++) index[i].value = rule(index[i].object);
            index.sort(sliceIndexSort);
            this.rule = rule;
          }
          this.orderDesc = orderDesc;
          this.rule = rule;
          this.emit_ruleChanged(oldRule, oldOrderDesc);
          return this.applyRule();
        }
      },
      applyRule: function() {
        var start = this.offset;
        var end = start + this.limit;
        if (this.orderDesc) {
          start = this.index_.length - end;
          end = start + this.limit;
        }
        var curSet = basis.object.slice(this.members_);
        var newSet = this.index_.slice(Math.max(0, start), Math.max(0, end));
        var inserted = [];
        var delta;
        for (var i = 0, item; item = newSet[i]; i++) {
          var objectId = item.object.basisObjectId;
          if (curSet[objectId]) delete curSet[objectId]; else {
            inserted.push(item.object);
            this.members_[objectId] = item.object;
          }
        }
        for (var objectId in curSet) delete this.members_[objectId];
        if (delta = getDelta(inserted, values(curSet))) this.emit_itemsChanged(delta);
        return delta;
      },
      destroy: function() {
        SourceDataset.prototype.destroy.call(this);
        this.index_ = null;
      }
    });
    var CLOUD_SOURCEOBJECT_UPDATE = function(sourceObject) {
      var sourceMap = this.sourceMap_;
      var memberMap = this.members_;
      var sourceObjectId = sourceObject.basisObjectId;
      var oldList = sourceMap[sourceObjectId].list;
      var newList = sourceMap[sourceObjectId].list = {};
      var list = this.rule(sourceObject);
      var delta;
      var inserted = [];
      var deleted = [];
      var subset;
      if (Array.isArray(list)) for (var j = 0; j < list.length; j++) {
        subset = this.keyMap.get(list[j], true);
        if (subset && !subset.has(sourceObject)) {
          subsetId = subset.basisObjectId;
          newList[subsetId] = subset;
          if (!oldList[subsetId]) {
            subset.dataset.emit_itemsChanged({
              inserted: [ sourceObject ]
            });
            if (!memberMap[subsetId]) {
              inserted.push(subset);
              memberMap[subsetId] = 1;
            } else memberMap[subsetId]++;
          }
        }
      }
      for (var subsetId in oldList) if (!newList[subsetId]) {
        var subset = oldList[subsetId];
        subset.dataset.emit_itemsChanged({
          deleted: [ sourceObject ]
        });
        if (!--memberMap[subsetId]) {
          delete memberMap[subsetId];
          deleted.push(subset);
        }
      }
      if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
    };
    var CLOUD_SOURCE_HANDLER = {
      itemsChanged: function(dataset, delta) {
        var sourceMap = this.sourceMap_;
        var memberMap = this.members_;
        var updateHandler = this.ruleEvents;
        var array;
        var subset;
        var subsetId;
        var inserted = [];
        var deleted = [];
        setAccumulateState(true);
        if (array = delta.inserted) for (var i = 0, sourceObject; sourceObject = array[i]; i++) {
          var list = this.rule(sourceObject);
          var sourceObjectInfo = {
            object: sourceObject,
            list: {}
          };
          sourceMap[sourceObject.basisObjectId] = sourceObjectInfo;
          if (Array.isArray(list)) for (var j = 0, dupFilter = {}; j < list.length; j++) {
            subset = this.keyMap.get(list[j], true);
            if (subset && !dupFilter[subset.basisObjectId]) {
              subsetId = subset.basisObjectId;
              dupFilter[subsetId] = true;
              sourceObjectInfo.list[subsetId] = subset;
              subset.dataset.emit_itemsChanged({
                inserted: [ sourceObject ]
              });
              if (!memberMap[subsetId]) {
                inserted.push(subset);
                memberMap[subsetId] = 1;
              } else memberMap[subsetId]++;
            }
          }
          if (updateHandler) sourceObject.addHandler(updateHandler, this);
        }
        if (array = delta.deleted) for (var i = 0, sourceObject; sourceObject = array[i]; i++) {
          var sourceObjectId = sourceObject.basisObjectId;
          var list = sourceMap[sourceObjectId].list;
          delete sourceMap[sourceObjectId];
          for (var subsetId in list) {
            subset = list[subsetId];
            subset.dataset.emit_itemsChanged({
              deleted: [ sourceObject ]
            });
            if (!--memberMap[subsetId]) {
              delete memberMap[subsetId];
              deleted.push(subset);
            }
          }
          if (updateHandler) sourceObject.removeHandler(updateHandler, this);
        }
        setAccumulateState(false);
        if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
      }
    };
    var Cloud = Class(SourceDataset, {
      className: namespace + ".Cloud",
      subsetClass: ReadOnlyDataset,
      subsetWrapperClass: DatasetWrapper,
      rule: getter($undef),
      ruleEvents: createRuleEvents(CLOUD_SOURCEOBJECT_UPDATE, "update"),
      keyMap: null,
      map: $self,
      listen: {
        source: CLOUD_SOURCE_HANDLER
      },
      init: function() {
        if (!this.keyMap || this.keyMap instanceof KeyObjectMap == false) this.keyMap = createKeyMap(this.keyMap, this.rule, this.subsetWrapperClass, this.subsetClass);
        SourceDataset.prototype.init.call(this);
      },
      getSubset: function(data, autocreate) {
        return this.keyMap.get(data, autocreate);
      },
      destroy: function() {
        SourceDataset.prototype.destroy.call(this);
        this.keyMap.destroy();
        this.keyMap = null;
      }
    });
    var EXTRACT_SOURCEOBJECT_UPDATE = function(sourceObject) {
      var sourceObjectInfo = this.sourceMap_[sourceObject.basisObjectId];
      var newValue = this.rule(sourceObject) || null;
      var oldValue = sourceObjectInfo.value;
      var inserted;
      var deleted;
      var delta;
      if (newValue === oldValue) return;
      if (newValue instanceof DataObject || newValue instanceof ReadOnlyDataset) inserted = addToExtract(this, newValue, sourceObject);
      if (oldValue) deleted = removeFromExtract(this, oldValue, sourceObject);
      sourceObjectInfo.value = newValue;
      if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
    };
    var EXTRACT_DATASET_ITEMSCHANGED = function(dataset, delta) {
      var inserted = delta.inserted;
      var deleted = delta.deleted;
      var delta;
      if (inserted) inserted = addToExtract(this, inserted, dataset);
      if (deleted) deleted = removeFromExtract(this, deleted, dataset);
      if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
    };
    var EXTRACT_DATASET_HANDLER = {
      itemsChanged: EXTRACT_DATASET_ITEMSCHANGED,
      destroy: function(dataset) {
        var sourceMap = this.sourceMap_;
        for (var cursor = sourceMap[dataset.basisObjectId]; cursor = cursor.ref; ) sourceMap[cursor.object.basisObjectId].value = null;
        delete sourceMap[dataset.basisObjectId];
      }
    };
    function hasExtractSourceRef(extract, object, marker) {
      var sourceObjectInfo = extract.sourceMap_[object.basisObjectId];
      if (sourceObjectInfo && sourceObjectInfo.visited !== marker) {
        for (var cursor = sourceObjectInfo; cursor = cursor.ref; ) if (cursor.object === extract.source) return true;
        sourceObjectInfo.visited = marker;
        for (var cursor = sourceObjectInfo; cursor = cursor.ref; ) if (hasExtractSourceRef(extract, cursor.object, marker || {})) return true;
      }
    }
    function addToExtract(extract, items, ref) {
      var sourceMap = extract.sourceMap_;
      var members = extract.members_;
      var queue = arrayFrom(items);
      var inserted = [];
      for (var i = 0; i < queue.length; i++) {
        var item = queue[i];
        var sourceObjectId = item.basisObjectId;
        if (!sourceObjectId) {
          ref = item.ref;
          item = item.object;
          sourceObjectId = item.basisObjectId;
        }
        var sourceObjectInfo = sourceMap[sourceObjectId];
        if (sourceObjectInfo) {
          sourceObjectInfo.ref = {
            object: ref,
            ref: sourceObjectInfo.ref
          };
        } else {
          sourceObjectInfo = sourceMap[sourceObjectId] = {
            source: item,
            ref: {
              object: ref,
              ref: null
            },
            visited: null,
            value: null
          };
          if (item instanceof DataObject) {
            var value = extract.rule(item) || null;
            if (value instanceof DataObject || value instanceof ReadOnlyDataset) {
              sourceObjectInfo.value = value;
              queue.push({
                object: value,
                ref: item
              });
            }
            members[sourceObjectId] = sourceObjectInfo;
            inserted.push(item);
            if (extract.ruleEvents) item.addHandler(extract.ruleEvents, extract);
          } else {
            item.addHandler(EXTRACT_DATASET_HANDLER, extract);
            for (var j = 0, datasetItems = item.getItems(); j < datasetItems.length; j++) queue.push({
              object: datasetItems[j],
              ref: item
            });
          }
        }
      }
      return inserted;
    }
    function removeFromExtract(extract, items, ref) {
      var sourceMap = extract.sourceMap_;
      var members = extract.members_;
      var queue = arrayFrom(items);
      var deleted = [];
      for (var i = 0; i < queue.length; i++) {
        var item = queue[i];
        var sourceObjectId = item.basisObjectId;
        if (!sourceObjectId) {
          ref = item.ref;
          item = item.object;
          sourceObjectId = item.basisObjectId;
        }
        var sourceObjectInfo = sourceMap[sourceObjectId];
        var sourceObjectValue = sourceObjectInfo.value;
        for (var cursor = sourceObjectInfo, prevCursor = sourceObjectInfo; cursor = cursor.ref; ) {
          if (cursor.object === ref) {
            prevCursor.ref = cursor.ref;
            break;
          }
          prevCursor = cursor;
        }
        if (!sourceObjectInfo.ref) {
          if (item instanceof DataObject) {
            delete members[sourceObjectId];
            deleted.push(item);
            if (extract.ruleEvents) item.removeHandler(extract.ruleEvents, extract);
            if (sourceObjectValue) queue.push({
              object: sourceObjectValue,
              ref: item
            });
          } else {
            item.removeHandler(EXTRACT_DATASET_HANDLER, extract);
            for (var j = 0, datasetItems = item.getItems(); j < datasetItems.length; j++) queue.push({
              object: datasetItems[j],
              ref: item
            });
          }
          delete sourceMap[sourceObjectId];
        } else {
          if (sourceObjectValue && !hasExtractSourceRef(extract, item)) {
            sourceObjectInfo.value = null;
            queue.push({
              object: sourceObjectValue,
              ref: item
            });
          }
        }
      }
      return deleted;
    }
    var Extract = SourceDataset.subclass({
      className: namespace + ".Extract",
      rule: getter($undef),
      emit_ruleChanged: createEvent("ruleChanged", "oldRule"),
      ruleEvents: createRuleEvents(EXTRACT_SOURCEOBJECT_UPDATE, "update"),
      listen: {
        source: {
          itemsChanged: EXTRACT_DATASET_ITEMSCHANGED
        }
      },
      setRule: function(rule) {
        rule = getter(rule || $undef);
        if (this.rule !== rule) {
          var oldRule = this.rule;
          this.rule = rule;
          this.emit_ruleChanged(oldRule);
          return this.applyRule();
        }
      },
      applyRule: function() {
        var insertedMap = {};
        var deletedMap = {};
        var array;
        var delta;
        for (var key in this.sourceMap_) {
          var sourceObjectInfo = this.sourceMap_[key];
          var sourceObject = sourceObjectInfo.source;
          if (sourceObject instanceof DataObject) {
            var newValue = this.rule(sourceObject) || null;
            var oldValue = sourceObjectInfo.value;
            if (newValue === oldValue) continue;
            if (newValue instanceof DataObject || newValue instanceof ReadOnlyDataset) {
              var inserted = addToExtract(this, newValue, sourceObject);
              for (var i = 0; i < inserted.length; i++) {
                var item = inserted[i];
                var id = item.basisObjectId;
                if (deletedMap[id]) delete deletedMap[id]; else insertedMap[id] = item;
              }
            }
            if (oldValue) {
              var deleted = removeFromExtract(this, oldValue, sourceObject);
              for (var i = 0; i < deleted.length; i++) {
                var item = deleted[i];
                var id = item.basisObjectId;
                if (insertedMap[id]) delete insertedMap[id]; else deletedMap[id] = item;
              }
            }
            sourceObjectInfo.value = newValue;
          }
        }
        if (delta = getDelta(values(insertedMap), values(deletedMap))) this.emit_itemsChanged(delta);
        return delta;
      }
    });
    module.exports = {
      getDelta: getDelta,
      createRuleEvents: createRuleEvents,
      Merge: Merge,
      Subtract: Subtract,
      SourceDataset: SourceDataset,
      MapFilter: MapFilter,
      Filter: Filter,
      Split: Split,
      Extract: Extract,
      Slice: Slice,
      Cloud: Cloud
    };
  },
  "g.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./a.js");
    basis.require("./h.js");
    var namespace = this.path;
    var createEvent = basis.event.create;
    var createAction = basis.net.action.create;
    var Emitter = basis.event.Emitter;
    var AjaxTransport = basis.net.ajax.Transport;
    var SERVICE_HANDLER = {
      start: function(service, request) {
        basis.array.add(this.inprogressTransports, request.transport);
      },
      complete: function(service, request) {
        basis.array.remove(this.inprogressTransports, request.transport);
      }
    };
    var Service = Emitter.subclass({
      className: namespace + ".Service",
      inprogressTransports: null,
      transportClass: AjaxTransport,
      emit_sessionOpen: createEvent("sessionOpen"),
      emit_sessionClose: createEvent("sessionClose"),
      emit_sessionFreeze: createEvent("sessionFreeze"),
      emit_sessionUnfreeze: createEvent("sessionUnfreeze"),
      isSecure: false,
      prepare: basis.fn.$true,
      signature: basis.fn.$undef,
      isSessionExpiredError: basis.fn.$false,
      init: function() {
        if (this.requestClass) basis.dev.warn(namespace + ".Service#requestClass is not supported; set requestClass via transportClass");
        Emitter.prototype.init.call(this);
        this.inprogressTransports = [];
        var TransportClass = this.transportClass;
        this.transportClass = TransportClass.subclass({
          service: this,
          needSignature: this.isSecure,
          emit_failure: function(request, error) {
            TransportClass.prototype.emit_failure.call(this, request, error);
            if (this.needSignature && this.service.isSessionExpiredError(request)) {
              this.service.freeze();
              this.service.stoppedTransports.push(this);
              this.stop();
            }
          },
          request: function(requestData) {
            if (!this.service.prepare(this, requestData)) return;
            if (this.needSignature && !this.service.sign(this)) return;
            return TransportClass.prototype.request.call(this, requestData);
          }
        });
        this.addHandler(SERVICE_HANDLER);
      },
      sign: function(transport) {
        if (this.sessionKey) {
          this.signature(transport, this.sessionData);
          return true;
        } else {
          basis.dev.warn("Request ignored. Service have no session key");
        }
      },
      openSession: function(sessionKey, sessionData) {
        this.sessionKey = sessionKey;
        this.sessionData = sessionData;
        this.unfreeze();
        this.emit_sessionOpen();
      },
      closeSession: function() {
        this.freeze();
        this.emit_sessionClose();
      },
      freeze: function() {
        if (!this.sessionKey) return;
        this.sessionKey = null;
        this.sessionData = null;
        this.stoppedTransports = this.inprogressTransports.filter(function(transport) {
          return transport.needSignature;
        });
        for (var i = 0, transport; transport = this.inprogressTransports[i]; i++) transport.stop();
        this.emit_sessionFreeze();
      },
      unfreeze: function() {
        if (this.stoppedTransports) for (var i = 0, transport; transport = this.stoppedTransports[i]; i++) transport.resume();
        this.emit_sessionUnfreeze();
      },
      createTransport: function(config) {
        return new this.transportClass(config);
      },
      createAction: function(config) {
        return createAction(basis.object.complete({
          service: this
        }, config));
      },
      destroy: function() {
        this.inprogressTransports = null;
        this.stoppedTransports = null;
        this.sessionKey = null;
        this.sessionData = null;
        Emitter.prototype.destroy.call(this);
      }
    });
    module.exports = {
      Service: Service
    };
  },
  "h.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./4.js");
    basis.require("./a.js");
    var STATE_UNDEFINED = basis.data.STATE.UNDEFINED;
    var STATE_READY = basis.data.STATE.READY;
    var STATE_PROCESSING = basis.data.STATE.PROCESSING;
    var STATE_ERROR = basis.data.STATE.ERROR;
    var nothingToDo = function() {};
    var CALLBACK_HANDLER = {
      start: function(transport, request) {
        var origin = request.requestData.origin;
        this.start.call(request.requestData.origin);
        if (origin.state != STATE_PROCESSING) origin.setState(STATE_PROCESSING);
      },
      success: function(transport, request, data) {
        var origin = request.requestData.origin;
        this.success.call(origin, data);
        if (origin.state == STATE_PROCESSING) origin.setState(STATE_READY);
      },
      failure: function(transport, request, error) {
        var origin = request.requestData.origin;
        this.failure.call(origin, error);
        if (origin.state == STATE_PROCESSING) origin.setState(STATE_ERROR, error);
      },
      abort: function(transport, request) {
        var origin = request.requestData.origin;
        this.abort.call(origin);
        if (origin.state == STATE_PROCESSING) origin.setState(STATE_UNDEFINED);
      },
      complete: function(transport, request) {
        this.complete.call(request.requestData.origin);
      }
    };
    var DEFAULT_CALLBACK = {
      start: nothingToDo,
      success: nothingToDo,
      failure: nothingToDo,
      abort: nothingToDo,
      complete: nothingToDo
    };
    function resolveTransport(config) {
      if (config.transport) return config.transport;
      if (config.service) return config.service.createTransport(config);
      if (config.createTransport) return config.createTransport(config);
      return new basis.net.ajax.Transport(config);
    }
    function createAction(config) {
      config = basis.object.extend({
        prepare: nothingToDo,
        request: nothingToDo
      }, config);
      var fn = basis.object.splice(config, [ "prepare", "request" ]);
      var callback = basis.object.merge(DEFAULT_CALLBACK, basis.object.splice(config, [ "start", "success", "failure", "abort", "complete" ]));
      var getTransport = basis.fn.lazyInit(function() {
        var transport = resolveTransport(config);
        transport.addHandler(CALLBACK_HANDLER, callback);
        return transport;
      });
      return function action() {
        if (this.state != STATE_PROCESSING) {
          fn.prepare.apply(this, arguments);
          this.request = getTransport().request(basis.object.complete({
            origin: this
          }, fn.request.apply(this, arguments)));
        } else {
          basis.dev.warn(this + " has not ready state. Operation aborted");
        }
      };
    }
    module.exports = {
      create: createAction
    };
  },
  "v.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    (function(undefined) {
      var moment, VERSION = "2.8.4", globalScope = typeof global !== "undefined" ? global : this, oldGlobalMoment, round = Math.round, hasOwnProperty = Object.prototype.hasOwnProperty, i, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = typeof module !== "undefined" && module && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenOffsetMs = /[\+\-]?\d+/, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/ ], [ "YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d{2}/ ], [ "YYYY-DDD", /\d{4}-\d{3}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss", /(T| )\d\d:\d\d:\d\d/ ], [ "HH:mm", /(T| )\d\d:\d\d/ ], [ "HH", /(T| )\d\d/ ] ], parseTimezoneChunker = /([\+\-]|\d\d)/gi, proxyGettersAndSetters = "Date|Hours|Minutes|Seconds|Milliseconds".split("|"), unitMillisecondFactors = {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
      }, unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
      }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
      }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
      }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function() {
          return this.month() + 1;
        },
        MMM: function(format) {
          return this.localeData().monthsShort(this, format);
        },
        MMMM: function(format) {
          return this.localeData().months(this, format);
        },
        D: function() {
          return this.date();
        },
        DDD: function() {
          return this.dayOfYear();
        },
        d: function() {
          return this.day();
        },
        dd: function(format) {
          return this.localeData().weekdaysMin(this, format);
        },
        ddd: function(format) {
          return this.localeData().weekdaysShort(this, format);
        },
        dddd: function(format) {
          return this.localeData().weekdays(this, format);
        },
        w: function() {
          return this.week();
        },
        W: function() {
          return this.isoWeek();
        },
        YY: function() {
          return leftZeroFill(this.year() % 100, 2);
        },
        YYYY: function() {
          return leftZeroFill(this.year(), 4);
        },
        YYYYY: function() {
          return leftZeroFill(this.year(), 5);
        },
        YYYYYY: function() {
          var y = this.year(), sign = y >= 0 ? "+" : "-";
          return sign + leftZeroFill(Math.abs(y), 6);
        },
        gg: function() {
          return leftZeroFill(this.weekYear() % 100, 2);
        },
        gggg: function() {
          return leftZeroFill(this.weekYear(), 4);
        },
        ggggg: function() {
          return leftZeroFill(this.weekYear(), 5);
        },
        GG: function() {
          return leftZeroFill(this.isoWeekYear() % 100, 2);
        },
        GGGG: function() {
          return leftZeroFill(this.isoWeekYear(), 4);
        },
        GGGGG: function() {
          return leftZeroFill(this.isoWeekYear(), 5);
        },
        e: function() {
          return this.weekday();
        },
        E: function() {
          return this.isoWeekday();
        },
        a: function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), true);
        },
        A: function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), false);
        },
        H: function() {
          return this.hours();
        },
        h: function() {
          return this.hours() % 12 || 12;
        },
        m: function() {
          return this.minutes();
        },
        s: function() {
          return this.seconds();
        },
        S: function() {
          return toInt(this.milliseconds() / 100);
        },
        SS: function() {
          return leftZeroFill(toInt(this.milliseconds() / 10), 2);
        },
        SSS: function() {
          return leftZeroFill(this.milliseconds(), 3);
        },
        SSSS: function() {
          return leftZeroFill(this.milliseconds(), 3);
        },
        Z: function() {
          var a = -this.zone(), b = "+";
          if (a < 0) {
            a = -a;
            b = "-";
          }
          return b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2);
        },
        ZZ: function() {
          var a = -this.zone(), b = "+";
          if (a < 0) {
            a = -a;
            b = "-";
          }
          return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
        },
        z: function() {
          return this.zoneAbbr();
        },
        zz: function() {
          return this.zoneName();
        },
        x: function() {
          return this.valueOf();
        },
        X: function() {
          return this.unix();
        },
        Q: function() {
          return this.quarter();
        }
      }, deprecations = {}, lists = [ "months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin" ];
      function dfl(a, b, c) {
        switch (arguments.length) {
          case 2:
            return a != null ? a : b;
          case 3:
            return a != null ? a : b != null ? b : c;
          default:
            throw new Error("Implement me");
        }
      }
      function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false
        };
      }
      function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (firstTime) {
            printMsg(msg);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
          printMsg(msg);
          deprecations[name] = true;
        }
      }
      function padToken(func, count) {
        return function(a) {
          return leftZeroFill(func.call(this, a), count);
        };
      }
      function ordinalizeToken(func, period) {
        return function(a) {
          return this.localeData().ordinal(func.call(this, a), period);
        };
      }
      while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
      }
      while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
      }
      formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);
      function Locale() {}
      function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
          checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 36e5;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = moment.localeData();
        this._bubble();
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function copyConfig(to, from) {
        var i, prop, val;
        if (typeof from._isAMomentObject !== "undefined") {
          to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== "undefined") {
          to._i = from._i;
        }
        if (typeof from._f !== "undefined") {
          to._f = from._f;
        }
        if (typeof from._l !== "undefined") {
          to._l = from._l;
        }
        if (typeof from._strict !== "undefined") {
          to._strict = from._strict;
        }
        if (typeof from._tzm !== "undefined") {
          to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== "undefined") {
          to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== "undefined") {
          to._offset = from._offset;
        }
        if (typeof from._pf !== "undefined") {
          to._pf = from._pf;
        }
        if (typeof from._locale !== "undefined") {
          to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
          for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (typeof val !== "undefined") {
              to[prop] = val;
            }
          }
        }
        return to;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.ceil(number);
        } else {
          return Math.floor(number);
        }
      }
      function leftZeroFill(number, targetLength, forceSign) {
        var output = "" + Math.abs(number), sign = number >= 0;
        while (output.length < targetLength) {
          output = "0" + output;
        }
        return (sign ? forceSign ? "+" : "" : "-") + output;
      }
      function positiveMomentsDifference(base, other) {
        var res = {
          milliseconds: 0,
          months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period).");
            tmp = val;
            val = period;
            period = tmp;
          }
          val = typeof val === "string" ? +val : val;
          dur = moment.duration(val, period);
          addOrSubtractDurationFromMoment(this, dur, direction);
          return this;
        };
      }
      function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
          mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
          rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding);
        }
        if (months) {
          rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding);
        }
        if (updateOffset) {
          moment.updateOffset(mom, days || months);
        }
      }
      function isArray(input) {
        return Object.prototype.toString.call(input) === "[object Array]";
      }
      function isDate(input) {
        return Object.prototype.toString.call(input) === "[object Date]" || input instanceof Date;
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function normalizeUnits(units) {
        if (units) {
          var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
          units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      function makeList(field) {
        var count, setter;
        if (field.indexOf("week") === 0) {
          count = 7;
          setter = "day";
        } else if (field.indexOf("month") === 0) {
          count = 12;
          setter = "month";
        } else {
          return;
        }
        moment[field] = function(format, index) {
          var i, getter, method = moment._locale[field], results = [];
          if (typeof format === "number") {
            index = format;
            format = undefined;
          }
          getter = function(i) {
            var m = moment().utc().set(setter, i);
            return method.call(moment._locale, m, format || "");
          };
          if (index != null) {
            return getter(index);
          } else {
            for (i = 0; i < count; i++) {
              results.push(getter(i));
            }
            return results;
          }
        };
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          if (coercedNumber >= 0) {
            value = Math.floor(coercedNumber);
          } else {
            value = Math.ceil(coercedNumber);
          }
        }
        return value;
      }
      function daysInMonth(year, month) {
        return (new Date(Date.UTC(year, month + 1, 0))).getUTCDate();
      }
      function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([ year, 11, 31 + dow - doy ]), dow, doy).week;
      }
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
          overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 || m._a[SECOND] !== 0 || m._a[MILLISECOND] !== 0) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          m._pf.overflow = overflow;
        }
      }
      function isValid(m) {
        if (m._isValid == null) {
          m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated;
          if (m._strict) {
            m._isValid = m._isValid && m._pf.charsLeftOver === 0 && m._pf.unusedTokens.length === 0 && m._pf.bigHour === undefined;
          }
        }
        return m._isValid;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join("-"));
            if (locale) {
              return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return null;
      }
      function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
          try {
            oldLocale = moment.locale();
            basis.require("./locale/" + name, "C:/repos/git/timesheet/public/components/moment");
            moment.locale(oldLocale);
          } catch (e) {}
        }
        return locales[name];
      }
      function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res;
          res._d.setTime(+res._d + diff);
          moment.updateOffset(res, false);
          return res;
        } else {
          return moment(input).local();
        }
      }
      extend(Locale.prototype, {
        set: function(config) {
          var prop, i;
          for (i in config) {
            prop = config[i];
            if (typeof prop === "function") {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
          this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function(m) {
          return this._months[m.month()];
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function(m) {
          return this._monthsShort[m.month()];
        },
        monthsParse: function(monthName, format, strict) {
          var i, mom, regex;
          if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
          }
          for (i = 0; i < 12; i++) {
            mom = moment.utc([ 2e3, i ]);
            if (strict && !this._longMonthsParse[i]) {
              this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
              this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
            }
            if (!strict && !this._monthsParse[i]) {
              regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
              this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (strict && format === "MMMM" && this._longMonthsParse[i].test(monthName)) {
              return i;
            } else if (strict && format === "MMM" && this._shortMonthsParse[i].test(monthName)) {
              return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
              return i;
            }
          }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function(m) {
          return this._weekdays[m.day()];
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function(m) {
          return this._weekdaysShort[m.day()];
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function(m) {
          return this._weekdaysMin[m.day()];
        },
        weekdaysParse: function(weekdayName) {
          var i, mom, regex;
          if (!this._weekdaysParse) {
            this._weekdaysParse = [];
          }
          for (i = 0; i < 7; i++) {
            if (!this._weekdaysParse[i]) {
              mom = moment([ 2e3, 1 ]).day(i);
              regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
              this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
            }
            if (this._weekdaysParse[i].test(weekdayName)) {
              return i;
            }
          }
        },
        _longDateFormat: {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY LT",
          LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function(key) {
          var output = this._longDateFormat[key];
          if (!output && this._longDateFormat[key.toUpperCase()]) {
            output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function(val) {
              return val.slice(1);
            });
            this._longDateFormat[key] = output;
          }
          return output;
        },
        isPM: function(input) {
          return (input + "").toLowerCase().charAt(0) === "p";
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function(hours, minutes, isLower) {
          if (hours > 11) {
            return isLower ? "pm" : "PM";
          } else {
            return isLower ? "am" : "AM";
          }
        },
        _calendar: {
          sameDay: "[Today at] LT",
          nextDay: "[Tomorrow at] LT",
          nextWeek: "dddd [at] LT",
          lastDay: "[Yesterday at] LT",
          lastWeek: "[Last] dddd [at] LT",
          sameElse: "L"
        },
        calendar: function(key, mom, now) {
          var output = this._calendar[key];
          return typeof output === "function" ? output.apply(mom, [ now ]) : output;
        },
        _relativeTime: {
          future: "in %s",
          past: "%s ago",
          s: "a few seconds",
          m: "a minute",
          mm: "%d minutes",
          h: "an hour",
          hh: "%d hours",
          d: "a day",
          dd: "%d days",
          M: "a month",
          MM: "%d months",
          y: "a year",
          yy: "%d years"
        },
        relativeTime: function(number, withoutSuffix, string, isFuture) {
          var output = this._relativeTime[string];
          return typeof output === "function" ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
        },
        pastFuture: function(diff, output) {
          var format = this._relativeTime[diff > 0 ? "future" : "past"];
          return typeof format === "function" ? format(output) : format.replace(/%s/i, output);
        },
        ordinal: function(number) {
          return this._ordinal.replace("%d", number);
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function(string) {
          return string;
        },
        postformat: function(string) {
          return string;
        },
        week: function(mom) {
          return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },
        _week: {
          dow: 0,
          doy: 6
        },
        _invalidDate: "Invalid date",
        invalidDate: function() {
          return this._invalidDate;
        }
      });
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "";
          for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
          }
          return output;
        };
      }
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        if (!formatFunctions[format]) {
          formatFunctions[format] = makeFormatFunction(format);
        }
        return formatFunctions[format](m);
      }
      function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format;
      }
      function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
          case "Q":
            return parseTokenOneDigit;
          case "DDDD":
            return parseTokenThreeDigits;
          case "YYYY":
          case "GGGG":
          case "gggg":
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
          case "Y":
          case "G":
          case "g":
            return parseTokenSignedNumber;
          case "YYYYYY":
          case "YYYYY":
          case "GGGGG":
          case "ggggg":
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
          case "S":
            if (strict) {
              return parseTokenOneDigit;
            }
          case "SS":
            if (strict) {
              return parseTokenTwoDigits;
            }
          case "SSS":
            if (strict) {
              return parseTokenThreeDigits;
            }
          case "DDD":
            return parseTokenOneToThreeDigits;
          case "MMM":
          case "MMMM":
          case "dd":
          case "ddd":
          case "dddd":
            return parseTokenWord;
          case "a":
          case "A":
            return config._locale._meridiemParse;
          case "x":
            return parseTokenOffsetMs;
          case "X":
            return parseTokenTimestampMs;
          case "Z":
          case "ZZ":
            return parseTokenTimezone;
          case "T":
            return parseTokenT;
          case "SSSS":
            return parseTokenDigits;
          case "MM":
          case "DD":
          case "YY":
          case "GG":
          case "gg":
          case "HH":
          case "hh":
          case "mm":
          case "ss":
          case "ww":
          case "WW":
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
          case "M":
          case "D":
          case "d":
          case "H":
          case "h":
          case "m":
          case "s":
          case "w":
          case "W":
          case "e":
          case "E":
            return parseTokenOneOrTwoDigits;
          case "Do":
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
          default:
            a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"));
            return a;
        }
      }
      function timezoneMinutesFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || [ "-", 0, 0 ], minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === "+" ? -minutes : minutes;
      }
      function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
          case "Q":
            if (input != null) {
              datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
          case "M":
          case "MM":
            if (input != null) {
              datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
          case "MMM":
          case "MMMM":
            a = config._locale.monthsParse(input, token, config._strict);
            if (a != null) {
              datePartArray[MONTH] = a;
            } else {
              config._pf.invalidMonth = input;
            }
            break;
          case "D":
          case "DD":
            if (input != null) {
              datePartArray[DATE] = toInt(input);
            }
            break;
          case "Do":
            if (input != null) {
              datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10));
            }
            break;
          case "DDD":
          case "DDDD":
            if (input != null) {
              config._dayOfYear = toInt(input);
            }
            break;
          case "YY":
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
          case "YYYY":
          case "YYYYY":
          case "YYYYYY":
            datePartArray[YEAR] = toInt(input);
            break;
          case "a":
          case "A":
            config._isPm = config._locale.isPM(input);
            break;
          case "h":
          case "hh":
            config._pf.bigHour = true;
          case "H":
          case "HH":
            datePartArray[HOUR] = toInt(input);
            break;
          case "m":
          case "mm":
            datePartArray[MINUTE] = toInt(input);
            break;
          case "s":
          case "ss":
            datePartArray[SECOND] = toInt(input);
            break;
          case "S":
          case "SS":
          case "SSS":
          case "SSSS":
            datePartArray[MILLISECOND] = toInt(("0." + input) * 1e3);
            break;
          case "x":
            config._d = new Date(toInt(input));
            break;
          case "X":
            config._d = new Date(parseFloat(input) * 1e3);
            break;
          case "Z":
          case "ZZ":
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
          case "dd":
          case "ddd":
          case "dddd":
            a = config._locale.weekdaysParse(input);
            if (a != null) {
              config._w = config._w || {};
              config._w["d"] = a;
            } else {
              config._pf.invalidWeekday = input;
            }
            break;
          case "w":
          case "ww":
          case "W":
          case "WW":
          case "d":
          case "e":
          case "E":
            token = token.substr(0, 1);
          case "gggg":
          case "GGGG":
          case "GGGGG":
            token = token.substr(0, 2);
            if (input) {
              config._w = config._w || {};
              config._w[token] = toInt(input);
            }
            break;
          case "gg":
          case "GG":
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
          week = dfl(w.W, 1);
          weekday = dfl(w.E, 1);
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
          week = dfl(w.w, 1);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < dow) {
              ++week;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
          } else {
            weekday = dow;
          }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
      function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
          yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse)) {
            config._pf._overflowDayOfYear = true;
          }
          date = makeUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
      }
      function dateFromObject(config) {
        var normalizedInput;
        if (config._d) {
          return;
        }
        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [ normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond ];
        dateFromConfig(config);
      }
      function currentDateArray(config) {
        var now = new Date;
        if (config._useUTC) {
          return [ now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate() ];
        } else {
          return [ now.getFullYear(), now.getMonth(), now.getDate() ];
        }
      }
      function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
          parseISO(config);
          return;
        }
        config._a = [];
        config._pf.empty = true;
        var string = "" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              config._pf.unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              config._pf.empty = false;
            } else {
              config._pf.unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            config._pf.unusedTokens.push(token);
          }
        }
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          config._pf.unusedInput.push(string);
        }
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
          config._pf.bigHour = undefined;
        }
        if (config._isPm && config._a[HOUR] < 12) {
          config._a[HOUR] += 12;
        }
        if (config._isPm === false && config._a[HOUR] === 12) {
          config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
      }
      function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        });
      }
      function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (config._f.length === 0) {
          config._pf.invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._pf = defaultParsingFlags();
          tempConfig._f = config._f[i];
          makeDateFromStringAndFormat(tempConfig);
          if (!isValid(tempConfig)) {
            continue;
          }
          currentScore += tempConfig._pf.charsLeftOver;
          currentScore += tempConfig._pf.unusedTokens.length * 10;
          tempConfig._pf.score = currentScore;
          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
          config._pf.iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(string)) {
              config._f = isoDates[i][0] + (match[6] || " ");
              break;
            }
          }
          for (i = 0, l = isoTimes.length; i < l; i++) {
            if (isoTimes[i][1].exec(string)) {
              config._f += isoTimes[i][0];
              break;
            }
          }
          if (string.match(parseTokenTimezone)) {
            config._f += "Z";
          }
          makeDateFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
          delete config._isValid;
          moment.createFromInputFallback(config);
        }
      }
      function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
          config._d = new Date;
        } else if (isDate(input)) {
          config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
          config._d = new Date(+matched[1]);
        } else if (typeof input === "string") {
          makeDateFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          dateFromConfig(config);
        } else if (typeof input === "object") {
          dateFromObject(config);
        } else if (typeof input === "number") {
          config._d = new Date(input);
        } else {
          moment.createFromInputFallback(config);
        }
      }
      function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 1970) {
          date.setFullYear(y);
        }
        return date;
      }
      function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
          date.setUTCFullYear(y);
        }
        return date;
      }
      function parseWeekday(input, locale) {
        if (typeof input === "string") {
          if (!isNaN(input)) {
            input = parseInt(input, 10);
          } else {
            input = locale.weekdaysParse(input);
            if (typeof input !== "number") {
              return null;
            }
          }
        }
        return input;
      }
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && [ "s", seconds ] || minutes === 1 && [ "m" ] || minutes < relativeTimeThresholds.m && [ "mm", minutes ] || hours === 1 && [ "h" ] || hours < relativeTimeThresholds.h && [ "hh", hours ] || days === 1 && [ "d" ] || days < relativeTimeThresholds.d && [ "dd", days ] || months === 1 && [ "M" ] || months < relativeTimeThresholds.M && [ "MM", months ] || years === 1 && [ "y" ] || [ "yy", years ];
        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
      }
      function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(), adjustedMoment;
        if (daysToDayOfWeek > end) {
          daysToDayOfWeek -= 7;
        }
        if (daysToDayOfWeek < end - 7) {
          daysToDayOfWeek += 7;
        }
        adjustedMoment = moment(mom).add(daysToDayOfWeek, "d");
        return {
          week: Math.ceil(adjustedMoment.dayOfYear() / 7),
          year: adjustedMoment.year()
        };
      }
      function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;
        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;
        return {
          year: dayOfYear > 0 ? year : year - 1,
          dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
      }
      function makeMoment(config) {
        var input = config._i, format = config._f, res;
        config._locale = config._locale || moment.localeData(config._l);
        if (input === null || format === undefined && input === "") {
          return moment.invalid({
            nullInput: true
          });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (moment.isMoment(input)) {
          return new Moment(input, true);
        } else if (format) {
          if (isArray(format)) {
            makeDateFromStringAndArray(config);
          } else {
            makeDateFromStringAndFormat(config);
          }
        } else {
          makeDateFromInput(config);
        }
        res = new Moment(config);
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = undefined;
        }
        return res;
      }
      moment = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
          strict = locale;
          locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();
        return makeMoment(c);
      };
      moment.suppressDeprecationWarnings = false;
      moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is " + "discouraged and will be removed in upcoming major " + "release. Please refer to " + "https://github.com/moment/moment/issues/1407 for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      moment.min = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      };
      moment.max = function() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      };
      moment.utc = function(input, format, locale, strict) {
        var c;
        if (typeof locale === "boolean") {
          strict = locale;
          locale = undefined;
        }
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();
        return makeMoment(c).utc();
      };
      moment.unix = function(input) {
        return moment(input * 1e3);
      };
      moment.duration = function(input, key) {
        var duration = input, match = null, sign, ret, parseIso, diffRes;
        if (moment.isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (typeof input === "number") {
          duration = {};
          if (key) {
            duration[key] = input;
          } else {
            duration.milliseconds = input;
          }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
          sign = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(match[MILLISECOND]) * sign
          };
        } else if (!!(match = isoDurationRegex.exec(input))) {
          sign = match[1] === "-" ? -1 : 1;
          parseIso = function(inp) {
            var res = inp && parseFloat(inp.replace(",", "."));
            return (isNaN(res) ? 0 : res) * sign;
          };
          duration = {
            y: parseIso(match[2]),
            M: parseIso(match[3]),
            d: parseIso(match[4]),
            h: parseIso(match[5]),
            m: parseIso(match[6]),
            s: parseIso(match[7]),
            w: parseIso(match[8])
          };
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(moment(duration.from), moment(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (moment.isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        return ret;
      };
      moment.version = VERSION;
      moment.defaultFormat = isoFormat;
      moment.ISO_8601 = function() {};
      moment.momentProperties = momentProperties;
      moment.updateOffset = function() {};
      moment.relativeTimeThreshold = function(threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
          return false;
        }
        if (limit === undefined) {
          return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
      };
      moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function(key, value) {
        return moment.locale(key, value);
      });
      moment.locale = function(key, values) {
        var data;
        if (key) {
          if (typeof values !== "undefined") {
            data = moment.defineLocale(key, values);
          } else {
            data = moment.localeData(key);
          }
          if (data) {
            moment.duration._locale = moment._locale = data;
          }
        }
        return moment._locale._abbr;
      };
      moment.defineLocale = function(name, values) {
        if (values !== null) {
          values.abbr = name;
          if (!locales[name]) {
            locales[name] = new Locale;
          }
          locales[name].set(values);
          moment.locale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      };
      moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function(key) {
        return moment.localeData(key);
      });
      moment.localeData = function(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return moment._locale;
        }
        if (!isArray(key)) {
          locale = loadLocale(key);
          if (locale) {
            return locale;
          }
          key = [ key ];
        }
        return chooseLocale(key);
      };
      moment.isMoment = function(obj) {
        return obj instanceof Moment || obj != null && hasOwnProp(obj, "_isAMomentObject");
      };
      moment.isDuration = function(obj) {
        return obj instanceof Duration;
      };
      for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
      }
      moment.normalizeUnits = function(units) {
        return normalizeUnits(units);
      };
      moment.invalid = function(flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
          extend(m._pf, flags);
        } else {
          m._pf.userInvalidated = true;
        }
        return m;
      };
      moment.parseZone = function() {
        return moment.apply(null, arguments).parseZone();
      };
      moment.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      extend(moment.fn = Moment.prototype, {
        clone: function() {
          return moment(this);
        },
        valueOf: function() {
          return +this._d + (this._offset || 0) * 6e4;
        },
        unix: function() {
          return Math.floor(+this / 1e3);
        },
        toString: function() {
          return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
        },
        toDate: function() {
          return this._offset ? new Date(+this) : this._d;
        },
        toISOString: function() {
          var m = moment(this).utc();
          if (0 < m.year() && m.year() <= 9999) {
            if ("function" === typeof Date.prototype.toISOString) {
              return this.toDate().toISOString();
            } else {
              return formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
            }
          } else {
            return formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
          }
        },
        toArray: function() {
          var m = this;
          return [ m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds() ];
        },
        isValid: function() {
          return isValid(this);
        },
        isDSTShifted: function() {
          if (this._a) {
            return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
          }
          return false;
        },
        parsingFlags: function() {
          return extend({}, this._pf);
        },
        invalidAt: function() {
          return this._pf.overflow;
        },
        utc: function(keepLocalTime) {
          return this.zone(0, keepLocalTime);
        },
        local: function(keepLocalTime) {
          if (this._isUTC) {
            this.zone(0, keepLocalTime);
            this._isUTC = false;
            if (keepLocalTime) {
              this.add(this._dateTzOffset(), "m");
            }
          }
          return this;
        },
        format: function(inputString) {
          var output = formatMoment(this, inputString || moment.defaultFormat);
          return this.localeData().postformat(output);
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function(input, units, asFloat) {
          var that = makeAs(input, this), zoneDiff = (this.zone() - that.zone()) * 6e4, diff, output, daysAdjust;
          units = normalizeUnits(units);
          if (units === "year" || units === "month") {
            diff = (this.daysInMonth() + that.daysInMonth()) * 432e5;
            output = (this.year() - that.year()) * 12 + (this.month() - that.month());
            daysAdjust = this - moment(this).startOf("month") - (that - moment(that).startOf("month"));
            daysAdjust -= (this.zone() - moment(this).startOf("month").zone() - (that.zone() - moment(that).startOf("month").zone())) * 6e4;
            output += daysAdjust / diff;
            if (units === "year") {
              output = output / 12;
            }
          } else {
            diff = this - that;
            output = units === "second" ? diff / 1e3 : units === "minute" ? diff / 6e4 : units === "hour" ? diff / 36e5 : units === "day" ? (diff - zoneDiff) / 864e5 : units === "week" ? (diff - zoneDiff) / 6048e5 : diff;
          }
          return asFloat ? output : absRound(output);
        },
        from: function(time, withoutSuffix) {
          return moment.duration({
            to: this,
            from: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        },
        fromNow: function(withoutSuffix) {
          return this.from(moment(), withoutSuffix);
        },
        calendar: function(time) {
          var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", true), format = diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
          return this.format(this.localeData().calendar(format, this, moment(now)));
        },
        isLeapYear: function() {
          return isLeapYear(this.year());
        },
        isDST: function() {
          return this.zone() < this.clone().month(0).zone() || this.zone() < this.clone().month(5).zone();
        },
        day: function(input) {
          var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
          if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, "d");
          } else {
            return day;
          }
        },
        month: makeAccessor("Month", true),
        startOf: function(units) {
          units = normalizeUnits(units);
          switch (units) {
            case "year":
              this.month(0);
            case "quarter":
            case "month":
              this.date(1);
            case "week":
            case "isoWeek":
            case "day":
              this.hours(0);
            case "hour":
              this.minutes(0);
            case "minute":
              this.seconds(0);
            case "second":
              this.milliseconds(0);
          }
          if (units === "week") {
            this.weekday(0);
          } else if (units === "isoWeek") {
            this.isoWeekday(1);
          }
          if (units === "quarter") {
            this.month(Math.floor(this.month() / 3) * 3);
          }
          return this;
        },
        endOf: function(units) {
          units = normalizeUnits(units);
          if (units === undefined || units === "millisecond") {
            return this;
          }
          return this.startOf(units).add(1, units === "isoWeek" ? "week" : units).subtract(1, "ms");
        },
        isAfter: function(input, units) {
          var inputMs;
          units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
          if (units === "millisecond") {
            input = moment.isMoment(input) ? input : moment(input);
            return +this > +input;
          } else {
            inputMs = moment.isMoment(input) ? +input : +moment(input);
            return inputMs < +this.clone().startOf(units);
          }
        },
        isBefore: function(input, units) {
          var inputMs;
          units = normalizeUnits(typeof units !== "undefined" ? units : "millisecond");
          if (units === "millisecond") {
            input = moment.isMoment(input) ? input : moment(input);
            return +this < +input;
          } else {
            inputMs = moment.isMoment(input) ? +input : +moment(input);
            return +this.clone().endOf(units) < inputMs;
          }
        },
        isSame: function(input, units) {
          var inputMs;
          units = normalizeUnits(units || "millisecond");
          if (units === "millisecond") {
            input = moment.isMoment(input) ? input : moment(input);
            return +this === +input;
          } else {
            inputMs = +moment(input);
            return +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units);
          }
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function(other) {
          other = moment.apply(null, arguments);
          return other < this ? this : other;
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function(other) {
          other = moment.apply(null, arguments);
          return other > this ? this : other;
        }),
        zone: function(input, keepLocalTime) {
          var offset = this._offset || 0, localAdjust;
          if (input != null) {
            if (typeof input === "string") {
              input = timezoneMinutesFromString(input);
            }
            if (Math.abs(input) < 16) {
              input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
              localAdjust = this._dateTzOffset();
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
              this.subtract(localAdjust, "m");
            }
            if (offset !== input) {
              if (!keepLocalTime || this._changeInProgress) {
                addOrSubtractDurationFromMoment(this, moment.duration(offset - input, "m"), 1, false);
              } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                moment.updateOffset(this, true);
                this._changeInProgress = null;
              }
            }
          } else {
            return this._isUTC ? offset : this._dateTzOffset();
          }
          return this;
        },
        zoneAbbr: function() {
          return this._isUTC ? "UTC" : "";
        },
        zoneName: function() {
          return this._isUTC ? "Coordinated Universal Time" : "";
        },
        parseZone: function() {
          if (this._tzm) {
            this.zone(this._tzm);
          } else if (typeof this._i === "string") {
            this.zone(this._i);
          }
          return this;
        },
        hasAlignedHourOffset: function(input) {
          if (!input) {
            input = 0;
          } else {
            input = moment(input).zone();
          }
          return (this.zone() - input) % 60 === 0;
        },
        daysInMonth: function() {
          return daysInMonth(this.year(), this.month());
        },
        dayOfYear: function(input) {
          var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
          return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
        },
        quarter: function(input) {
          return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },
        weekYear: function(input) {
          var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
          return input == null ? year : this.add(input - year, "y");
        },
        isoWeekYear: function(input) {
          var year = weekOfYear(this, 1, 4).year;
          return input == null ? year : this.add(input - year, "y");
        },
        week: function(input) {
          var week = this.localeData().week(this);
          return input == null ? week : this.add((input - week) * 7, "d");
        },
        isoWeek: function(input) {
          var week = weekOfYear(this, 1, 4).week;
          return input == null ? week : this.add((input - week) * 7, "d");
        },
        weekday: function(input) {
          var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
          return input == null ? weekday : this.add(input - weekday, "d");
        },
        isoWeekday: function(input) {
          return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },
        isoWeeksInYear: function() {
          return weeksInYear(this.year(), 1, 4);
        },
        weeksInYear: function() {
          var weekInfo = this.localeData()._week;
          return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },
        get: function(units) {
          units = normalizeUnits(units);
          return this[units]();
        },
        set: function(units, value) {
          units = normalizeUnits(units);
          if (typeof this[units] === "function") {
            this[units](value);
          }
          return this;
        },
        locale: function(key) {
          var newLocaleData;
          if (key === undefined) {
            return this._locale._abbr;
          } else {
            newLocaleData = moment.localeData(key);
            if (newLocaleData != null) {
              this._locale = newLocaleData;
            }
            return this;
          }
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
          if (key === undefined) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }),
        localeData: function() {
          return this._locale;
        },
        _dateTzOffset: function() {
          return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
      });
      function rawMonthSetter(mom, value) {
        var dayOfMonth;
        if (typeof value === "string") {
          value = mom.localeData().monthsParse(value);
          if (typeof value !== "number") {
            return mom;
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]();
      }
      function rawSetter(mom, unit, value) {
        if (unit === "Month") {
          return rawMonthSetter(mom, value);
        } else {
          return mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
        }
      }
      function makeAccessor(unit, keepTime) {
        return function(value) {
          if (value != null) {
            rawSetter(this, unit, value);
            moment.updateOffset(this, keepTime);
            return this;
          } else {
            return rawGetter(this, unit);
          }
        };
      }
      moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", false);
      moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", false);
      moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", false);
      moment.fn.hour = moment.fn.hours = makeAccessor("Hours", true);
      moment.fn.date = makeAccessor("Date", true);
      moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", true));
      moment.fn.year = makeAccessor("FullYear", true);
      moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", true));
      moment.fn.days = moment.fn.day;
      moment.fn.months = moment.fn.month;
      moment.fn.weeks = moment.fn.week;
      moment.fn.isoWeeks = moment.fn.isoWeek;
      moment.fn.quarters = moment.fn.quarter;
      moment.fn.toJSON = moment.fn.toISOString;
      function daysToYears(days) {
        return days * 400 / 146097;
      }
      function yearsToDays(years) {
        return years * 146097 / 400;
      }
      extend(moment.duration.fn = Duration.prototype, {
        _bubble: function() {
          var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years = 0;
          data.milliseconds = milliseconds % 1e3;
          seconds = absRound(milliseconds / 1e3);
          data.seconds = seconds % 60;
          minutes = absRound(seconds / 60);
          data.minutes = minutes % 60;
          hours = absRound(minutes / 60);
          data.hours = hours % 24;
          days += absRound(hours / 24);
          years = absRound(daysToYears(days));
          days -= absRound(yearsToDays(years));
          months += absRound(days / 30);
          days %= 30;
          years += absRound(months / 12);
          months %= 12;
          data.days = days;
          data.months = months;
          data.years = years;
        },
        abs: function() {
          this._milliseconds = Math.abs(this._milliseconds);
          this._days = Math.abs(this._days);
          this._months = Math.abs(this._months);
          this._data.milliseconds = Math.abs(this._data.milliseconds);
          this._data.seconds = Math.abs(this._data.seconds);
          this._data.minutes = Math.abs(this._data.minutes);
          this._data.hours = Math.abs(this._data.hours);
          this._data.months = Math.abs(this._data.months);
          this._data.years = Math.abs(this._data.years);
          return this;
        },
        weeks: function() {
          return absRound(this.days() / 7);
        },
        valueOf: function() {
          return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
        },
        humanize: function(withSuffix) {
          var output = relativeTime(this, !withSuffix, this.localeData());
          if (withSuffix) {
            output = this.localeData().pastFuture(+this, output);
          }
          return this.localeData().postformat(output);
        },
        add: function(input, val) {
          var dur = moment.duration(input, val);
          this._milliseconds += dur._milliseconds;
          this._days += dur._days;
          this._months += dur._months;
          this._bubble();
          return this;
        },
        subtract: function(input, val) {
          var dur = moment.duration(input, val);
          this._milliseconds -= dur._milliseconds;
          this._days -= dur._days;
          this._months -= dur._months;
          this._bubble();
          return this;
        },
        get: function(units) {
          units = normalizeUnits(units);
          return this[units.toLowerCase() + "s"]();
        },
        as: function(units) {
          var days, months;
          units = normalizeUnits(units);
          if (units === "month" || units === "year") {
            days = this._days + this._milliseconds / 864e5;
            months = this._months + daysToYears(days) * 12;
            return units === "month" ? months : months / 12;
          } else {
            days = this._days + Math.round(yearsToDays(this._months / 12));
            switch (units) {
              case "week":
                return days / 7 + this._milliseconds / 6048e5;
              case "day":
                return days + this._milliseconds / 864e5;
              case "hour":
                return days * 24 + this._milliseconds / 36e5;
              case "minute":
                return days * 24 * 60 + this._milliseconds / 6e4;
              case "second":
                return days * 24 * 60 * 60 + this._milliseconds / 1e3;
              case "millisecond":
                return Math.floor(days * 24 * 60 * 60 * 1e3) + this._milliseconds;
              default:
                throw new Error("Unknown unit " + units);
            }
          }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead " + "(notice the capitals)", function() {
          return this.toISOString();
        }),
        toISOString: function() {
          var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
          if (!this.asSeconds()) {
            return "P0D";
          }
          return (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "");
        },
        localeData: function() {
          return this._locale;
        }
      });
      moment.duration.fn.toString = moment.duration.fn.toISOString;
      function makeDurationGetter(name) {
        moment.duration.fn[name] = function() {
          return this._data[name];
        };
      }
      for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
          makeDurationGetter(i.toLowerCase());
        }
      }
      moment.duration.fn.asMilliseconds = function() {
        return this.as("ms");
      };
      moment.duration.fn.asSeconds = function() {
        return this.as("s");
      };
      moment.duration.fn.asMinutes = function() {
        return this.as("m");
      };
      moment.duration.fn.asHours = function() {
        return this.as("h");
      };
      moment.duration.fn.asDays = function() {
        return this.as("d");
      };
      moment.duration.fn.asWeeks = function() {
        return this.as("weeks");
      };
      moment.duration.fn.asMonths = function() {
        return this.as("M");
      };
      moment.duration.fn.asYears = function() {
        return this.as("y");
      };
      moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      function makeGlobal(shouldDeprecate) {
        if (typeof ender !== "undefined") {
          return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
          globalScope.moment = deprecate("Accessing Moment through the global scope is " + "deprecated, and will be removed in an upcoming " + "release.", moment);
        } else {
          globalScope.moment = moment;
        }
      }
      if (hasModule) {
        module.exports = moment;
      } else if (typeof define === "function" && define.amd) {
        define("moment", function(require, exports, module) {
          if (module.config && module.config() && module.config().noGlobal === true) {
            globalScope.moment = oldGlobalMoment;
          }
          return moment;
        });
        makeGlobal(true);
      } else {
        makeGlobal();
      }
    }).call(this);
  },
  "w.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    basis.require("./i.js");
    var router = basis.require("./d.js");
    var moment = basis.require("./v.js");
    var Teams = basis.require("./x.js");
    var Calendar = basis.require("./y.js");
    module.exports = basis.ui.Node.subclass({
      container: basis.dom.get("toolbox"),
      template: basis.template.get("#5"),
      satellite: {
        calendar: {
          delegate: function(owner) {
            return owner.delegate;
          },
          instanceOf: Calendar
        },
        teamsList: {
          instanceOf: Teams,
          delegate: function(owner) {
            return owner.delegate;
          }
        }
      },
      binding: {
        calendar: "satellite:calendar",
        button: new basis.ui.button.Button({
          caption: "Public holidays",
          click: function() {
            this.owner.action.navigateToPublicHolidays(this.owner.data);
          }
        }),
        teamsList: "satellite:teamsList"
      },
      action: {
        navigateToTeam: function(data) {
          router.navigate("team/" + data.team + "/" + data.month + "/" + data.year);
        },
        navigateToPublicHolidays: function(data) {
          router.navigate("public-holidays/" + data.month + "/" + data.year);
        }
      },
      emit_teamChange: basis.event.create("teamChange", "team"),
      emit_monthChange: basis.event.create("monthChange", "date"),
      handler: {
        teamChange: function(sender, team) {
          this.data.team = team;
          this.action.navigateToTeam(this.data);
        },
        monthChange: function(sender, date) {
          var momentDate = moment(date);
          this.data.month = momentDate.format("MMMM");
          this.data.year = momentDate.format("YYYY");
          if (location.hash.match(/public-holidays/)) {
            this.action.navigateToPublicHolidays(this.data);
          } else {
            this.action.navigateToTeam(this.data);
          }
        }
      }
    });
  },
  "i.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    var namespace = this.path;
    var Node = basis.ui.Node;
    var templates = basis.template.define(namespace, {
      Button: basis.resource("./a.tmpl"),
      ButtonPanel: basis.resource("./b.tmpl"),
      ButtonGroup: basis.resource("./c.tmpl")
    });
    var Button = Node.subclass({
      className: namespace + ".Button",
      template: templates.Button,
      binding: {
        caption: "caption"
      },
      action: {
        click: function() {
          if (!this.isDisabled()) this.click();
        }
      },
      caption: "[no caption]",
      setCaption: function(newCaption) {
        this.caption = newCaption;
        this.updateBind("caption");
      },
      click: function() {}
    });
    var ButtonPanel = Node.subclass({
      className: namespace + ".ButtonPanel",
      template: templates.ButtonPanel,
      childClass: Button,
      groupingClass: {
        className: namespace + ".ButtonGroupingNode",
        rule: function(button) {
          return button.groupId || button.basisObjectId;
        },
        childClass: {
          className: namespace + ".ButtonGroup",
          template: templates.ButtonGroup
        }
      },
      grouping: {}
    });
    module.exports = {
      Button: Button,
      ButtonPanel: ButtonPanel
    };
  },
  "3.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    var namespace = this.path;
    var Class = basis.Class;
    var extend = basis.object.extend;
    var slice = Array.prototype.slice;
    var NULL_HANDLER = {};
    var events = {};
    var warnOnDestroy = function() {
      basis.dev.warn("Object had been destroyed before. Destroy method must not be called more than once.");
    };
    function createDispatcher(eventName) {
      var eventFunction = events[eventName];
      if (!eventFunction) {
        eventFunction = function() {
          var cursor = this;
          var args;
          var fn;
          while (cursor = cursor.handler) {
            fn = cursor.callbacks[eventName];
            if (typeof fn == "function") {
              if (!args) {
                args = [ this ];
                for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
              }
              fn.apply(cursor.context || this, args);
            }
            fn = cursor.callbacks["*"];
            if (typeof fn == "function") {
              if (!args) {
                args = [ this ];
                for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
              }
              fn.call(cursor.context || this, {
                sender: this,
                type: eventName,
                args: args
              });
            }
          }
          if (this.debug_emit) {
            args = [];
            for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
            this.debug_emit({
              sender: this,
              type: eventName,
              args: args
            });
          }
        };
        eventFunction = (new Function("slice", 'return {"' + namespace + ".events." + eventName + '":\n\n      ' + "function(" + slice.call(arguments, 1).join(", ") + "){" + eventFunction.toString().replace(/\beventName\b/g, '"' + eventName + '"').replace(/^function[^(]*\(\)[^{]*\{|\}$/g, "") + "}" + '\n\n}["' + namespace + ".events." + eventName + '"];'))(slice);
        events[eventName] = eventFunction;
      }
      return eventFunction;
    }
    function createHandler(events, eventCallback) {
      var handler = {
        events: []
      };
      if (events) {
        events = String(events).trim().split(/\s+|\s*,\s*/).sort();
        handler = {
          events: events
        };
        for (var i = 0, eventName; eventName = events[i]; i++) if (eventName != "destroy") handler[eventName] = eventCallback;
      }
      return handler;
    }
    var Emitter = Class(null, {
      className: namespace + ".Emitter",
      extendConstructor_: true,
      handler: null,
      emit_destroy: createDispatcher("destroy"),
      listen: Class.nestedExtendProperty(),
      debug_handlers: function() {
        var result = [];
        var cursor = this;
        while (cursor = cursor.handler) result.push([ cursor.callbacks, cursor.context ]);
        return result;
      },
      debug_emit: null,
      init: function() {
        if (this.handler && !this.handler.callbacks) this.handler = {
          callbacks: this.handler,
          context: this,
          handler: null
        };
      },
      addHandler: function(callbacks, context) {
        if (!callbacks) basis.dev.warn(namespace + ".Emitter#addHandler: callbacks is not an object (", callbacks, ")");
        context = context || this;
        var cursor = this;
        while (cursor = cursor.handler) {
          if (cursor.callbacks === callbacks && cursor.context === context) {
            basis.dev.warn(namespace + ".Emitter#addHandler: add duplicate event callbacks", callbacks, "to Emitter instance:", this);
            break;
          }
        }
        this.handler = {
          callbacks: callbacks,
          context: context,
          handler: this.handler
        };
      },
      removeHandler: function(callbacks, context) {
        var cursor = this;
        var prev;
        context = context || this;
        while (prev = cursor, cursor = cursor.handler) if (cursor.callbacks === callbacks && cursor.context === context) {
          cursor.callbacks = NULL_HANDLER;
          prev.handler = cursor.handler;
          return;
        }
        basis.dev.warn(namespace + ".Emitter#removeHandler: no handler removed");
      },
      destroy: function() {
        this.destroy = warnOnDestroy;
        this.emit_destroy();
        this.handler = null;
      }
    });
    module.exports = {
      create: createDispatcher,
      createHandler: createHandler,
      events: events,
      Emitter: Emitter
    };
  },
  "4.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    var namespace = this.path;
    var Class = basis.Class;
    var sliceArray = Array.prototype.slice;
    var values = basis.object.values;
    var $self = basis.fn.$self;
    var Emitter = basis.event.Emitter;
    var createEvent = basis.event.create;
    var events = basis.event.events;
    var NULL_OBJECT = {};
    var EMPTY_ARRAY = [];
    var STATE_EXISTS = {};
    var STATE = {
      priority: [],
      values: {},
      add: function(state, order) {
        var name = state;
        var value = state.toLowerCase();
        STATE[name] = value;
        STATE_EXISTS[value] = name;
        this.values[value] = name;
        if (order) order = this.priority.indexOf(order); else order = -1;
        if (order == -1) this.priority.push(value); else this.priority.splice(order, 0, value);
      },
      getList: function() {
        return values(STATE_EXISTS);
      }
    };
    STATE.add("READY");
    STATE.add("DEPRECATED");
    STATE.add("UNDEFINED");
    STATE.add("ERROR");
    STATE.add("PROCESSING");
    var subscriptionConfig = {};
    var subscriptionSeed = 1;
    var SUBSCRIPTION = {
      NONE: 0,
      ALL: 0,
      link: function(type, from, to) {
        var subscriberId = type + from.basisObjectId;
        var subscribers = to.subscribers_;
        if (!subscribers) subscribers = to.subscribers_ = {};
        if (!subscribers[subscriberId]) {
          subscribers[subscriberId] = from;
          var count = to.subscriberCount += 1;
          if (count == 1) to.emit_subscribersChanged(+1);
        } else {
          basis.dev.warn("Attempt to add duplicate subscription");
        }
      },
      unlink: function(type, from, to) {
        var subscriberId = type + from.basisObjectId;
        var subscribers = to.subscribers_;
        if (subscribers && subscribers[subscriberId]) {
          delete subscribers[subscriberId];
          var count = to.subscriberCount -= 1;
          if (count == 0) {
            to.emit_subscribersChanged(-1);
            to.subscribers_ = null;
          }
        } else {
          basis.dev.warn("Trying remove non-exists subscription");
        }
      },
      add: function(name, handler, action) {
        subscriptionConfig[subscriptionSeed] = {
          handler: handler,
          action: action
        };
        SUBSCRIPTION[name] = subscriptionSeed;
        SUBSCRIPTION.ALL |= subscriptionSeed;
        subscriptionSeed <<= 1;
      },
      addProperty: function(propertyName, eventName) {
        var handler = {};
        handler[eventName || propertyName + "Changed"] = function(object, oldValue) {
          if (oldValue instanceof AbstractData) SUBSCRIPTION.unlink(propertyName, object, oldValue);
          if (object[propertyName] instanceof AbstractData) SUBSCRIPTION.link(propertyName, object, object[propertyName]);
        };
        this.add(propertyName.toUpperCase(), handler, function(fn, object) {
          if (object[propertyName]) fn(propertyName, object, object[propertyName]);
        });
      }
    };
    var maskConfig = {};
    function mixFunctions(fnA, fnB) {
      return function() {
        fnA.apply(this, arguments);
        fnB.apply(this, arguments);
      };
    }
    function getMaskConfig(mask) {
      var config = maskConfig[mask];
      if (!config) {
        var actions = [];
        var handler = {};
        var idx = 1;
        config = maskConfig[mask] = {
          actions: actions,
          handler: handler
        };
        while (mask) {
          if (mask & 1) {
            var cfg = subscriptionConfig[idx];
            actions.push(cfg.action);
            for (var key in cfg.handler) handler[key] = handler[key] ? mixFunctions(handler[key], cfg.handler[key]) : cfg.handler[key];
          }
          idx <<= 1;
          mask >>= 1;
        }
      }
      return config;
    }
    function addSub(object, mask) {
      var config = getMaskConfig(mask);
      for (var i = 0, action; action = config.actions[i]; i++) action(SUBSCRIPTION.link, object);
      object.addHandler(config.handler);
    }
    function remSub(object, mask) {
      var config = getMaskConfig(mask);
      for (var i = 0, action; action = config.actions[i++]; ) action(SUBSCRIPTION.unlink, object);
      object.removeHandler(config.handler);
    }
    SUBSCRIPTION.addProperty("delegate");
    SUBSCRIPTION.addProperty("target");
    SUBSCRIPTION.addProperty("dataset");
    SUBSCRIPTION.addProperty("value", "change");
    var AbstractData = Class(Emitter, {
      className: namespace + ".AbstractData",
      state: STATE.UNDEFINED,
      emit_stateChanged: createEvent("stateChanged", "oldState"),
      active: false,
      emit_activeChanged: createEvent("activeChanged"),
      subscribeTo: SUBSCRIPTION.NONE,
      subscriberCount: 0,
      subscribers_: null,
      emit_subscribersChanged: createEvent("subscribersChanged", "delta"),
      syncEvents: Class.oneFunctionProperty(function() {
        if (this.isSyncRequired()) this.syncAction();
      }, {
        stateChanged: true,
        subscribersChanged: true
      }),
      syncAction: null,
      init: function() {
        Emitter.prototype.init.call(this);
        if (this.active) this.addHandler(getMaskConfig(this.subscribeTo).handler);
        var syncAction = this.syncAction;
        if (syncAction) {
          this.syncAction = null;
          this.setSyncAction(syncAction);
        }
      },
      setState: function(state, data) {
        var stateCode = String(state);
        if (!STATE_EXISTS[stateCode]) throw new Error("Wrong state value");
        if (this.state != stateCode || this.state.data != data) {
          var oldState = this.state;
          this.state = Object(stateCode);
          this.state.data = data;
          this.emit_stateChanged(oldState);
          return true;
        }
        return false;
      },
      deprecate: function() {
        if (this.state != STATE.PROCESSING) this.setState(STATE.DEPRECATED);
      },
      setActive: function(isActive) {
        isActive = !!isActive;
        if (this.active != isActive) {
          this.active = isActive;
          this.emit_activeChanged();
          if (isActive) addSub(this, this.subscribeTo); else remSub(this, this.subscribeTo);
          return true;
        }
        return false;
      },
      setSubscription: function(subscriptionType) {
        var curSubscriptionType = this.subscribeTo;
        var newSubscriptionType = subscriptionType & SUBSCRIPTION.ALL;
        var delta = curSubscriptionType ^ newSubscriptionType;
        if (delta) {
          this.subscribeTo = newSubscriptionType;
          if (this.active) {
            var curConfig = getMaskConfig(curSubscriptionType);
            var newConfig = getMaskConfig(newSubscriptionType);
            this.removeHandler(curConfig.handler);
            this.addHandler(newConfig.handler);
            var idx = 1;
            while (delta) {
              if (delta & 1) {
                var cfg = subscriptionConfig[idx];
                if (curSubscriptionType & idx) cfg.action(SUBSCRIPTION.unlink, this); else cfg.action(SUBSCRIPTION.link, this);
              }
              idx <<= 1;
              delta >>= 1;
            }
          }
          return true;
        }
        return false;
      },
      isSyncRequired: function() {
        return this.subscriberCount > 0 && (this.state == STATE.UNDEFINED || this.state == STATE.DEPRECATED);
      },
      setSyncAction: function(syncAction) {
        var oldAction = this.syncAction;
        if (typeof syncAction != "function") syncAction = null;
        this.syncAction = syncAction;
        if (syncAction) {
          if (!oldAction) this.addHandler(this.syncEvents);
          if (this.isSyncRequired()) this.syncAction();
        } else {
          if (oldAction) this.removeHandler(this.syncEvents);
        }
      },
      destroy: function() {
        Emitter.prototype.destroy.call(this);
        if (this.active) {
          var config = getMaskConfig(this.subscribeTo);
          for (var i = 0, action; action = config.actions[i]; i++) action(SUBSCRIPTION.unlink, this);
        }
        this.state = STATE.UNDEFINED;
      }
    });
    var GETTER_ID = basis.getter.ID;
    var VALUE_EMMITER_HANDLER = {
      destroy: function(object) {
        this.value.unlink(object, this.fn);
      }
    };
    var VALUE_EMMITER_DESTROY_HANDLER = {
      destroy: function(object) {
        this.set(null);
      }
    };
    var computeFunctions = {};
    var valueSetters = {};
    var valueSyncToken = function(value) {
      this.set(this.fn(value));
    };
    var Value = Class(AbstractData, {
      className: namespace + ".Value",
      subscribeTo: SUBSCRIPTION.VALUE,
      emit_change: createEvent("change", "oldValue") && function(oldValue) {
        events.change.call(this, oldValue);
        var cursor = this;
        while (cursor = cursor.links_) cursor.fn.call(cursor.context, this.value, oldValue);
      },
      value: null,
      initValue: null,
      proxy: null,
      locked: 0,
      lockedValue_: null,
      links_: null,
      setNullOnEmitterDestroy: true,
      bindingBridge: {
        attach: function(host, callback, context) {
          host.link(context, callback, true);
        },
        detach: function(host, callback, context) {
          host.unlink(context, callback);
        },
        get: function(host) {
          return host.value;
        }
      },
      init: function() {
        AbstractData.prototype.init.call(this);
        if (this.proxy) this.value = this.proxy(this.value);
        if (this.setNullOnEmitterDestroy && this.value instanceof Emitter) this.value.addHandler(VALUE_EMMITER_DESTROY_HANDLER, this);
        this.initValue = this.value;
      },
      set: function(value) {
        var oldValue = this.value;
        var newValue = this.proxy ? this.proxy(value) : value;
        var changed = newValue !== oldValue;
        if (changed) {
          if (this.setNullOnEmitterDestroy) {
            if (oldValue instanceof Emitter) oldValue.removeHandler(VALUE_EMMITER_DESTROY_HANDLER, this);
            if (newValue instanceof Emitter) newValue.addHandler(VALUE_EMMITER_DESTROY_HANDLER, this);
          }
          this.value = newValue;
          if (!this.locked) this.emit_change(oldValue);
        }
        return changed;
      },
      reset: function() {
        this.set(this.initValue);
      },
      isLocked: function() {
        return this.locked > 0;
      },
      lock: function() {
        this.locked++;
        if (this.locked == 1) this.lockedValue_ = this.value;
      },
      unlock: function() {
        if (this.locked) {
          this.locked--;
          if (!this.locked) {
            var lockedValue = this.lockedValue_;
            this.lockedValue_ = null;
            if (this.value !== lockedValue) this.emit_change(lockedValue);
          }
        }
      },
      compute: function(events, fn) {
        if (!fn) {
          fn = events;
          events = null;
        }
        if (!fn) fn = $self;
        var hostValue = this;
        var handler = basis.event.createHandler(events, function(object) {
          this.set(fn(object, hostValue.value));
        });
        var fnId = fn[GETTER_ID] || String(fn);
        var getComputeTokenId = handler.events.concat(fnId, this.basisObjectId).join("_");
        var getComputeToken = computeFunctions[getComputeTokenId];
        if (!getComputeToken) {
          var tokenMap = {};
          handler.destroy = function(object) {
            delete tokenMap[object.basisObjectId];
            this.destroy();
          };
          this.addHandler({
            change: function() {
              for (var key in tokenMap) {
                var pair = tokenMap[key];
                pair.token.set(fn(pair.object, this.value));
              }
            },
            destroy: function() {
              for (var key in tokenMap) {
                var pair = tokenMap[key];
                pair.object.removeHandler(handler, pair.token);
                pair.token.destroy();
              }
              tokenMap = null;
              hostValue = null;
            }
          });
          getComputeToken = computeFunctions[getComputeTokenId] = function(object) {
            if (object instanceof basis.event.Emitter == false) basis.dev.warn("basis.data.Value#compute: object should be an instanceof basis.event.Emitter");
            var objectId = object.basisObjectId;
            var pair = tokenMap[objectId];
            var value = fn(object, hostValue.value);
            if (!pair) {
              var token = new basis.Token(value);
              object.addHandler(handler, token);
              pair = tokenMap[objectId] = {
                token: token,
                object: object
              };
            } else {
              pair.token.set(value);
            }
            return pair.token;
          };
          getComputeToken.deferred = function() {
            return function(object) {
              return getComputeToken(object).deferred();
            };
          };
        }
        return getComputeToken;
      },
      as: function(fn, deferred) {
        if (!fn) fn = $self;
        if (this.links_) {
          var cursor = this;
          var fnId = fn[GETTER_ID] || String(fn);
          while (cursor = cursor.links_) {
            var context = cursor.context;
            if (context instanceof basis.Token && (context.fn[GETTER_ID] || String(context.fn)) == fnId) return deferred ? context.deferred() : context;
          }
        }
        var token = new basis.Token;
        token.fn = fn;
        this.link(token, valueSyncToken);
        return deferred ? token.deferred() : token;
      },
      deferred: function(fn) {
        return this.as(fn, true);
      },
      link: function(context, fn, noApply) {
        if (typeof fn != "function") {
          var property = String(fn);
          fn = valueSetters[property];
          if (!fn) fn = valueSetters[property] = function(value) {
            this[property] = value;
          };
        }
        var cursor = this;
        while (cursor = cursor.links_) if (cursor.context === context && cursor.fn === fn) {
          basis.dev.warn(this.constructor.className + "#attach: Duplicate link pair context-fn");
          break;
        }
        this.links_ = {
          value: this,
          context: context,
          fn: fn,
          links_: this.links_
        };
        if (context instanceof Emitter) context.addHandler(VALUE_EMMITER_HANDLER, this.links_);
        if (!noApply) fn.call(context, this.value);
        return context;
      },
      unlink: function(context, fn) {
        var cursor = this;
        var prev;
        while (prev = cursor, cursor = cursor.links_) if (cursor.context === context && (!fn || cursor.fn === fn)) {
          cursor.fn = basis.fn.$undef;
          prev.links_ = cursor.links_;
          if (cursor.context instanceof Emitter) cursor.context.removeHandler(VALUE_EMMITER_HANDLER, cursor);
        }
      },
      destroy: function() {
        AbstractData.prototype.destroy.call(this);
        if (this.setNullOnEmitterDestroy && this.value instanceof Emitter) this.value.removeHandler(VALUE_EMMITER_DESTROY_HANDLER, this);
        var cursor = this;
        while (cursor = cursor.links_) if (cursor.context instanceof Emitter) cursor.context.removeHandler(VALUE_EMMITER_HANDLER, cursor);
        this.proxy = null;
        this.initValue = null;
        this.value = null;
        this.lockedValue_ = null;
        this.links_ = null;
      }
    });
    var valueFromMap = {};
    var valueFromSetProxy = function(object) {
      Value.prototype.set.call(this, object);
    };
    Value.from = function(obj, events, getter) {
      var result;
      if (!obj) return null;
      if (obj instanceof Emitter) {
        if (!getter) {
          getter = events;
          events = null;
        }
        if (!getter) getter = $self;
        var handler = basis.event.createHandler(events, valueFromSetProxy);
        var getterId = getter[GETTER_ID] || String(getter);
        var id = handler.events.concat(getterId, obj.basisObjectId).join("_");
        result = valueFromMap[id];
        if (!result) {
          result = valueFromMap[id] = new Value({
            value: obj,
            proxy: basis.getter(getter),
            set: basis.fn.$undef,
            handler: {
              destroy: function() {
                valueFromMap[id] = null;
                obj.removeHandler(handler, this);
              }
            }
          });
          handler.destroy = function(sender) {
            valueFromMap[id] = null;
            this.destroy();
          };
          obj.addHandler(handler, result);
        }
      }
      if (!result) {
        var id = obj.basisObjectId;
        var bindingBridge = obj.bindingBridge;
        if (id && bindingBridge) {
          result = valueFromMap[id];
          if (!result) {
            result = valueFromMap[id] = new Value({
              value: bindingBridge.get(obj)
            });
            bindingBridge.attach(obj, result.set, result);
          }
        }
      }
      if (!result) throw "Bad object type";
      return result;
    };
    Value.factory = function(events, getter) {
      return function(object) {
        return Value.from(object, events, getter);
      };
    };
    var INIT_DATA = {};
    function isConnected(a, b) {
      while (b && b !== a && b !== b.delegate) b = b.delegate;
      return b === a;
    }
    function applyDelegateChanges(object, oldRoot, oldTarget) {
      var delegate = object.delegate;
      if (delegate) {
        object.root = delegate.root;
        object.target = delegate.target;
        object.data = delegate.data;
        object.state = delegate.state;
      }
      if (object.root !== oldRoot) {
        var rootListenHandler = object.listen.root;
        if (rootListenHandler) {
          if (oldRoot && oldRoot !== object) oldRoot.removeHandler(rootListenHandler, object);
          if (object.root && object.root !== object) object.root.addHandler(rootListenHandler, object);
        }
        object.emit_rootChanged(oldRoot);
      }
      if (object.target !== oldTarget) {
        var targetListenHandler = object.listen.target;
        if (targetListenHandler) {
          if (oldTarget && oldTarget !== object) oldTarget.removeHandler(targetListenHandler, object);
          if (object.target && object.target !== object) object.target.addHandler(targetListenHandler, object);
        }
        object.emit_targetChanged(oldTarget);
      }
      var cursor = object.delegates_;
      while (cursor) {
        if (cursor.delegate) applyDelegateChanges(cursor.delegate, oldRoot, oldTarget);
        cursor = cursor.next;
      }
    }
    var DataObject = Class(AbstractData, {
      className: namespace + ".Object",
      subscribeTo: SUBSCRIPTION.DELEGATE + SUBSCRIPTION.TARGET,
      data: null,
      emit_update: createEvent("update", "delta") && function(delta) {
        var cursor = this.delegates_;
        events.update.call(this, delta);
        while (cursor) {
          if (cursor.delegate) cursor.delegate.emit_update(delta);
          cursor = cursor.next;
        }
      },
      emit_stateChanged: function(oldState) {
        var cursor = this.delegates_;
        AbstractData.prototype.emit_stateChanged.call(this, oldState);
        while (cursor) {
          if (cursor.delegate) {
            cursor.delegate.state = this.state;
            cursor.delegate.emit_stateChanged(oldState);
          }
          cursor = cursor.next;
        }
      },
      delegate: null,
      delegateAdapter_: null,
      delegates_: null,
      debug_delegates: function() {
        var cursor = this.delegates_;
        var result = [];
        while (cursor) {
          result.push(cursor.delegate);
          cursor = cursor.next;
        }
        return result;
      },
      emit_delegateChanged: createEvent("delegateChanged", "oldDelegate"),
      target: null,
      emit_targetChanged: createEvent("targetChanged", "oldTarget"),
      root: null,
      emit_rootChanged: createEvent("rootChanged", "oldRoot"),
      init: function() {
        this.root = this;
        AbstractData.prototype.init.call(this);
        var delegate = this.delegate;
        var data = this.data;
        if (delegate) {
          this.delegate = null;
          this.target = null;
          this.data = INIT_DATA;
          this.setDelegate(delegate);
          if (this.data === INIT_DATA) this.data = data || {};
        } else {
          if (!data) this.data = {};
          if (this.target !== null) this.target = this;
        }
      },
      setSyncAction: function(syncAction) {
        if (syncAction && this.delegate) basis.dev.warn(this.constructor.syncAction + " instance has a delegate and syncAction - it may produce conflics with data & state");
        AbstractData.prototype.setSyncAction.call(this, syncAction);
      },
      setDelegate: function(newDelegate) {
        newDelegate = resolveObject(this, this.setDelegate, newDelegate, "delegateAdapter_");
        if (newDelegate && newDelegate instanceof DataObject) {
          if (newDelegate.delegate && isConnected(this, newDelegate)) {
            basis.dev.warn("New delegate has already connected to object. Delegate assignment has been ignored.", this, newDelegate);
            return false;
          }
        } else {
          newDelegate = null;
        }
        if (this.delegate !== newDelegate) {
          var oldState = this.state;
          var oldData = this.data;
          var oldDelegate = this.delegate;
          var oldTarget = this.target;
          var oldRoot = this.root;
          var delegateListenHandler = this.listen.delegate;
          var dataChanged = false;
          var delta;
          if (oldDelegate) {
            if (delegateListenHandler) oldDelegate.removeHandler(delegateListenHandler, this);
            var cursor = oldDelegate.delegates_;
            var prev = oldDelegate;
            while (cursor) {
              if (cursor.delegate === this) {
                cursor.delegate = null;
                if (prev === oldDelegate) oldDelegate.delegates_ = cursor.next; else prev.next = cursor.next;
                break;
              }
              prev = cursor;
              cursor = cursor.next;
            }
          }
          if (newDelegate) {
            this.delegate = newDelegate;
            if (delegateListenHandler) newDelegate.addHandler(delegateListenHandler, this);
            newDelegate.delegates_ = {
              delegate: this,
              next: newDelegate.delegates_
            };
            if (this.data !== INIT_DATA) {
              delta = {};
              for (var key in newDelegate.data) if (key in oldData === false) {
                dataChanged = true;
                delta[key] = undefined;
              }
              for (var key in oldData) if (oldData[key] !== newDelegate.data[key]) {
                dataChanged = true;
                delta[key] = oldData[key];
              }
            }
          } else {
            this.delegate = null;
            this.target = null;
            this.root = this;
            this.data = {};
            for (var key in oldData) this.data[key] = oldData[key];
          }
          applyDelegateChanges(this, oldRoot, oldTarget);
          if (dataChanged) this.emit_update(delta);
          if (delta && oldState !== this.state && (String(oldState) != this.state || oldState.data !== this.state.data)) this.emit_stateChanged(oldState);
          this.emit_delegateChanged(oldDelegate);
          return true;
        }
        return false;
      },
      setState: function(state, data) {
        if (this.delegate) return this.root.setState(state, data); else return AbstractData.prototype.setState.call(this, state, data);
      },
      update: function(data) {
        if (this.delegate) return this.root.update(data);
        if (data) {
          var delta = {};
          var changed = false;
          for (var prop in data) if (this.data[prop] !== data[prop]) {
            changed = true;
            delta[prop] = this.data[prop];
            this.data[prop] = data[prop];
          }
          if (changed) {
            this.emit_update(delta);
            return delta;
          }
        }
        return false;
      },
      destroy: function() {
        AbstractData.prototype.destroy.call(this);
        var cursor = this.delegates_;
        this.delegates_ = null;
        while (cursor) {
          cursor.delegate.setDelegate();
          cursor = cursor.next;
        }
        if (this.delegate) this.setDelegate();
        this.data = NULL_OBJECT;
        this.root = null;
        this.target = null;
      }
    });
    var Slot = Class(DataObject, {
      className: namespace + ".Slot"
    });
    var KEYOBJECTMAP_MEMBER_HANDLER = {
      destroy: function() {
        delete this.map[this.id];
      }
    };
    var KeyObjectMap = Class(AbstractData, {
      className: namespace + ".KeyObjectMap",
      itemClass: DataObject,
      keyGetter: $self,
      autoDestroyMembers: true,
      map_: null,
      extendConstructor_: true,
      init: function() {
        this.map_ = {};
        AbstractData.prototype.init.call(this);
      },
      resolve: function(object) {
        return this.get(this.keyGetter(object), object);
      },
      create: function(key, object) {
        var itemConfig;
        if (key instanceof DataObject) itemConfig = {
          delegate: key
        }; else itemConfig = {
          data: {
            id: key,
            title: key
          }
        };
        return new this.itemClass(itemConfig);
      },
      get: function(key, autocreate) {
        var itemId = key instanceof DataObject ? key.basisObjectId : key;
        var itemInfo = this.map_[itemId];
        if (!itemInfo && autocreate) {
          itemInfo = this.map_[itemId] = {
            map: this.map_,
            id: itemId,
            item: this.create(key, autocreate)
          };
          itemInfo.item.addHandler(KEYOBJECTMAP_MEMBER_HANDLER, itemInfo);
        }
        if (itemInfo) return itemInfo.item;
      },
      destroy: function() {
        AbstractData.prototype.destroy.call(this);
        var map = this.map_;
        this.map_ = null;
        for (var itemId in map) {
          var itemInfo = map[itemId];
          if (this.autoDestroyMembers) itemInfo.item.destroy(); else itemInfo.item.removeHandler(KEYOBJECTMAP_MEMBER_HANDLER, itemInfo);
        }
      }
    });
    function getDelta(inserted, deleted) {
      var delta = {};
      var result;
      if (inserted && inserted.length) result = delta.inserted = inserted;
      if (deleted && deleted.length) result = delta.deleted = deleted;
      if (result) return delta;
    }
    function getDatasetDelta(a, b) {
      if (!a || !a.itemCount) {
        if (b && b.itemCount) return {
          inserted: b.getItems()
        };
      } else {
        if (!b || !b.itemCount) {
          if (a.itemCount) return {
            deleted: a.getItems()
          };
        } else {
          var inserted = [];
          var deleted = [];
          for (var key in a.items_) {
            var item = a.items_[key];
            if (item.basisObjectId in b.items_ == false) deleted.push(item);
          }
          for (var key in b.items_) {
            var item = b.items_[key];
            if (item.basisObjectId in a.items_ == false) inserted.push(item);
          }
          return getDelta(inserted, deleted);
        }
      }
    }
    var DatasetWrapper = Class(DataObject, {
      className: namespace + ".DatasetWrapper",
      subscribeTo: DataObject.prototype.subscribeTo + SUBSCRIPTION.DATASET,
      listen: {
        dataset: {
          itemsChanged: function(dataset, delta) {
            this.itemCount = dataset.itemCount;
            this.emit_itemsChanged(delta);
          },
          destroy: function() {
            this.setDataset();
          }
        }
      },
      dataset: null,
      datasetAdapter_: null,
      emit_datasetChanged: createEvent("datasetChanged", "oldDataset"),
      emit_itemsChanged: createEvent("itemsChanged", "delta"),
      init: function() {
        DataObject.prototype.init.call(this);
        var dataset = this.dataset;
        if (dataset) {
          this.dataset = null;
          this.setDataset(dataset);
        }
      },
      setDataset: function(dataset) {
        dataset = resolveDataset(this, this.setDataset, dataset, "datasetAdapter_");
        if (this.dataset !== dataset) {
          var listenHandler = this.listen.dataset;
          var oldDataset = this.dataset;
          var delta;
          if (listenHandler) {
            if (oldDataset) oldDataset.removeHandler(listenHandler, this);
            if (dataset) dataset.addHandler(listenHandler, this);
          }
          this.itemCount = dataset ? dataset.itemCount : 0;
          if (delta = getDatasetDelta(oldDataset, dataset)) this.emit_itemsChanged(delta);
          this.dataset = dataset;
          this.emit_datasetChanged(oldDataset);
        }
      },
      has: function(object) {
        return this.dataset ? this.dataset.has(object) : null;
      },
      getItems: function() {
        return this.dataset ? this.dataset.getItems() : [];
      },
      pick: function() {
        return this.dataset ? this.dataset.pick() : null;
      },
      top: function(count) {
        return this.dataset ? this.dataset.top(count) : [];
      },
      forEach: function(fn) {
        if (this.dataset) return this.dataset.forEach(fn);
      },
      destroy: function() {
        if (this.dataset || this.datasetAdapter_) this.setDataset();
        DataObject.prototype.destroy.call(this);
      }
    });
    var ReadOnlyDataset = Class(AbstractData, {
      className: namespace + ".ReadOnlyDataset",
      itemCount: 0,
      items_: null,
      members_: null,
      cache_: null,
      emit_itemsChanged: createEvent("itemsChanged", "delta") && function(delta) {
        var items;
        var insertCount = 0;
        var deleteCount = 0;
        var object;
        if (items = delta.inserted) {
          while (object = items[insertCount]) {
            this.items_[object.basisObjectId] = object;
            insertCount++;
          }
        }
        if (items = delta.deleted) {
          while (object = items[deleteCount]) {
            delete this.items_[object.basisObjectId];
            deleteCount++;
          }
        }
        this.itemCount += insertCount - deleteCount;
        this.cache_ = insertCount == this.itemCount ? delta.inserted : null;
        events.itemsChanged.call(this, delta);
      },
      init: function() {
        AbstractData.prototype.init.call(this);
        this.members_ = {};
        this.items_ = {};
      },
      has: function(object) {
        return !!(object && this.items_[object.basisObjectId]);
      },
      getItems: function() {
        if (!this.cache_) this.cache_ = values(this.items_);
        return this.cache_;
      },
      getValues: function(getter) {
        return this.getItems().map(basis.getter(getter || $self));
      },
      pick: function() {
        for (var objectId in this.items_) return this.items_[objectId];
        return null;
      },
      top: function(count) {
        var result = [];
        if (count) for (var objectId in this.items_) if (result.push(this.items_[objectId]) >= count) break;
        return result;
      },
      forEach: function(fn) {
        var items = this.getItems();
        for (var i = 0; i < items.length; i++) fn(items[i]);
      },
      destroy: function() {
        AbstractData.prototype.destroy.call(this);
        this.cache_ = EMPTY_ARRAY;
        this.itemCount = 0;
        this.members_ = null;
        this.items_ = null;
      }
    });
    var Dataset = Class(ReadOnlyDataset, {
      className: namespace + ".Dataset",
      listen: {
        item: {
          destroy: function(object) {
            this.remove([ object ]);
          }
        }
      },
      init: function() {
        ReadOnlyDataset.prototype.init.call(this);
        var items = this.items;
        if (items) {
          this.items = null;
          this.set(items);
        }
      },
      add: function(items) {
        var memberMap = this.members_;
        var listenHandler = this.listen.item;
        var inserted = [];
        var delta;
        if (items && !Array.isArray(items)) items = [ items ];
        for (var i = 0; i < items.length; i++) {
          var object = items[i];
          if (object instanceof DataObject) {
            var objectId = object.basisObjectId;
            if (!memberMap[objectId]) {
              memberMap[objectId] = object;
              if (listenHandler) object.addHandler(listenHandler, this);
              inserted.push(object);
            }
          } else {
            basis.dev.warn("Wrong data type: value should be an instance of basis.data.Object");
          }
        }
        if (inserted.length) {
          this.emit_itemsChanged(delta = {
            inserted: inserted
          });
        }
        return delta;
      },
      remove: function(items) {
        var memberMap = this.members_;
        var listenHandler = this.listen.item;
        var deleted = [];
        var delta;
        if (items && !Array.isArray(items)) items = [ items ];
        for (var i = 0; i < items.length; i++) {
          var object = items[i];
          if (object instanceof DataObject) {
            var objectId = object.basisObjectId;
            if (memberMap[objectId]) {
              if (listenHandler) object.removeHandler(listenHandler, this);
              delete memberMap[objectId];
              deleted.push(object);
            }
          } else {
            basis.dev.warn("Wrong data type: value should be an instance of basis.data.Object");
          }
        }
        if (deleted.length) {
          this.emit_itemsChanged(delta = {
            deleted: deleted
          });
        }
        return delta;
      },
      set: function(items) {
        if (!this.itemCount) return this.add(items);
        if (!items || !items.length) return this.clear();
        var memberMap = this.members_;
        var listenHandler = this.listen.item;
        var exists = {};
        var deleted = [];
        var inserted = [];
        var object;
        var objectId;
        var delta;
        for (var i = 0; i < items.length; i++) {
          object = items[i];
          if (object instanceof DataObject) {
            objectId = object.basisObjectId;
            exists[objectId] = object;
            if (!memberMap[objectId]) {
              memberMap[objectId] = object;
              if (listenHandler) object.addHandler(listenHandler, this);
              inserted.push(object);
            }
          } else {
            basis.dev.warn("Wrong data type: value should be an instance of basis.data.Object");
          }
        }
        for (var objectId in memberMap) {
          if (!exists[objectId]) {
            object = memberMap[objectId];
            if (listenHandler) object.removeHandler(listenHandler, this);
            delete memberMap[objectId];
            deleted.push(object);
          }
        }
        if (delta = getDelta(inserted, deleted)) this.emit_itemsChanged(delta);
        return delta;
      },
      sync: function(items) {
        var delta = this.set(items) || {};
        var deleted = delta.deleted;
        Dataset.setAccumulateState(true);
        if (deleted) for (var i = 0, object; object = deleted[i]; i++) object.destroy();
        Dataset.setAccumulateState(false);
        return delta.inserted;
      },
      clear: function() {
        var deleted = this.getItems();
        var listenHandler = this.listen.item;
        var delta;
        if (deleted.length) {
          if (listenHandler) for (var i = 0; i < deleted.length; i++) deleted[i].removeHandler(listenHandler, this);
          this.emit_itemsChanged(delta = {
            deleted: deleted
          });
          this.members_ = {};
        }
        return delta;
      },
      destroy: function() {
        this.clear();
        ReadOnlyDataset.prototype.destroy.call(this);
      }
    });
    var ResolveAdapter = function(context, fn, source, handler) {
      this.context = context;
      this.fn = fn;
      this.source = source;
      this.handler = handler;
    };
    ResolveAdapter.prototype = {
      context: null,
      fn: null,
      source: null,
      handler: null,
      next: null,
      attach: function() {
        this.source.addHandler(this.handler, this);
      },
      detach: function() {
        this.source.removeHandler(this.handler, this);
      },
      proxy: function() {
        this.fn.call(this.context, this.source);
      }
    };
    var BBResolveAdapter = function() {
      ResolveAdapter.apply(this, arguments);
    };
    BBResolveAdapter.prototype = new ResolveAdapter;
    BBResolveAdapter.prototype.attach = function() {
      this.source.bindingBridge.attach(this.source, this.handler, this);
    };
    BBResolveAdapter.prototype.detach = function() {
      this.source.bindingBridge.detach(this.source, this.handler, this);
    };
    var TOKEN_ADAPTER_HANDLER = function() {
      this.fn.call(this.context, this.source);
    };
    var DATASETWRAPPER_ADAPTER_HANDLER = {
      datasetChanged: function() {
        this.fn.call(this.context, this.source);
      },
      destroy: function() {
        this.fn.call(this.context, null);
      }
    };
    var VALUE_ADAPTER_HANDLER = {
      change: function() {
        this.fn.call(this.context, this.source);
      },
      destroy: function() {
        this.fn.call(this.context, null);
      }
    };
    function resolveDataset(context, fn, source, property) {
      var oldAdapter = context[property] || null;
      var newAdapter = null;
      if (typeof source == "function") source = source.call(context, context);
      if (source) {
        if (source instanceof DatasetWrapper) {
          newAdapter = new ResolveAdapter(context, fn, source, DATASETWRAPPER_ADAPTER_HANDLER);
          source = source.dataset;
        } else if (source instanceof Value) {
          newAdapter = new ResolveAdapter(context, fn, source, VALUE_ADAPTER_HANDLER);
          source = resolveDataset(newAdapter, newAdapter.proxy, source.value, "next");
        } else if (source.bindingBridge) {
          newAdapter = new BBResolveAdapter(context, fn, source, TOKEN_ADAPTER_HANDLER);
          source = resolveDataset(newAdapter, newAdapter.proxy, source.value, "next");
        }
      }
      if (source instanceof ReadOnlyDataset == false) source = null;
      if (property && oldAdapter !== newAdapter) {
        if (oldAdapter) {
          oldAdapter.detach();
          if (oldAdapter.next) resolveDataset(oldAdapter, null, null, "next");
        }
        if (newAdapter) newAdapter.attach();
        context[property] = newAdapter;
      }
      return source;
    }
    function resolveObject(context, fn, source, property) {
      var oldAdapter = context[property] || null;
      var newAdapter = null;
      if (typeof source == "function") source = source.call(context, context);
      if (source) {
        if (source instanceof Value) {
          newAdapter = new ResolveAdapter(context, fn, source, VALUE_ADAPTER_HANDLER);
          source = resolveObject(newAdapter, newAdapter.proxy, source.value, "next");
        } else if (source.bindingBridge) {
          newAdapter = new BBResolveAdapter(context, fn, source, TOKEN_ADAPTER_HANDLER);
          source = resolveObject(newAdapter, newAdapter.proxy, source.value, "next");
        }
      }
      if (source instanceof DataObject == false) source = null;
      if (property && oldAdapter !== newAdapter) {
        if (oldAdapter) {
          oldAdapter.detach();
          if (oldAdapter.next) resolveObject(oldAdapter, null, null, "next");
        }
        if (newAdapter) newAdapter.attach();
        context[property] = newAdapter;
      }
      return source;
    }
    Dataset.setAccumulateState = function() {
      var proto = ReadOnlyDataset.prototype;
      var eventCache = {};
      var setStateCount = 0;
      var urgentTimer;
      var realEvent;
      function flushCache(cache) {
        var dataset = cache.dataset;
        realEvent.call(dataset, cache);
      }
      function flushAllDataset() {
        var eventCacheCopy = eventCache;
        eventCache = {};
        for (var datasetId in eventCacheCopy) {
          var entry = eventCacheCopy[datasetId];
          if (entry) flushCache(entry);
        }
      }
      function storeDatasetDelta(delta) {
        var dataset = this;
        var datasetId = dataset.basisObjectId;
        var inserted = delta.inserted;
        var deleted = delta.deleted;
        var cache = eventCache[datasetId];
        if (inserted && deleted || cache && cache.mixed) {
          if (cache) {
            eventCache[datasetId] = null;
            flushCache(cache);
          }
          realEvent.call(dataset, delta);
          return;
        }
        if (cache) {
          var mode = inserted ? "inserted" : "deleted";
          var array = cache[mode];
          if (!array) {
            var inCacheMode = inserted ? "deleted" : "inserted";
            var inCache = cache[inCacheMode];
            var inCacheMap = {};
            var deltaItems = inserted || deleted;
            var newInCacheItems = [];
            var inCacheRemoves = 0;
            for (var i = 0; i < inCache.length; i++) inCacheMap[inCache[i].basisObjectId] = i;
            for (var i = 0; i < deltaItems.length; i++) {
              var id = deltaItems[i].basisObjectId;
              if (id in inCacheMap == false) {
                newInCacheItems.push(deltaItems[i]);
              } else {
                if (!inCacheRemoves) inCache = sliceArray.call(inCache);
                inCacheRemoves++;
                inCache[inCacheMap[id]] = null;
              }
            }
            if (inCacheRemoves) {
              if (inCacheRemoves < inCache.length) {
                inCache = inCache.filter(Boolean);
              } else {
                inCache = null;
              }
              cache[inCacheMode] = inCache;
            }
            if (!newInCacheItems.length) {
              newInCacheItems = null;
              if (!inCache) eventCache[datasetId] = null;
            } else {
              cache[mode] = newInCacheItems;
              if (inCache) cache.mixed = true;
            }
          } else array.push.apply(array, inserted || deleted);
          return;
        }
        eventCache[datasetId] = {
          inserted: inserted,
          deleted: deleted,
          dataset: dataset,
          mixed: false
        };
      }
      function urgentFlush() {
        urgentTimer = null;
        if (setStateCount) {
          basis.dev.warn("(debug) Urgent flush dataset changes");
          setStateCount = 0;
          setAccumulateStateOff();
        }
      }
      function setAccumulateStateOff() {
        proto.emit_itemsChanged = realEvent;
        flushAllDataset();
      }
      return function(state) {
        if (state) {
          if (setStateCount == 0) {
            realEvent = proto.emit_itemsChanged;
            proto.emit_itemsChanged = storeDatasetDelta;
            if (!urgentTimer) urgentTimer = basis.setImmediate(urgentFlush);
          }
          setStateCount++;
        } else {
          setStateCount -= setStateCount > 0;
          if (setStateCount == 0) setAccumulateStateOff();
        }
      };
    }();
    function wrapData(data) {
      if (Array.isArray(data)) return data.map(function(item) {
        return {
          data: item
        };
      }); else return {
        data: data
      };
    }
    function wrapObject(data) {
      if (!data || data.constructor !== Object) data = {
        value: data
      };
      return new DataObject({
        data: data
      });
    }
    function wrap(value, retObject) {
      var wrapper = retObject ? wrapObject : wrapData;
      return Array.isArray(value) ? value.map(wrapper) : wrapper(value);
    }
    module.exports = {
      STATE: STATE,
      SUBSCRIPTION: SUBSCRIPTION,
      AbstractData: AbstractData,
      Value: Value,
      Object: DataObject,
      Slot: Slot,
      KeyObjectMap: KeyObjectMap,
      ReadOnlyDataset: ReadOnlyDataset,
      Dataset: Dataset,
      DatasetWrapper: DatasetWrapper,
      isConnected: isConnected,
      getDatasetDelta: getDatasetDelta,
      ResolveAdapter: ResolveAdapter,
      resolveDataset: resolveDataset,
      resolveObject: resolveObject,
      wrapData: wrapData,
      wrapObject: wrapObject,
      wrap: wrap
    };
  },
  "5.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./4.js");
    var namespace = this.path;
    var Class = basis.Class;
    var complete = basis.object.complete;
    var arrayFrom = basis.array;
    var arrayRemove = basis.array.remove;
    var $undef = basis.fn.$undef;
    var getter = basis.getter;
    var nullGetter = basis.fn.nullGetter;
    var oneFunctionProperty = Class.oneFunctionProperty;
    var createEvent = basis.event.create;
    var events = basis.event.events;
    var SUBSCRIPTION = basis.data.SUBSCRIPTION;
    var STATE = basis.data.STATE;
    var AbstractData = basis.data.AbstractData;
    var DataObject = basis.data.Object;
    var ReadOnlyDataset = basis.data.ReadOnlyDataset;
    var Dataset = basis.data.Dataset;
    var DatasetWrapper = basis.data.DatasetWrapper;
    var EXCEPTION_CANT_INSERT = namespace + ": Node can't be inserted at specified point in hierarchy";
    var EXCEPTION_NODE_NOT_FOUND = namespace + ": Node was not found";
    var EXCEPTION_BAD_CHILD_CLASS = namespace + ": Child node has wrong class";
    var EXCEPTION_NULL_CHILD = namespace + ": Child node is null";
    var EXCEPTION_DATASOURCE_CONFLICT = namespace + ": Operation is not allowed because node is under dataSource control";
    var EXCEPTION_DATASOURCEADAPTER_CONFLICT = namespace + ": Operation is not allowed because node is under dataSource adapter control";
    var EXCEPTION_PARENTNODE_OWNER_CONFLICT = namespace + ": Node can't has owner and parentNode";
    var EXCEPTION_NO_CHILDCLASS = namespace + ": Node can't has children and dataSource as childClass isn't specified";
    var DELEGATE = {
      ANY: true,
      NONE: false,
      PARENT: "parent",
      OWNER: "owner"
    };
    var childNodesDatasetMap = {};
    function warnOnDataSourceItemNodeDestoy() {
      basis.dev.warn(namespace + ": node can't be destroyed as representing dataSource item, destroy delegate item or remove it from dataSource first");
    }
    function warnOnAutoSatelliteOwnerChange() {
      basis.dev.warn(namespace + ": satellite can't change owner as it auto-satellite");
    }
    function warnOnAutoSatelliteDestoy() {
      basis.dev.warn(namespace + ": satellite can't be destroyed as it auto-create satellite, and could be destroyed on owner destroy");
    }
    function lockDataSourceItemNode(node) {
      node.setDelegate = basis.fn.$undef;
      node.destroy = warnOnDataSourceItemNodeDestoy;
    }
    function unlockDataSourceItemNode(node) {
      var proto = node.constructor.prototype;
      node.setDelegate = proto.setDelegate;
      node.destroy = proto.destroy;
    }
    function sortingSearch(node) {
      return node.sortingValue || 0;
    }
    function sortAsc(a, b) {
      a = a.sortingValue || 0;
      b = b.sortingValue || 0;
      return +(a > b) || -(a < b);
    }
    function sortDesc(a, b) {
      a = a.sortingValue || 0;
      b = b.sortingValue || 0;
      return -(a > b) || +(a < b);
    }
    function sortChildNodes(obj) {
      return obj.childNodes.sort(obj.sortingDesc ? sortDesc : sortAsc);
    }
    function binarySearchPos(array, value, getter_, desc) {
      if (!array.length) return 0;
      desc = !!desc;
      var pos;
      var compareValue;
      var l = 0;
      var r = array.length - 1;
      do {
        pos = l + r >> 1;
        compareValue = getter_(array[pos]);
        if (desc ? value > compareValue : value < compareValue) r = pos - 1; else if (desc ? value < compareValue : value > compareValue) l = pos + 1; else return value == compareValue ? pos : 0;
      } while (l <= r);
      return pos + (compareValue < value ^ desc);
    }
    function updateNodeContextSelection(root, oldSelection, newSelection, rootUpdate, ignoreRootSelection) {
      if (oldSelection === newSelection) return;
      var nextNode;
      var cursor = root;
      var selected = [];
      if (rootUpdate) {
        root.contextSelection = newSelection;
        if (root.selected) selected.push(root);
      }
      while (cursor) {
        nextNode = !cursor.selection || ignoreRootSelection && cursor === root ? cursor.firstChild : null;
        if (nextNode && nextNode.contextSelection !== oldSelection) throw "Try change wrong context selection";
        while (!nextNode) {
          if (cursor === root) {
            if (selected.length) {
              if (oldSelection) oldSelection.remove(selected);
              if (newSelection) newSelection.add(selected);
            }
            return;
          }
          nextNode = cursor.nextSibling;
          if (!nextNode) cursor = cursor.parentNode;
        }
        cursor = nextNode;
        if (cursor.selected) selected.push(cursor);
        cursor.contextSelection = newSelection;
      }
    }
    function updateNodeDisableContext(node, disabled) {
      if (node.contextDisabled != disabled) {
        node.contextDisabled = disabled;
        if (node.disabled) return;
        if (disabled) node.emit_disable(); else node.emit_enable();
      }
    }
    SUBSCRIPTION.addProperty("owner");
    SUBSCRIPTION.addProperty("dataSource");
    function processSatelliteConfig(value) {
      if (!value) return null;
      if (value.isSatelliteConfig) return value;
      if (value instanceof AbstractNode) return value;
      if (Class.isClass(value)) value = {
        instanceOf: value
      };
      if (value && value.constructor === Object) {
        var handlerRequired = false;
        var config = {
          isSatelliteConfig: true
        };
        var instanceClass;
        for (var key in value) switch (key) {
          case "instance":
            if (value[key] instanceof AbstractNode) config[key] = value[key]; else {
              basis.dev.warn(namespace + ": `instance` value in satellite config must be an instance of basis.dom.wrapper.AbstractNode");
            }
            break;
          case "instanceOf":
            if (Class.isClass(value[key]) && value[key].isSubclassOf(AbstractNode)) instanceClass = value[key]; else {
              basis.dev.warn(namespace + ": `instanceOf` value in satellite config must be a subclass of basis.dom.wrapper.AbstractNode");
            }
            break;
          case "existsIf":
          case "delegate":
          case "dataSource":
            handlerRequired = true;
            config[key] = getter(value[key]);
            break;
          case "config":
            config[key] = value[key];
            break;
        }
        if (!config.instance) config.instanceOf = instanceClass || AbstractNode; else {
          if (instanceClass) basis.dev.warn(namespace + ": `instanceOf` can't be set with `instance` value in satellite config, value ignored");
        }
        if (handlerRequired) {
          var events = "events" in value ? value.events : "update";
          if (Array.isArray(events)) events = events.join(" ");
          if (typeof events == "string") {
            var handler = {};
            events = events.split(/\s+/);
            for (var i = 0, eventName; eventName = events[i]; i++) {
              handler[eventName] = SATELLITE_UPDATE;
              config.handler = handler;
            }
          }
        }
        return config;
      }
      return null;
    }
    function applySatellites(node, satellites) {
      for (var name in satellites) if (satellites[name] && typeof satellites[name] == "object") node.setSatellite(name, satellites[name]);
    }
    var NULL_SATELLITE = Class.customExtendProperty({}, function(result, extend) {
      for (var name in extend) result[name] = processSatelliteConfig(extend[name]);
    });
    var SATELLITE_UPDATE = function(owner) {
      var name = this.name;
      var config = this.config;
      var exists = !config.existsIf || config.existsIf(owner);
      var satellite = owner.satellite[name];
      if (exists) {
        if (satellite) {
          if (config.delegate) satellite.setDelegate(config.delegate(owner));
          if (config.dataSource) satellite.setDataSource(config.dataSource(owner));
        } else {
          satellite = config.instance;
          if (!satellite) {
            var listenHandler;
            var satelliteConfig = (typeof config.config == "function" ? config.config(owner) : config.config) || {};
            satelliteConfig.owner = owner;
            if (config.delegate) {
              satelliteConfig.autoDelegate = false;
              satelliteConfig.delegate = config.delegate(owner);
            }
            if (config.dataSource) satelliteConfig.dataSource = config.dataSource(owner);
            satellite = new config.instanceOf(satelliteConfig);
            satellite.destroy = warnOnAutoSatelliteDestoy;
            if (listenHandler = owner.listen.satellite) satellite.addHandler(listenHandler, owner);
            if (listenHandler = owner.listen["satellite:" + name]) satellite.addHandler(listenHandler, owner);
          } else {
            if (config.delegate) satellite.setDelegate(config.delegate(owner));
            if (config.dataSource) satellite.setDataSource(config.dataSource(owner));
          }
          owner.satellite.__auto__[name].instance = satellite;
          owner.setSatellite(name, satellite, true);
        }
      } else {
        if (satellite) {
          if (config.instance) {
            if (config.delegate) satellite.setDelegate();
            if (config.dataSource) satellite.setDataSource();
          }
          owner.satellite.__auto__[name].instance = null;
          owner.setSatellite(name, null, true);
        }
      }
    };
    var AUTO_SATELLITE_INSTANCE_HANDLER = {
      destroy: function() {
        this.owner.setSatellite(this.name, null);
      }
    };
    var AbstractNode = Class(DataObject, {
      className: namespace + ".AbstractNode",
      subscribeTo: DataObject.prototype.subscribeTo + SUBSCRIPTION.DATASOURCE,
      isSyncRequired: function() {
        return this.state == STATE.UNDEFINED || this.state == STATE.DEPRECATED;
      },
      syncEvents: {
        activeChanged: false
      },
      emit_update: function(delta) {
        DataObject.prototype.emit_update.call(this, delta);
        var parentNode = this.parentNode;
        if (parentNode) {
          if (parentNode.matchFunction) this.match(parentNode.matchFunction);
          parentNode.insertBefore(this, this.nextSibling);
        }
      },
      listen: {
        owner: {
          destroy: function() {
            if (!this.ownerSatelliteName) this.setOwner();
          }
        }
      },
      autoDelegate: DELEGATE.NONE,
      name: null,
      childNodes: null,
      emit_childNodesModified: createEvent("childNodesModified", "delta") && function(delta) {
        events.childNodesModified.call(this, delta);
        var listen = this.listen.childNode;
        var array;
        if (listen) {
          if (array = delta.inserted) for (var i = 0, child; child = array[i]; i++) child.addHandler(listen, this);
          if (array = delta.deleted) for (var i = 0, child; child = array[i]; i++) child.removeHandler(listen, this);
        }
      },
      childNodesState: STATE.UNDEFINED,
      emit_childNodesStateChanged: createEvent("childNodesStateChanged", "oldState"),
      childClass: AbstractNode,
      dataSource: null,
      emit_dataSourceChanged: createEvent("dataSourceChanged", "oldDataSource"),
      dataSourceAdapter_: null,
      dataSourceMap_: null,
      destroyDataSourceMember: true,
      parentNode: null,
      nextSibling: null,
      previousSibling: null,
      firstChild: null,
      lastChild: null,
      sorting: nullGetter,
      sortingDesc: false,
      emit_sortingChanged: createEvent("sortingChanged", "oldSorting", "oldSortingDesc"),
      groupingClass: null,
      grouping: null,
      emit_groupingChanged: createEvent("groupingChanged", "oldGrouping"),
      groupNode: null,
      groupId: NaN,
      satellite: NULL_SATELLITE,
      ownerSatelliteName: null,
      emit_satelliteChanged: createEvent("satelliteChanged", "name", "oldSatellite"),
      owner: null,
      emit_ownerChanged: createEvent("ownerChanged", "oldOwner"),
      init: function() {
        DataObject.prototype.init.call(this);
        var childNodes = this.childNodes;
        var dataSource = this.dataSource;
        if (childNodes) this.childNodes = null;
        if (dataSource) this.dataSource = null;
        var grouping = this.grouping;
        if (grouping) {
          this.grouping = null;
          this.setGrouping(grouping);
        }
        if (this.childClass) {
          this.childNodes = [];
          if (dataSource) {
            this.setDataSource(dataSource);
          } else {
            if (childNodes) this.setChildNodes(childNodes);
          }
        }
        var satellites = this.satellite;
        if (satellites !== NULL_SATELLITE) {
          this.satellite = NULL_SATELLITE;
          applySatellites(this, satellites);
        }
        var owner = this.owner;
        if (owner) {
          this.owner = null;
          this.setOwner(owner);
        }
      },
      setChildNodesState: function(state, data) {
        var stateCode = String(state);
        var oldState = this.childNodesState;
        if (!STATE.values[stateCode]) throw new Error("Wrong state value");
        if (oldState != stateCode || oldState.data != data) {
          this.childNodesState = Object(stateCode);
          this.childNodesState.data = data;
          this.emit_childNodesStateChanged(oldState);
        }
      },
      appendChild: function(newChild) {},
      insertBefore: function(newChild, refChild) {},
      removeChild: function(oldChild) {},
      replaceChild: function(newChild, oldChild) {},
      clear: function(alive) {},
      setChildNodes: function(nodes) {},
      setGrouping: function(grouping, alive) {},
      setSorting: function(sorting, desc) {},
      setDataSource: function(dataSource) {},
      setOwner: function(owner) {
        if (!owner || owner instanceof AbstractNode == false) owner = null;
        if (owner && this.parentNode) throw EXCEPTION_PARENTNODE_OWNER_CONFLICT;
        var oldOwner = this.owner;
        if (oldOwner !== owner) {
          var listenHandler = this.listen.owner;
          if (oldOwner) {
            if (this.ownerSatelliteName && oldOwner.satellite.__auto__ && this.ownerSatelliteName in oldOwner.satellite.__auto__) {
              basis.dev.warn(namespace + ": auto-satellite can't change it's owner");
              return;
            }
            if (listenHandler) oldOwner.removeHandler(listenHandler, this);
            if (this.ownerSatelliteName) {
              this.owner = null;
              oldOwner.setSatellite(this.ownerSatelliteName, null);
            }
          }
          if (owner && listenHandler) owner.addHandler(listenHandler, this);
          this.owner = owner;
          this.emit_ownerChanged(oldOwner);
          if (this.autoDelegate == DELEGATE.OWNER || this.autoDelegate === DELEGATE.ANY) this.setDelegate(owner);
        }
      },
      setSatellite: function(name, satellite, autoSet) {
        var oldSatellite = this.satellite[name] || null;
        var auto = this.satellite.__auto__;
        var autoConfig = auto && auto[name];
        var preserveAuto = autoSet && autoConfig;
        if (preserveAuto) {
          satellite = autoConfig.instance;
          if (autoConfig.config.instance) {
            if (satellite) delete autoConfig.config.instance.setOwner;
          }
        } else {
          satellite = processSatelliteConfig(satellite);
          if (satellite && satellite.owner && auto && satellite.ownerSatelliteName && auto[satellite.ownerSatelliteName]) {
            basis.dev.warn(namespace + ": auto-create satellite can't change name inside owner");
            return;
          }
          if (autoConfig) {
            delete auto[name];
            if (autoConfig.config.instance) autoConfig.config.instance.removeHandler(AUTO_SATELLITE_INSTANCE_HANDLER, autoConfig);
            if (autoConfig.config.handler) this.removeHandler(autoConfig.config.handler, autoConfig);
          }
        }
        if (oldSatellite !== satellite) {
          var satelliteListen = this.listen.satellite;
          var satellitePersonalListen = this.listen["satellite:" + name];
          var destroySatellite;
          if (oldSatellite) {
            delete this.satellite[name];
            oldSatellite.ownerSatelliteName = null;
            if (autoConfig && oldSatellite.destroy === warnOnAutoSatelliteDestoy) {
              destroySatellite = oldSatellite;
            } else {
              if (satelliteListen) oldSatellite.removeHandler(satelliteListen, this);
              if (satellitePersonalListen) oldSatellite.removeHandler(satellitePersonalListen, this);
              oldSatellite.setOwner(null);
            }
            if (preserveAuto && !satellite && autoConfig.config.instance) autoConfig.config.instance.setOwner = warnOnAutoSatelliteOwnerChange;
          }
          if (satellite) {
            if (satellite instanceof AbstractNode == false) {
              var autoConfig = {
                owner: this,
                name: name,
                config: satellite,
                instance: null
              };
              if (satellite.handler) this.addHandler(satellite.handler, autoConfig);
              if (satellite.instance) {
                satellite.instance.addHandler(AUTO_SATELLITE_INSTANCE_HANDLER, autoConfig);
                satellite.instance.setOwner = warnOnAutoSatelliteOwnerChange;
              }
              if (!auto) {
                if (this.satellite === NULL_SATELLITE) this.satellite = {};
                auto = this.satellite.__auto__ = {};
              }
              auto[name] = autoConfig;
              SATELLITE_UPDATE.call(autoConfig, this);
              if (!autoConfig.instance && oldSatellite) this.emit_satelliteChanged(name, oldSatellite);
              if (destroySatellite) {
                delete destroySatellite.destroy;
                destroySatellite.destroy();
              }
              return;
            }
            if (satellite.owner !== this) {
              if (autoConfig && autoConfig.config.delegate) {
                var autoDelegate = satellite.autoDelegate;
                satellite.autoDelegate = false;
                satellite.setOwner(this);
                satellite.autoDelegate = autoDelegate;
              } else satellite.setOwner(this);
              if (satellite.owner !== this) return;
              if (satelliteListen) satellite.addHandler(satelliteListen, this);
              if (satellitePersonalListen) satellite.addHandler(satellitePersonalListen, this);
            } else {
              if (satellite.ownerSatelliteName) {
                delete this.satellite[satellite.ownerSatelliteName];
                this.emit_satelliteChanged(satellite.ownerSatelliteName, satellite);
              }
            }
            if (this.satellite == NULL_SATELLITE) this.satellite = {};
            this.satellite[name] = satellite;
            satellite.ownerSatelliteName = name;
          }
          this.emit_satelliteChanged(name, oldSatellite);
          if (destroySatellite) {
            delete destroySatellite.destroy;
            destroySatellite.destroy();
          }
        }
      },
      getChildNodesDataset: function() {
        return childNodesDatasetMap[this.basisObjectId] || new ChildNodesDataset({
          sourceNode: this
        });
      },
      destroy: function() {
        DataObject.prototype.destroy.call(this);
        if (this.dataSource || this.dataSourceAdapter_) {
          this.setDataSource();
        } else {
          if (this.firstChild) this.clear();
        }
        if (this.parentNode) this.parentNode.removeChild(this);
        if (this.grouping) {
          this.grouping.setOwner();
          this.grouping = null;
        }
        if (this.owner) this.setOwner();
        var satellites = this.satellite;
        if (satellites !== NULL_SATELLITE) {
          var auto = satellites.__auto__;
          delete satellites.__auto__;
          for (var name in auto) if (auto[name].config.instance && !auto[name].instance) auto[name].config.instance.destroy();
          for (var name in satellites) {
            var satellite = satellites[name];
            satellite.owner = null;
            satellite.ownerSatelliteName = null;
            if (satellite.destroy === warnOnAutoSatelliteDestoy) delete satellite.destroy;
            satellite.destroy();
          }
          this.satellite = null;
        }
        this.childNodes = null;
        this.parentNode = null;
        this.previousSibling = null;
        this.nextSibling = null;
        this.firstChild = null;
        this.lastChild = null;
      }
    });
    var PartitionNode = Class(AbstractNode, {
      className: namespace + ".PartitionNode",
      autoDestroyIfEmpty: false,
      nodes: null,
      first: null,
      last: null,
      init: function() {
        this.nodes = [];
        AbstractNode.prototype.init.call(this);
      },
      insert: function(newNode, refNode) {
        var nodes = this.nodes;
        var pos = refNode ? nodes.indexOf(refNode) : -1;
        if (pos == -1) {
          nodes.push(newNode);
          this.last = newNode;
        } else nodes.splice(pos, 0, newNode);
        this.first = nodes[0];
        newNode.groupNode = this;
        this.emit_childNodesModified({
          inserted: [ newNode ]
        });
      },
      remove: function(oldNode) {
        var nodes = this.nodes;
        if (arrayRemove(nodes, oldNode)) {
          this.first = nodes[0] || null;
          this.last = nodes[nodes.length - 1] || null;
          oldNode.groupNode = null;
          this.emit_childNodesModified({
            deleted: [ oldNode ]
          });
        }
        if (!this.first && this.autoDestroyIfEmpty) this.destroy();
      },
      clear: function() {
        if (!this.first) return;
        var nodes = this.nodes;
        for (var i = nodes.length; i-- > 0; ) nodes[i].groupNode = null;
        this.nodes = [];
        this.first = null;
        this.last = null;
        this.emit_childNodesModified({
          deleted: nodes
        });
        if (this.autoDestroyIfEmpty) this.destroy();
      },
      destroy: function() {
        AbstractNode.prototype.destroy.call(this);
        this.nodes = null;
        this.first = null;
        this.last = null;
      }
    });
    var DOMMIXIN_DATASOURCE_HANDLER = {
      itemsChanged: function(dataSource, delta) {
        var newDelta = {};
        var deleted = [];
        if (delta.deleted) {
          newDelta.deleted = deleted;
          if (this.childNodes.length == delta.deleted.length) {
            deleted = arrayFrom(this.childNodes);
            for (var i = 0, child; child = deleted[i]; i++) unlockDataSourceItemNode(child);
            var tmp = this.dataSource;
            this.dataSource = null;
            this.clear(true);
            this.dataSource = tmp;
            this.dataSourceMap_ = {};
          } else {
            for (var i = 0, item; item = delta.deleted[i]; i++) {
              var delegateId = item.basisObjectId;
              var oldChild = this.dataSourceMap_[delegateId];
              unlockDataSourceItemNode(oldChild);
              delete this.dataSourceMap_[delegateId];
              this.removeChild(oldChild);
              deleted.push(oldChild);
            }
          }
        }
        if (delta.inserted) {
          newDelta.inserted = [];
          for (var i = 0, item; item = delta.inserted[i]; i++) {
            var newChild = createChildByFactory(this, {
              delegate: item
            });
            lockDataSourceItemNode(newChild);
            this.dataSourceMap_[item.basisObjectId] = newChild;
            newDelta.inserted.push(newChild);
            if (this.firstChild) this.insertBefore(newChild);
          }
        }
        if (!this.firstChild) this.setChildNodes(newDelta.inserted); else this.emit_childNodesModified(newDelta);
        if (this.destroyDataSourceMember && deleted.length) for (var i = 0, item; item = deleted[i]; i++) item.destroy();
      },
      stateChanged: function(dataSource) {
        this.setChildNodesState(dataSource.state, dataSource.state.data);
      },
      destroy: function(dataSource) {
        if (!this.dataSourceAdapter_) this.setDataSource();
      }
    };
    var MIXIN_DATASOURCE_WRAPPER_HANDLER = {
      datasetChanged: function(wrapper) {
        this.setDataSource(wrapper);
      },
      destroy: function() {
        this.setDataSource();
      }
    };
    function fastChildNodesOrder(node, order) {
      var lastIndex = order.length - 1;
      node.childNodes = order;
      node.firstChild = order[0] || null;
      node.lastChild = order[lastIndex] || null;
      for (var orderNode, i = lastIndex; orderNode = order[i]; i--) {
        orderNode.nextSibling = order[i + 1] || null;
        orderNode.previousSibling = order[i - 1] || null;
        node.insertBefore(orderNode, orderNode.nextSibling);
      }
    }
    function fastChildNodesGroupOrder(node, order) {
      for (var i = 0, child; child = order[i]; i++) child.groupNode.nodes.push(child);
      order.length = 0;
      for (var group = node.grouping.nullGroup; group; group = group.nextSibling) {
        var nodes = group.nodes;
        group.first = nodes[0] || null;
        group.last = nodes[nodes.length - 1] || null;
        order.push.apply(order, nodes);
        group.emit_childNodesModified({
          inserted: nodes
        });
      }
      return order;
    }
    function createChildByFactory(node, config) {
      var child;
      if (typeof node.childFactory == "function") {
        child = node.childFactory(config);
        if (child instanceof node.childClass) return child;
      }
      if (!child) throw EXCEPTION_NULL_CHILD;
      basis.dev.warn(EXCEPTION_BAD_CHILD_CLASS + " (expected " + (node.childClass && node.childClass.className) + " but " + (child && child.constructor && child.constructor.className) + ")");
      throw EXCEPTION_BAD_CHILD_CLASS;
    }
    var DomMixin = {
      childClass: AbstractNode,
      childFactory: null,
      listen: {
        dataSource: DOMMIXIN_DATASOURCE_HANDLER
      },
      getChild: function(value, getter) {
        return basis.array.search(this.childNodes, value, getter);
      },
      getChildByName: function(name) {
        return this.getChild(name, "name");
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild);
      },
      insertBefore: function(newChild, refChild) {
        if (!this.childClass) throw EXCEPTION_NO_CHILDCLASS;
        if (newChild.firstChild) {
          var cursor = this;
          while (cursor = cursor.parentNode) {
            if (cursor === newChild) throw EXCEPTION_CANT_INSERT;
          }
        }
        var isChildClassInstance = newChild && newChild instanceof this.childClass;
        if (this.dataSource) {
          if (!isChildClassInstance || !newChild.delegate || this.dataSourceMap_[newChild.delegate.basisObjectId] !== newChild) throw EXCEPTION_DATASOURCE_CONFLICT;
        } else {
          if (this.dataSourceAdapter_) throw EXCEPTION_DATASOURCEADAPTER_CONFLICT;
        }
        if (!isChildClassInstance) newChild = createChildByFactory(this, newChild instanceof DataObject ? {
          delegate: newChild
        } : newChild);
        if (newChild.owner) throw EXCEPTION_PARENTNODE_OWNER_CONFLICT;
        var isInside = newChild.parentNode === this;
        var childNodes = this.childNodes;
        var grouping = this.grouping;
        var groupNodes;
        var currentNewChildGroup = newChild.groupNode;
        var group = null;
        var sorting = this.sorting;
        var sortingDesc;
        var correctSortPos = false;
        var newChildValue;
        var pos = -1;
        var nextSibling;
        var prevSibling;
        if (isInside) {
          nextSibling = newChild.nextSibling;
          prevSibling = newChild.previousSibling;
        }
        if (sorting !== nullGetter) {
          refChild = null;
          sortingDesc = this.sortingDesc;
          newChildValue = sorting(newChild) || 0;
          if (isInside) {
            if (newChildValue === newChild.sortingValue) {
              correctSortPos = true;
            } else {
              if ((!nextSibling || (sortingDesc ? nextSibling.sortingValue <= newChildValue : nextSibling.sortingValue >= newChildValue)) && (!prevSibling || (sortingDesc ? prevSibling.sortingValue >= newChildValue : prevSibling.sortingValue <= newChildValue))) {
                newChild.sortingValue = newChildValue;
                correctSortPos = true;
              }
            }
          }
        }
        if (grouping) {
          var cursor;
          group = grouping.getGroupNode(newChild, true);
          groupNodes = group.nodes;
          if (currentNewChildGroup === group) if (correctSortPos || sorting === nullGetter && nextSibling === refChild) return newChild;
          if (sorting !== nullGetter) {
            if (currentNewChildGroup === group && correctSortPos) {
              if (nextSibling && nextSibling.groupNode === group) pos = groupNodes.indexOf(nextSibling); else pos = groupNodes.length;
            } else {
              pos = binarySearchPos(groupNodes, newChildValue, sortingSearch, sortingDesc);
              newChild.sortingValue = newChildValue;
            }
          } else {
            if (refChild && refChild.groupNode === group) pos = groupNodes.indexOf(refChild); else pos = groupNodes.length;
          }
          if (pos < groupNodes.length) {
            refChild = groupNodes[pos];
          } else {
            if (group.last) {
              refChild = group.last.nextSibling;
            } else {
              cursor = group;
              refChild = null;
              while (cursor = cursor.nextSibling) if (refChild = cursor.first) break;
            }
          }
          if (newChild === refChild || isInside && nextSibling === refChild) {
            if (currentNewChildGroup !== group) {
              if (currentNewChildGroup) currentNewChildGroup.remove(newChild);
              group.insert(newChild, refChild);
            }
            return newChild;
          }
          pos = -1;
        } else {
          if (sorting !== nullGetter) {
            if (correctSortPos) return newChild;
            pos = binarySearchPos(childNodes, newChildValue, sortingSearch, sortingDesc);
            refChild = childNodes[pos];
            newChild.sortingValue = newChildValue;
            if (newChild === refChild || isInside && nextSibling === refChild) return newChild;
          } else {
            if (refChild && refChild.parentNode !== this) throw EXCEPTION_NODE_NOT_FOUND;
            if (isInside) {
              if (nextSibling === refChild) return newChild;
              if (newChild === refChild) throw EXCEPTION_CANT_INSERT;
            }
          }
        }
        if (isInside) {
          if (nextSibling) {
            nextSibling.previousSibling = prevSibling;
            newChild.nextSibling = null;
          } else this.lastChild = prevSibling;
          if (prevSibling) {
            prevSibling.nextSibling = nextSibling;
            newChild.previousSibling = null;
          } else this.firstChild = nextSibling;
          if (pos == -1) arrayRemove(childNodes, newChild); else {
            var oldPos = childNodes.indexOf(newChild);
            childNodes.splice(oldPos, 1);
            pos -= oldPos < pos;
          }
          if (currentNewChildGroup) {
            currentNewChildGroup.remove(newChild);
            currentNewChildGroup = null;
          }
        } else {
          if (newChild.parentNode) newChild.parentNode.removeChild(newChild);
        }
        if (currentNewChildGroup != group) group.insert(newChild, refChild);
        if (refChild) {
          if (pos == -1) pos = childNodes.indexOf(refChild);
          if (pos == -1) throw EXCEPTION_NODE_NOT_FOUND;
          newChild.nextSibling = refChild;
          childNodes.splice(pos, 0, newChild);
        } else {
          pos = childNodes.length;
          childNodes.push(newChild);
          refChild = {
            previousSibling: this.lastChild
          };
          this.lastChild = newChild;
        }
        newChild.parentNode = this;
        newChild.previousSibling = refChild.previousSibling;
        if (pos == 0) this.firstChild = newChild; else refChild.previousSibling.nextSibling = newChild;
        refChild.previousSibling = newChild;
        if (!isInside) {
          updateNodeContextSelection(newChild, newChild.contextSelection, this.selection || this.contextSelection, true);
          updateNodeDisableContext(newChild, this.disabled || this.contextDisabled);
          if ((newChild.underMatch_ || this.matchFunction) && newChild.match) newChild.match(this.matchFunction);
          if (newChild.autoDelegate == DELEGATE.PARENT || newChild.autoDelegate === DELEGATE.ANY) newChild.setDelegate(this);
          if (!this.dataSource) this.emit_childNodesModified({
            inserted: [ newChild ]
          });
          if (newChild.listen.parentNode) this.addHandler(newChild.listen.parentNode, newChild);
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (!oldChild || oldChild.parentNode !== this) throw EXCEPTION_NODE_NOT_FOUND;
        if (oldChild instanceof this.childClass == false) throw EXCEPTION_BAD_CHILD_CLASS;
        if (this.dataSource) {
          if (this.dataSource.has(oldChild.delegate)) throw EXCEPTION_DATASOURCE_CONFLICT;
        } else {
          if (this.dataSourceAdapter_) throw EXCEPTION_DATASOURCEADAPTER_CONFLICT;
        }
        var pos = this.childNodes.indexOf(oldChild);
        if (pos == -1) throw EXCEPTION_NODE_NOT_FOUND;
        this.childNodes.splice(pos, 1);
        oldChild.parentNode = null;
        if (oldChild.nextSibling) oldChild.nextSibling.previousSibling = oldChild.previousSibling; else this.lastChild = oldChild.previousSibling;
        if (oldChild.previousSibling) oldChild.previousSibling.nextSibling = oldChild.nextSibling; else this.firstChild = oldChild.nextSibling;
        oldChild.nextSibling = null;
        oldChild.previousSibling = null;
        if (oldChild.listen.parentNode) this.removeHandler(oldChild.listen.parentNode, oldChild);
        updateNodeContextSelection(oldChild, oldChild.contextSelection, null, true);
        if (oldChild.groupNode) oldChild.groupNode.remove(oldChild);
        if (!this.dataSource) this.emit_childNodesModified({
          deleted: [ oldChild ]
        });
        if (oldChild.autoDelegate == DELEGATE.PARENT || oldChild.autoDelegate === DELEGATE.ANY) oldChild.setDelegate();
        return oldChild;
      },
      replaceChild: function(newChild, oldChild) {
        if (this.dataSource) throw EXCEPTION_DATASOURCE_CONFLICT;
        if (this.dataSourceAdapter_) throw EXCEPTION_DATASOURCEADAPTER_CONFLICT;
        if (oldChild == null || oldChild.parentNode !== this) throw EXCEPTION_NODE_NOT_FOUND;
        this.insertBefore(newChild, oldChild);
        return this.removeChild(oldChild);
      },
      clear: function(alive) {
        if (this.dataSource && this.dataSource.itemCount) throw EXCEPTION_DATASOURCE_CONFLICT;
        if (!this.firstChild) return;
        if (alive) updateNodeContextSelection(this, this.selection || this.contextSelection, null, false, true);
        var childNodes = this.childNodes;
        this.firstChild = null;
        this.lastChild = null;
        this.childNodes = [];
        this.emit_childNodesModified({
          deleted: childNodes
        });
        for (var i = childNodes.length; i-- > 0; ) {
          var child = childNodes[i];
          if (child.listen.parentNode) child.parentNode.removeHandler(child.listen.parentNode, child);
          child.parentNode = null;
          child.groupNode = null;
          if (alive) {
            child.nextSibling = null;
            child.previousSibling = null;
            if (child.autoDelegate == DELEGATE.PARENT || child.autoDelegate === DELEGATE.ANY) child.setDelegate();
          } else child.destroy();
        }
        if (this.grouping) {
          for (var childNodes = this.grouping.childNodes, i = childNodes.length - 1, group; group = childNodes[i]; i--) group.clear();
        }
      },
      setChildNodes: function(newChildNodes, keepAlive) {
        if (!this.dataSource && !this.dataSourceAdapter_) this.clear(keepAlive);
        if (newChildNodes) {
          if ("length" in newChildNodes == false) newChildNodes = [ newChildNodes ];
          if (newChildNodes.length) {
            var tmp = this.emit_childNodesModified;
            this.emit_childNodesModified = $undef;
            for (var i = 0, len = newChildNodes.length; i < len; i++) this.insertBefore(newChildNodes[i]);
            this.emit_childNodesModified = tmp;
            this.emit_childNodesModified({
              inserted: this.childNodes
            });
          }
        }
      },
      setDataSource: function(dataSource) {
        if (!this.childClass) throw EXCEPTION_NO_CHILDCLASS;
        dataSource = basis.data.resolveDataset(this, this.setDataSource, dataSource, "dataSourceAdapter_");
        if (this.dataSource !== dataSource) {
          var oldDataSource = this.dataSource;
          var listenHandler = this.listen.dataSource;
          if (oldDataSource) {
            this.dataSourceMap_ = null;
            this.dataSource = null;
            if (listenHandler) oldDataSource.removeHandler(listenHandler, this);
          }
          if (this.firstChild) {
            if (oldDataSource) for (var i = 0, child; child = this.childNodes[i]; i++) unlockDataSourceItemNode(child);
            this.clear();
          }
          this.dataSource = dataSource;
          if (dataSource) {
            this.dataSourceMap_ = {};
            this.setChildNodesState(dataSource.state, dataSource.state.data);
            if (listenHandler) {
              dataSource.addHandler(listenHandler, this);
              if (dataSource.itemCount && listenHandler.itemsChanged) {
                listenHandler.itemsChanged.call(this, dataSource, {
                  inserted: dataSource.getItems()
                });
              }
            }
          } else {
            this.setChildNodesState(STATE.UNDEFINED);
          }
          this.emit_dataSourceChanged(oldDataSource);
        }
      },
      setGrouping: function(grouping, alive) {
        if (typeof grouping == "function" || typeof grouping == "string") grouping = {
          rule: grouping
        };
        if (grouping instanceof GroupingNode == false) {
          grouping = grouping && typeof grouping == "object" ? new this.groupingClass(grouping) : null;
        }
        if (this.grouping !== grouping) {
          var oldGrouping = this.grouping;
          var order;
          if (oldGrouping) {
            this.grouping = null;
            if (!grouping) {
              if (this.firstChild) {
                if (this.sorting !== nullGetter) order = sortChildNodes(this); else order = this.childNodes;
                oldGrouping.nullGroup.clear();
                var groups = oldGrouping.childNodes.slice(0);
                for (var i = 0; i < groups.length; i++) groups[i].clear();
                fastChildNodesOrder(this, order);
              }
            }
            oldGrouping.setOwner();
          }
          if (grouping) {
            this.grouping = grouping;
            grouping.setOwner(this);
            if (this.firstChild) {
              if (this.sorting !== nullGetter) order = sortChildNodes(this); else order = this.childNodes;
              for (var i = 0, child; child = order[i]; i++) child.groupNode = this.grouping.getGroupNode(child, true);
              order = fastChildNodesGroupOrder(this, order);
              fastChildNodesOrder(this, order);
            }
          }
          this.emit_groupingChanged(oldGrouping);
        }
      },
      setSorting: function(sorting, sortingDesc) {
        sorting = getter(sorting);
        sortingDesc = !!sortingDesc;
        if (this.sorting !== sorting || this.sortingDesc != !!sortingDesc) {
          var oldSorting = this.sorting;
          var oldSortingDesc = this.sortingDesc;
          this.sorting = sorting;
          this.sortingDesc = !!sortingDesc;
          if (sorting !== nullGetter && this.firstChild) {
            var order = [];
            var nodes;
            for (var node = this.firstChild; node; node = node.nextSibling) node.sortingValue = sorting(node) || 0;
            if (this.grouping) {
              for (var group = this.grouping.nullGroup; group; group = group.nextSibling) {
                nodes = group.nodes = sortChildNodes({
                  childNodes: group.nodes,
                  sortingDesc: this.sortingDesc
                });
                group.first = nodes[0] || null;
                group.last = nodes[nodes.length - 1] || null;
                order.push.apply(order, nodes);
              }
            } else {
              order = sortChildNodes(this);
            }
            fastChildNodesOrder(this, order);
          }
          this.emit_sortingChanged(oldSorting, oldSortingDesc);
        }
      },
      setMatchFunction: function(matchFunction) {
        if (this.matchFunction != matchFunction) {
          var oldMatchFunction = this.matchFunction;
          this.matchFunction = matchFunction;
          for (var node = this.lastChild; node; node = node.previousSibling) node.match(matchFunction);
          this.emit_matchFunctionChanged(oldMatchFunction);
        }
      }
    };
    var Node = Class(AbstractNode, DomMixin, {
      className: namespace + ".Node",
      emit_enable: createEvent("enable") && function() {
        for (var child = this.firstChild; child; child = child.nextSibling) updateNodeDisableContext(child, false);
        events.enable.call(this);
      },
      emit_disable: createEvent("disable") && function() {
        for (var child = this.firstChild; child; child = child.nextSibling) updateNodeDisableContext(child, true);
        events.disable.call(this);
      },
      emit_satelliteChanged: function(name, oldSatellite) {
        AbstractNode.prototype.emit_satelliteChanged.call(this, name, oldSatellite);
        if (this.satellite[name] instanceof Node) updateNodeDisableContext(this.satellite[name], this.disabled || this.contextDisabled);
      },
      emit_select: createEvent("select"),
      emit_unselect: createEvent("unselect"),
      emit_match: createEvent("match"),
      emit_unmatch: createEvent("unmatch"),
      emit_matchFunctionChanged: createEvent("matchFunctionChanged", "oldMatchFunction"),
      selectable: true,
      selected: false,
      selection: null,
      contextSelection: null,
      matchFunction: null,
      matched: true,
      disabled: false,
      contextDisabled: false,
      listen: {
        owner: {
          enable: function() {
            updateNodeDisableContext(this, false);
          },
          disable: function() {
            updateNodeDisableContext(this, true);
          }
        }
      },
      init: function() {
        if (this.selection) {
          if (this.selection instanceof ReadOnlyDataset == false) this.selection = new Selection(this.selection);
          if (this.listen.selection) this.selection.addHandler(this.listen.selection, this);
        }
        AbstractNode.prototype.init.call(this);
        if (this.disabled) this.emit_disable();
        if (this.selected) {
          this.selected = false;
          this.select(true);
        }
      },
      setSelection: function(selection) {
        if (this.selection !== selection) {
          updateNodeContextSelection(this, this.selection || this.contextSelection, selection || this.contextSelection, false, true);
          if (this.selection && this.listen.selection) this.selection.removeHandler(this.listen.selection, this);
          this.selection = selection;
          if (selection && this.listen.selection) selection.addHandler(this.listen.selection, this);
          return true;
        }
      },
      select: function(multiple) {
        var selected = this.selected;
        var selection = this.contextSelection;
        if (selection) {
          if (!multiple) {
            if (this.selectable) selection.set([ this ]);
          } else {
            if (selected) selection.remove([ this ]); else selection.add([ this ]);
          }
        } else if (!selected && this.selectable) {
          this.selected = true;
          this.emit_select();
        }
        return this.selected != selected;
      },
      unselect: function() {
        var selected = this.selected;
        if (selected) {
          var selection = this.contextSelection;
          if (selection) selection.remove([ this ]); else {
            this.selected = false;
            this.emit_unselect();
          }
        }
        return this.selected != selected;
      },
      setSelected: function(selected, multiple) {
        return selected ? this.select(multiple) : this.unselect();
      },
      enable: function() {
        var disabled = this.disabled;
        if (disabled) {
          this.disabled = false;
          if (!this.contextDisabled) this.emit_enable();
        }
        return this.disabled != disabled;
      },
      disable: function() {
        var disabled = this.disabled;
        if (!disabled) {
          this.disabled = true;
          if (!this.contextDisabled) this.emit_disable();
        }
        return this.disabled != disabled;
      },
      setDisabled: function(disabled) {
        return disabled ? this.disable() : this.enable();
      },
      isDisabled: function() {
        return this.disabled || this.contextDisabled;
      },
      match: function(func) {
        if (typeof func != "function") func = null;
        if (this.underMatch_ && !func) this.underMatch_(this, true);
        this.underMatch_ = func;
        var matched = !func || func(this);
        if (this.matched != matched) {
          this.matched = matched;
          if (matched) this.emit_match(); else this.emit_unmatch();
        }
      },
      destroy: function() {
        this.unselect();
        this.contextSelection = null;
        if (this.selection) this.setSelection();
        AbstractNode.prototype.destroy.call(this);
      }
    });
    var GroupingNode = Class(AbstractNode, DomMixin, {
      className: namespace + ".GroupingNode",
      emit_childNodesModified: function(delta) {
        events.childNodesModified.call(this, delta);
        this.nullGroup.nextSibling = this.firstChild;
        var array;
        if (array = delta.inserted) {
          for (var i = 0, child; child = array[i++]; ) {
            child.groupId_ = child.delegate ? child.delegate.basisObjectId : child.data.id;
            this.map_[child.groupId_] = child;
          }
          if (this.dataSource && this.nullGroup.first) {
            var parentNode = this.owner;
            var nodes = arrayFrom(this.nullGroup.nodes);
            for (var i = nodes.length; i-- > 0; ) parentNode.insertBefore(nodes[i], nodes[i].nextSibling);
          }
        }
      },
      emit_ownerChanged: function(oldOwner) {
        if (oldOwner && oldOwner.grouping === this) oldOwner.setGrouping(null, true);
        if (this.owner && this.owner.grouping !== this) this.owner.setGrouping(this);
        events.ownerChanged.call(this, oldOwner);
        if (!this.owner && this.autoDestroyWithNoOwner) this.destroy();
      },
      map_: null,
      nullGroup: null,
      autoDestroyWithNoOwner: true,
      autoDestroyEmptyGroups: true,
      rule: nullGetter,
      childClass: PartitionNode,
      childFactory: function(config) {
        return new this.childClass(complete({
          autoDestroyIfEmpty: this.dataSource ? false : this.autoDestroyEmptyGroups
        }, config));
      },
      init: function() {
        this.map_ = {};
        this.nullGroup = new PartitionNode;
        AbstractNode.prototype.init.call(this);
      },
      getGroupNode: function(node, autocreate) {
        var groupRef = this.rule(node);
        var isDelegate = groupRef instanceof DataObject;
        var group = this.map_[isDelegate ? groupRef.basisObjectId : groupRef];
        if (this.dataSource) autocreate = false;
        if (!group && autocreate) {
          group = this.appendChild(isDelegate ? groupRef : {
            data: {
              id: groupRef,
              title: groupRef
            }
          });
        }
        return group || this.nullGroup;
      },
      setDataSource: function(dataSource) {
        var curDataSource = this.dataSource;
        DomMixin.setDataSource.call(this, dataSource);
        var owner = this.owner;
        if (owner && this.dataSource !== curDataSource) {
          var nodes = arrayFrom(owner.childNodes);
          for (var i = nodes.length - 1; i >= 0; i--) owner.insertBefore(nodes[i], nodes[i + 1]);
        }
      },
      insertBefore: function(newChild, refChild) {
        newChild = DomMixin.insertBefore.call(this, newChild, refChild);
        var firstNode = newChild.first;
        if (firstNode) {
          var parent = firstNode.parentNode;
          var lastNode = newChild.last;
          var beforePrev;
          var beforeNext;
          var afterPrev;
          var afterNext = null;
          var cursor = newChild;
          while (cursor = cursor.nextSibling) {
            if (afterNext = cursor.first) break;
          }
          afterPrev = afterNext ? afterNext.previousSibling : parent.lastChild;
          beforePrev = firstNode.previousSibling;
          beforeNext = lastNode.nextSibling;
          if (beforeNext !== afterNext) {
            var parentChildNodes = parent.childNodes;
            var nodes = newChild.nodes;
            var nodesCount = nodes.length;
            if (beforePrev) beforePrev.nextSibling = beforeNext;
            if (beforeNext) beforeNext.previousSibling = beforePrev;
            if (afterPrev) afterPrev.nextSibling = firstNode;
            if (afterNext) afterNext.previousSibling = lastNode;
            firstNode.previousSibling = afterPrev;
            lastNode.nextSibling = afterNext;
            var firstPos = parentChildNodes.indexOf(firstNode);
            var afterNextPos = afterNext ? parentChildNodes.indexOf(afterNext) : parentChildNodes.length;
            if (afterNextPos > firstPos) afterNextPos -= nodesCount;
            parentChildNodes.splice(firstPos, nodesCount);
            parentChildNodes.splice.apply(parentChildNodes, [ afterNextPos, 0 ].concat(nodes));
            if (!afterPrev || !beforePrev) parent.firstChild = parentChildNodes[0];
            if (!afterNext || !beforeNext) parent.lastChild = parentChildNodes[parentChildNodes.length - 1];
            if (firstNode instanceof PartitionNode) for (var i = nodesCount, insertBefore = afterNext; i-- > 0; ) {
              parent.insertBefore(nodes[i], insertBefore);
              insertBefore = nodes[i];
            }
          }
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (oldChild = DomMixin.removeChild.call(this, oldChild)) {
          delete this.map_[oldChild.groupId_];
          for (var i = 0, node; node = oldChild.nodes[i]; i++) node.parentNode.insertBefore(node);
        }
        return oldChild;
      },
      clear: function(alive) {
        var nodes = [];
        var getGroupNode = this.getGroupNode;
        var nullGroup = this.nullGroup;
        this.getGroupNode = function() {
          return nullGroup;
        };
        for (var group = this.firstChild; group; group = group.nextSibling) nodes.push.apply(nodes, group.nodes);
        for (var i = 0, child; child = nodes[i]; i++) child.parentNode.insertBefore(child);
        this.getGroupNode = getGroupNode;
        DomMixin.clear.call(this, alive);
        this.map_ = {};
      },
      destroy: function() {
        this.autoDestroyWithNoOwner = false;
        AbstractNode.prototype.destroy.call(this);
        this.nullGroup.destroy();
        this.nullGroup = null;
        this.map_ = null;
      }
    });
    AbstractNode.prototype.groupingClass = GroupingNode;
    var CHILDNODESDATASET_HANDLER = {
      childNodesModified: function(sender, delta) {
        var memberMap = this.members_;
        var newDelta = {};
        var node;
        var insertCount = 0;
        var deleteCount = 0;
        var inserted = delta.inserted;
        var deleted = delta.deleted;
        if (inserted && inserted.length) {
          newDelta.inserted = inserted;
          while (node = inserted[insertCount]) {
            memberMap[node.basisObjectId] = node;
            insertCount++;
          }
        }
        if (deleted && deleted.length) {
          newDelta.deleted = deleted;
          while (node = deleted[deleteCount]) {
            delete memberMap[node.basisObjectId];
            deleteCount++;
          }
        }
        if (insertCount || deleteCount) this.emit_itemsChanged(newDelta);
      },
      destroy: function() {
        this.destroy();
      }
    };
    var ChildNodesDataset = Class(ReadOnlyDataset, {
      className: namespace + ".ChildNodesDataset",
      sourceNode: null,
      init: function() {
        ReadOnlyDataset.prototype.init.call(this);
        var sourceNode = this.sourceNode;
        childNodesDatasetMap[sourceNode.basisObjectId] = this;
        if (sourceNode.firstChild) CHILDNODESDATASET_HANDLER.childNodesModified.call(this, sourceNode, {
          inserted: sourceNode.childNodes
        });
        sourceNode.addHandler(CHILDNODESDATASET_HANDLER, this);
      },
      destroy: function() {
        this.sourceNode.removeHandler(CHILDNODESDATASET_HANDLER, this);
        delete childNodesDatasetMap[this.sourceNode.basisObjectId];
        ReadOnlyDataset.prototype.destroy.call(this);
      }
    });
    var Selection = Class(Dataset, {
      className: namespace + ".Selection",
      multiple: false,
      emit_itemsChanged: function(delta) {
        Dataset.prototype.emit_itemsChanged.call(this, delta);
        if (delta.inserted) {
          for (var i = 0, node; node = delta.inserted[i]; i++) {
            if (!node.selected) {
              node.selected = true;
              node.emit_select();
            }
          }
        }
        if (delta.deleted) {
          for (var i = 0, node; node = delta.deleted[i]; i++) {
            if (node.selected) {
              node.selected = false;
              node.emit_unselect();
            }
          }
        }
      },
      add: function(nodes) {
        if (!this.multiple) {
          if (this.itemCount) return this.set(nodes); else nodes = [ nodes[0] ];
        }
        var items = [];
        for (var i = 0, node; node = nodes[i]; i++) {
          if (node.contextSelection == this && node.selectable) items.push(node);
        }
        return Dataset.prototype.add.call(this, items);
      },
      set: function(nodes) {
        var items = [];
        for (var i = 0, node; node = nodes[i]; i++) {
          if (node.contextSelection == this && node.selectable) items.push(node);
        }
        if (!this.multiple) items.splice(1);
        return Dataset.prototype.set.call(this, items);
      }
    });
    module.exports = {
      DELEGATE: DELEGATE,
      AbstractNode: AbstractNode,
      Node: Node,
      GroupingNode: GroupingNode,
      PartitionNode: PartitionNode,
      ChildNodesDataset: ChildNodesDataset,
      Selection: Selection,
      nullSelection: new ReadOnlyDataset
    };
  },
  "x.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./j.js");
    basis.require("./1.js");
    module.exports = basis.ui.Node.subclass({
      template: basis.template.get("#3"),
      childClass: basis.ui.Node.subclass({
        template: basis.template.get("#4"),
        data: {
          name: "default",
          id: 0
        },
        binding: {
          name: "data:name",
          id: "data:id"
        },
        action: {
          selectTeam: function() {
            this.parentNode.owner.emit_teamChange(this.data.code);
          }
        }
      }),
      handler: {
        update: function() {
          var teams = this.data.teams;
          var arr = [];
          for (var i in teams) {
            if (teams.hasOwnProperty(i)) {
              arr.push({
                data: {
                  id: teams[i].id,
                  name: teams[i].name,
                  code: teams[i].code
                }
              });
            }
          }
          this.setChildNodes(arr);
        }
      }
    });
  },
  "j.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./8.js");
    var namespace = this.path;
    var document = global.document;
    var Class = basis.Class;
    var arrayFrom = basis.array.from;
    var getter = basis.getter;
    var testElement = document.createElement("div");
    var ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = 2;
    var TEXT_NODE = 3;
    var CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = 8;
    var DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = 12;
    var AXIS_ANCESTOR = 1;
    var AXIS_ANCESTOR_OR_SELF = 2;
    var AXIS_DESCENDANT = 4;
    var AXIS_DESCENDANT_OR_SELF = 8;
    var AXIS_SELF = 16;
    var AXIS_PARENT = 32;
    var AXIS_CHILD = 64;
    var AXIS_FOLLOWING = 128;
    var AXIS_FOLLOWING_SIBLING = 256;
    var AXIS_PRECEDING = 512;
    var AXIS_PRECEDING_SIBLING = 1024;
    var POSITION_DISCONNECTED = 1;
    var POSITION_PRECEDING = 2;
    var POSITION_FOLLOWING = 4;
    var POSITION_CONTAINS = 8;
    var POSITION_CONTAINED_BY = 16;
    var POSITION_IMPLEMENTATION_SPECIFIC = 32;
    var PARENT_NODE = "parentNode";
    var FIRST_CHILD = "firstChild";
    var LAST_CHILD = "lastChild";
    var NEXT_SIBLING = "nextSibling";
    var PREVIOUS_SIBLING = "previousSibling";
    var INSERT_BEGIN = "begin";
    var INSERT_END = "end";
    var INSERT_BEFORE = "before";
    var INSERT_AFTER = "after";
    var comparePosition;
    if (typeof testElement.compareDocumentPosition == "function") {
      comparePosition = function(nodeA, nodeB) {
        return nodeA.compareDocumentPosition(nodeB);
      };
    } else {
      comparePosition = function(nodeA, nodeB) {
        if (nodeA == nodeB) return 0;
        if (nodeA.document != nodeB.document) return POSITION_DISCONNECTED | POSITION_IMPLEMENTATION_SPECIFIC;
        if (nodeA.sourceIndex > nodeB.sourceIndex) return POSITION_PRECEDING | POSITION_CONTAINS * nodeB.contains(nodeA); else return POSITION_FOLLOWING | POSITION_CONTAINED_BY * nodeA.contains(nodeB);
      };
    }
    var isNode;
    if (typeof Node != "undefined") {
      isNode = function(node) {
        return node instanceof Node;
      };
      if (!Node.prototype.contains) Node.prototype.contains = function(node) {
        return !!(this.compareDocumentPosition(node) & POSITION_CONTAINED_BY);
      };
    } else {
      isNode = function(node) {
        return node && node.ownerDocument === document;
      };
    }
    function handleInsert(node, newNode, refChild) {
      return newNode != null ? node.insertBefore(isNode(newNode) ? newNode : createText(newNode), refChild || null) : null;
    }
    var TreeWalker = Class(null, {
      className: namespace + ".TreeWalker",
      root_: null,
      cursor_: null,
      filter: basis.fn.$true,
      init: function(root, filter, direction) {
        this.setRoot(root);
        this.setDirection(direction);
        if (typeof filter == "function") this.filter = filter;
      },
      setDirection: function(direction) {
        basis.object.extend(this, direction ? {
          a: LAST_CHILD,
          b: PREVIOUS_SIBLING,
          c: NEXT_SIBLING,
          d: FIRST_CHILD
        } : {
          a: FIRST_CHILD,
          b: NEXT_SIBLING,
          c: PREVIOUS_SIBLING,
          d: LAST_CHILD
        });
      },
      setRoot: function(node) {
        this.root_ = node || document;
        this.reset();
      },
      reset: function() {
        this.cursor_ = null;
      },
      first: function(filter) {
        this.reset();
        return this.next(filter);
      },
      last: function(filter) {
        this.reset();
        return this.prev(filter);
      },
      nodes: function(filter, result) {
        var node;
        if (!result) result = [];
        this.reset();
        while (node = this.next(filter)) result.push(node);
        return result;
      },
      next: function(filter) {
        filter = filter || this.filter;
        var cursor = this.cursor_ || this.root_;
        do {
          var node = cursor[this.a];
          while (!node) {
            if (cursor === this.root_) return this.cursor_ = null;
            node = cursor[this.b];
            if (!node) cursor = cursor[PARENT_NODE];
          }
        } while (!filter(cursor = node));
        return this.cursor_ = cursor;
      },
      prev: function(filter) {
        filter = filter || this.filter;
        var cursor = this.cursor_;
        var prevSibling = this.c;
        var prevChild = this.d;
        do {
          var node = cursor ? cursor[prevSibling] : this.root_[prevChild];
          if (node) {
            while (node[prevChild]) node = node[prevChild];
            cursor = node;
          } else if (cursor) cursor = cursor[PARENT_NODE];
          if (!cursor || cursor === this.root_) {
            cursor = null;
            break;
          }
        } while (!filter(cursor));
        return this.cursor_ = cursor;
      },
      destroy: function() {
        this.root_ = null;
        this.cursor_ = null;
      }
    });
    TreeWalker.BACKWARD = true;
    function outerHTML(node, noClone) {
      return node.outerHTML || createElement("", noClone ? node : node.cloneNode(true)).innerHTML;
    }
    var TEXT_PROPERTIES = [ "textContent", "innerText", "nodeValue" ];
    function textContent(node) {
      for (var i = 0, property; property = TEXT_PROPERTIES[i++]; ) if (node[property] != null) return node[property];
      return axis(node, AXIS_DESCENDANT, function(node) {
        return node.nodeType == TEXT_NODE;
      }).map(getter("nodeValue")).join("");
    }
    function get(ref) {
      if (ref && (isNode(ref) || ref.nodeType)) return ref; else return typeof ref == "string" ? document.getElementById(ref) : null;
    }
    function tag(node, tagName) {
      var element = get(node) || document;
      if (tagName == "*" && element.all) return arrayFrom(element.all); else return arrayFrom(element.getElementsByTagName(tagName || "*"));
    }
    function axis(root, axis, filter) {
      var result = [];
      var walker;
      var cursor;
      filter = typeof filter == "string" ? getter(filter) : filter || basis.fn.$true;
      if (axis & (AXIS_SELF | AXIS_ANCESTOR_OR_SELF | AXIS_DESCENDANT_OR_SELF)) if (filter(root)) result.push(root);
      switch (axis) {
        case AXIS_ANCESTOR:
        case AXIS_ANCESTOR_OR_SELF:
          cursor = root;
          while ((cursor = cursor[PARENT_NODE]) && cursor !== root.document) if (filter(cursor)) result.push(cursor);
          break;
        case AXIS_CHILD:
          cursor = root[FIRST_CHILD];
          while (cursor) {
            if (filter(cursor)) result.push(cursor);
            cursor = cursor[NEXT_SIBLING];
          }
          break;
        case AXIS_DESCENDANT:
        case AXIS_DESCENDANT_OR_SELF:
          if (root[FIRST_CHILD]) {
            walker = new TreeWalker(root);
            walker.nodes(filter, result);
          }
          break;
        case AXIS_FOLLOWING:
          walker = new TreeWalker(root, filter);
          walker.cursor_ = root[NEXT_SIBLING] || root[PARENT_NODE];
          while (cursor = walker.next()) result.push(cursor);
          break;
        case AXIS_FOLLOWING_SIBLING:
          cursor = root;
          while (cursor = cursor[NEXT_SIBLING]) if (filter(cursor)) result.push(cursor);
          break;
        case AXIS_PARENT:
          if (filter(root[PARENT_NODE])) result.push(root[PARENT_NODE]);
          break;
        case AXIS_PRECEDING:
          walker = new TreeWalker(root, filter, TreeWalker.BACKWARD);
          walker.cursor_ = root[PREVIOUS_SIBLING] || root[PARENT_NODE];
          while (cursor = walker.next()) result.push(cursor);
          break;
        case AXIS_PRECEDING_SIBLING:
          cursor = root;
          while (cursor = cursor[PREVIOUS_SIBLING]) if (filter(cursor)) result.push(cursor);
          break;
      }
      return result;
    }
    function findAncestor(node, matchFunction, bound) {
      while (node && node !== bound) {
        if (matchFunction(node)) break;
        node = node.parentNode;
      }
      return node || null;
    }
    function createText(text) {
      return document.createTextNode(text != null ? text : "");
    }
    function createFragment() {
      var result = document.createDocumentFragment();
      var len = arguments.length;
      var array = createFragment.array = [];
      for (var i = 0; i < len; i++) array.push(handleInsert(result, arguments[i]));
      return result;
    }
    var IS_ATTRIBUTE_BUG_NAME = function() {
      var input = document.createElement("input");
      input.name = "a";
      return !/name/.test(outerHTML(input));
    }();
    var IS_ATTRIBUTE_BUG_STYLE = function() {
      testElement.setAttribute("style", "color: red");
      return testElement.style.color !== "red";
    }();
    var DESCRIPTION_PART_REGEXP = /#([a-z0-9_:\-]+)|\.([a-z0-9_:\-]+)|\[([a-z0-9_:\-]+)(="((?:\\.|[^"])*)"|='((?:\\.|[^'])*)'|=((?:\\.|[^\]])*))?\s*\]|\s*(\S)/gi;
    function createElement(config) {
      var isConfig = config != undefined && typeof config != "string";
      var description = (isConfig ? config.description : config) || "";
      var elementName = "div";
      var element;
      var m = description.match(/^([a-z0-9_\-]+)(.*)$/i);
      if (m) {
        elementName = m[1];
        description = m[2];
      }
      if (description != "") {
        var classNames = [];
        var attributes = {};
        var entryName;
        while (m = DESCRIPTION_PART_REGEXP.exec(description)) {
          if (m[8]) {
            throw new Error("Create element error in basis.dom.createElement()" + "\n\nDescription:\n> " + description + "\n\nProblem place:\n> " + description.substr(0, m.index) + "-->" + description.substr(m.index) + "<--");
          }
          entryName = m[1] || m[2] || m[3];
          if (m[1]) attributes.id = entryName; else if (m[2]) classNames.push(entryName); else {
            if (entryName != "class") attributes[entryName] = m[4] ? m[5] || m[6] || m[7] || "" : entryName;
          }
        }
        if (IS_ATTRIBUTE_BUG_NAME && attributes.name && /^(input|textarea|select)$/i.test(elementName)) elementName = "<" + elementName + " name=" + attributes.name + ">";
      }
      element = document.createElement(elementName);
      if (attributes) {
        if (attributes.style && IS_ATTRIBUTE_BUG_STYLE) element.style.cssText = attributes.style;
        for (var attrName in attributes) element.setAttribute(attrName, attributes[attrName], 0);
      }
      if (classNames && classNames.length) element.className = classNames.join(" ");
      if (arguments.length > 1) handleInsert(element, createFragment.apply(0, basis.array.flatten(arrayFrom(arguments, 1))));
      if (isConfig) {
        if (config.css && basis.cssom) basis.cssom.setStyle(element, config.css);
        if (basis.dom.event) {
          for (var event in config) if (typeof config[event] == "function") basis.dom.event.addHandler(element, event, config[event], element);
        }
      }
      return element;
    }
    function insert(node, source, insertPoint, refChild) {
      node = get(node) || node;
      switch (insertPoint) {
        case undefined:
        case INSERT_END:
          refChild = null;
          break;
        case INSERT_BEGIN:
          refChild = node[FIRST_CHILD];
          break;
        case INSERT_BEFORE:
          break;
        case INSERT_AFTER:
          refChild = refChild[NEXT_SIBLING];
          break;
        default:
          insertPoint = Number(insertPoint);
          refChild = insertPoint >= 0 && insertPoint < node.childNodes.length ? node.childNodes[insertPoint] : null;
      }
      var isDOMLikeObject = !isNode(node);
      var result;
      if (!source || !Array.isArray(source)) result = isDOMLikeObject ? source && node.insertBefore(source, refChild) : handleInsert(node, source, refChild); else {
        if (isDOMLikeObject) {
          result = [];
          for (var i = 0, len = source.length; i < len; i++) result[i] = node.insertBefore(source[i], refChild);
        } else {
          node.insertBefore(createFragment.apply(0, source), refChild);
          result = createFragment.array;
        }
      }
      return result;
    }
    function remove(node) {
      return node[PARENT_NODE] ? node[PARENT_NODE].removeChild(node) : node;
    }
    function replace(oldNode, newNode) {
      return oldNode[PARENT_NODE] ? oldNode[PARENT_NODE].replaceChild(newNode, oldNode) : oldNode;
    }
    function swap(nodeA, nodeB) {
      if (nodeA === nodeB || comparePosition(nodeA, nodeB) & (POSITION_CONTAINED_BY | POSITION_CONTAINS | POSITION_DISCONNECTED)) return false;
      replace(nodeA, testElement);
      replace(nodeB, nodeA);
      replace(testElement, nodeB);
      return true;
    }
    function clone(node, noChildren) {
      var result = node.cloneNode(!noChildren);
      if (result.attachEvent) axis(result, AXIS_DESCENDANT_OR_SELF).forEach(basis.dom.event.clearHandlers);
      return result;
    }
    function clear(node) {
      node = get(node);
      while (node[LAST_CHILD]) node.removeChild(node[LAST_CHILD]);
      return node;
    }
    function wrap(array, map, getter) {
      var result = [];
      getter = basis.getter(getter || basis.fn.$self);
      for (var k in map) for (var i = 0; i < array.length; i++) {
        var value = getter(array[i]);
        result[i] = map[k](array[i], i, value) ? createElement(k, value) : array[i];
      }
      return result;
    }
    function setAttribute(node, name, value) {
      if (value == null) node.removeAttribute(name); else node.setAttribute(name, value);
    }
    function is(element, names) {
      return (new RegExp("(^|\\W)" + element.tagName + "(\\W|$)")).test(names);
    }
    function parentOf(node, child) {
      return node.contains(child);
    }
    function isInside(node, root) {
      return node == root || root.contains(node);
    }
    function focus(node, select) {
      try {
        node = get(node);
        node.focus();
        if (select && node.select) node.select();
      } catch (e) {}
    }
    function setSelectionRange(input, start, end) {
      if (arguments.length < 3) end = start;
      if (input.setSelectionRange) input.setSelectionRange(start, end); else if (input.createTextRange) {
        var range = input.createTextRange();
        range.collapse(true);
        range.moveStart("character", start);
        range.moveEnd("character", end - start);
        range.select();
      }
    }
    function ieGetInputPosition(isStart) {
      if (document.selection) {
        var range = document.selection.createRange();
        if (range.compareEndPoints("StartToEnd", range) != 0) range.collapse(isStart);
        return range.getBookmark().charCodeAt(2) - 2;
      }
      return 0;
    }
    function getSelectionStart(input) {
      if (typeof input.selectionStart != "undefined") return input.selectionStart; else return ieGetInputPosition(true);
    }
    function getSelectionEnd(input) {
      if (typeof input.selectionEnd != "undefined") return input.selectionEnd; else return ieGetInputPosition(false);
    }
    module.exports = {
      ELEMENT_NODE: ELEMENT_NODE,
      ATTRIBUTE_NODE: ATTRIBUTE_NODE,
      TEXT_NODE: TEXT_NODE,
      CDATA_SECTION_NODE: CDATA_SECTION_NODE,
      ENTITY_REFERENCE_NODE: ENTITY_REFERENCE_NODE,
      ENTITY_NODE: ENTITY_NODE,
      PROCESSING_INSTRUCTION_NODE: PROCESSING_INSTRUCTION_NODE,
      COMMENT_NODE: COMMENT_NODE,
      DOCUMENT_TYPE_NODE: DOCUMENT_TYPE_NODE,
      DOCUMENT_NODE: DOCUMENT_NODE,
      DOCUMENT_FRAGMENT_NODE: DOCUMENT_FRAGMENT_NODE,
      NOTATION_NODE: NOTATION_NODE,
      AXIS_ANCESTOR: AXIS_ANCESTOR,
      AXIS_ANCESTOR_OR_SELF: AXIS_ANCESTOR_OR_SELF,
      AXIS_DESCENDANT: AXIS_DESCENDANT,
      AXIS_DESCENDANT_OR_SELF: AXIS_DESCENDANT_OR_SELF,
      AXIS_SELF: AXIS_SELF,
      AXIS_PARENT: AXIS_PARENT,
      AXIS_CHILD: AXIS_CHILD,
      AXIS_FOLLOWING: AXIS_FOLLOWING,
      AXIS_FOLLOWING_SIBLING: AXIS_FOLLOWING_SIBLING,
      AXIS_PRECEDING: AXIS_PRECEDING,
      AXIS_PRECEDING_SIBLING: AXIS_PRECEDING_SIBLING,
      INSERT_BEGIN: INSERT_BEGIN,
      INSERT_END: INSERT_END,
      INSERT_BEFORE: INSERT_BEFORE,
      INSERT_AFTER: INSERT_AFTER,
      TreeWalker: TreeWalker,
      outerHTML: outerHTML,
      textContent: textContent,
      get: get,
      tag: tag,
      axis: axis,
      findAncestor: findAncestor,
      createElement: createElement,
      createText: createText,
      createFragment: createFragment,
      insert: insert,
      remove: remove,
      replace: replace,
      swap: swap,
      clone: clone,
      clear: clear,
      wrap: wrap,
      setAttribute: setAttribute,
      parentOf: parentOf,
      isInside: isInside,
      focus: focus,
      setSelectionRange: setSelectionRange,
      getSelectionStart: getSelectionStart,
      getSelectionEnd: getSelectionEnd
    };
  },
  "6.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./2.js");
    var namespace = this.path;
    var Class = basis.Class;
    var cleaner = basis.cleaner;
    var path = basis.path;
    var arraySearch = basis.array.search;
    var arrayAdd = basis.array.add;
    var arrayRemove = basis.array.remove;
    var templateList = [];
    var tmplFilesMap = {};
    var DECLARATION_VERSION = 2;
    var TYPE_ELEMENT = 1;
    var TYPE_ATTRIBUTE = 2;
    var TYPE_ATTRIBUTE_CLASS = 4;
    var TYPE_ATTRIBUTE_STYLE = 5;
    var TYPE_ATTRIBUTE_EVENT = 6;
    var TYPE_TEXT = 3;
    var TYPE_COMMENT = 8;
    var TOKEN_TYPE = 0;
    var TOKEN_BINDINGS = 1;
    var TOKEN_REFS = 2;
    var ATTR_NAME = 3;
    var ATTR_VALUE = 4;
    var ATTR_EVENT_RX = /^event-(.+)$/;
    var ATTR_NAME_BY_TYPE = {
      4: "class",
      5: "style"
    };
    var ATTR_TYPE_BY_NAME = {
      "class": TYPE_ATTRIBUTE_CLASS,
      style: TYPE_ATTRIBUTE_STYLE
    };
    var ATTR_VALUE_INDEX = {
      2: ATTR_VALUE,
      4: ATTR_VALUE - 1,
      5: ATTR_VALUE - 1,
      6: 2
    };
    var ELEMENT_NAME = 3;
    var ELEMENT_ATTRS = 4;
    var ELEMENT_CHILDS = 5;
    var TEXT_VALUE = 3;
    var COMMENT_VALUE = 3;
    var SYNTAX_ERROR = "Invalid or unsupported syntax";
    var TEXT = /((?:.|[\r\n])*?)(\{(?:l10n:([a-zA-Z_][a-zA-Z0-9_\-]*(?:\.[a-zA-Z_][a-zA-Z0-9_\-]*)*(?:\.\{[a-zA-Z_][a-zA-Z0-9_\-]*\})?)\})?|<(\/|!--(\s*\{)?)?|$)/g;
    var TAG_NAME = /([a-z_][a-z0-9\-_]*)(:|\{|\s*(\/?>)?)/ig;
    var ATTRIBUTE_NAME_OR_END = /([a-z_][a-z0-9_\-]*)(:|\{|=|\s*)|(\/?>)/ig;
    var COMMENT = /(.|[\r\n])*?-->/g;
    var CLOSE_TAG = /([a-z_][a-z0-9_\-]*(?::[a-z_][a-z0-9_\-]*)?)>/ig;
    var REFERENCE = /([a-z_][a-z0-9_]*)(\||\}\s*)/ig;
    var ATTRIBUTE_VALUE = /"((?:(\\")|[^"])*?)"\s*/g;
    var BREAK_TAG_PARSE = /^/g;
    var SINGLETON_TAG = /^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)$/i;
    var TAG_IGNORE_CONTENT = {
      text: /((?:.|[\r\n])*?)(?:<\/b:text>|$)/g,
      style: /((?:.|[\r\n])*?)(?:<\/b:style>|$)/g
    };
    var CSS_CLASSNAME_START = /^\-?([_a-z]|[^\x00-\xb1]|\\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?|\\[^\n\r\f0-9a-f])/i;
    var CSS_CLASSNAME_START_MAXLEN = 8;
    var CSS_NESTED_ATRULE = /^(media|supports|document)\b/i;
    var CSS_NESTED_ATRULE_MAXLEN = 8;
    var CSS_FNSELECTOR = /^(not|has|matches|nth-child|nth-last-child)\(/i;
    var CSS_FNSELECTOR_MAXLEN = 15;
    var quoteUnescape = /\\"/g;
    var tokenize = function(source) {
      var result = [];
      var tagStack = [];
      var lastTag = {
        childs: result
      };
      var sourceText;
      var token;
      var bufferPos;
      var startPos;
      var parseTag = false;
      var textStateEndPos = 0;
      var textEndPos;
      var state = TEXT;
      var pos = 0;
      var m;
      source = source.trim();
      result.warns = [];
      while (pos < source.length || state != TEXT) {
        state.lastIndex = pos;
        startPos = pos;
        m = state.exec(source);
        if (!m || m.index !== pos) {
          if (state == REFERENCE && token && token.type == TYPE_COMMENT) {
            state = COMMENT;
            continue;
          }
          if (parseTag) lastTag = tagStack.pop();
          if (token) lastTag.childs.pop();
          if (token = lastTag.childs.pop()) {
            if (token.type == TYPE_TEXT && !token.refs) textStateEndPos -= "len" in token ? token.len : token.value.length; else lastTag.childs.push(token);
          }
          parseTag = false;
          state = TEXT;
          continue;
        }
        pos = state.lastIndex;
        switch (state) {
          case TEXT:
            textEndPos = startPos + m[1].length;
            if (textStateEndPos != textEndPos) {
              sourceText = textStateEndPos == startPos ? m[1] : source.substring(textStateEndPos, textEndPos);
              token = sourceText.replace(/\s*(\r\n?|\n\r?)\s*/g, "");
              if (token) lastTag.childs.push({
                type: TYPE_TEXT,
                len: sourceText.length,
                value: token
              });
            }
            textStateEndPos = textEndPos;
            if (m[3]) {
              lastTag.childs.push({
                type: TYPE_TEXT,
                refs: [ "l10n:" + m[3] ],
                value: "{l10n:" + m[3] + "}"
              });
            } else if (m[2] == "{") {
              bufferPos = pos - 1;
              lastTag.childs.push(token = {
                type: TYPE_TEXT
              });
              state = REFERENCE;
            } else if (m[4]) {
              if (m[4] == "/") {
                token = null;
                state = CLOSE_TAG;
              } else {
                lastTag.childs.push(token = {
                  type: TYPE_COMMENT
                });
                if (m[5]) {
                  bufferPos = pos - m[5].length;
                  state = REFERENCE;
                } else {
                  bufferPos = pos;
                  state = COMMENT;
                }
              }
            } else if (m[2]) {
              parseTag = true;
              tagStack.push(lastTag);
              lastTag.childs.push(token = {
                type: TYPE_ELEMENT,
                attrs: [],
                childs: []
              });
              lastTag = token;
              state = TAG_NAME;
            }
            break;
          case CLOSE_TAG:
            if (m[1] !== (lastTag.prefix ? lastTag.prefix + ":" : "") + lastTag.name) {
              lastTag.childs.push({
                type: TYPE_TEXT,
                value: "</" + m[0]
              });
            } else lastTag = tagStack.pop();
            state = TEXT;
            break;
          case TAG_NAME:
          case ATTRIBUTE_NAME_OR_END:
            if (m[2] == ":") {
              if (token.prefix) state = BREAK_TAG_PARSE; else token.prefix = m[1];
              break;
            }
            if (m[1]) {
              token.name = m[1];
              if (token.type == TYPE_ATTRIBUTE) lastTag.attrs.push(token);
            }
            if (m[2] == "{") {
              if (token.type == TYPE_ELEMENT) state = REFERENCE; else state = BREAK_TAG_PARSE;
              break;
            }
            if (m[3]) {
              parseTag = false;
              if (m[3] == "/>" || !lastTag.prefix && SINGLETON_TAG.test(lastTag.name)) {
                if (m[3] != "/>") result.warns.push("Tag <" + lastTag.name + "> doesn't closed explicit (use `/>` as tag ending)");
                lastTag = tagStack.pop();
              } else {
                if (lastTag.prefix == "b" && lastTag.name in TAG_IGNORE_CONTENT) {
                  state = TAG_IGNORE_CONTENT[lastTag.name];
                  break;
                }
              }
              state = TEXT;
              break;
            }
            if (m[2] == "=") {
              state = ATTRIBUTE_VALUE;
              break;
            }
            token = {
              type: TYPE_ATTRIBUTE
            };
            state = ATTRIBUTE_NAME_OR_END;
            break;
          case COMMENT:
            token.value = source.substring(bufferPos, pos - 3);
            state = TEXT;
            break;
          case REFERENCE:
            if (token.refs) token.refs.push(m[1]); else token.refs = [ m[1] ];
            if (m[2] != "|") {
              if (token.type == TYPE_TEXT) {
                pos -= m[2].length - 1;
                token.value = source.substring(bufferPos, pos);
                state = TEXT;
              } else if (token.type == TYPE_COMMENT) {
                state = COMMENT;
              } else if (token.type == TYPE_ATTRIBUTE && source[pos] == "=") {
                pos++;
                state = ATTRIBUTE_VALUE;
              } else {
                token = {
                  type: TYPE_ATTRIBUTE
                };
                state = ATTRIBUTE_NAME_OR_END;
              }
            }
            break;
          case ATTRIBUTE_VALUE:
            token.value = m[1].replace(quoteUnescape, '"');
            token = {
              type: TYPE_ATTRIBUTE
            };
            state = ATTRIBUTE_NAME_OR_END;
            break;
          case TAG_IGNORE_CONTENT.text:
          case TAG_IGNORE_CONTENT.style:
            lastTag.childs.push({
              type: TYPE_TEXT,
              value: m[1]
            });
            lastTag = tagStack.pop();
            state = TEXT;
            break;
          default:
            throw "Parser bug";
        }
        if (state == TEXT) textStateEndPos = pos;
      }
      if (textStateEndPos != pos) lastTag.childs.push({
        type: TYPE_TEXT,
        value: source.substring(textStateEndPos, pos)
      });
      if (lastTag.name) result.warns.push("No close tag for <" + lastTag.name + ">");
      if (!result.warns.length) delete result.warns;
      result.templateTokens = true;
      return result;
    };
    var tokenTemplate = {};
    var L10nProxyToken = basis.Token.subclass({
      className: namespace + ".L10nProxyToken",
      token: null,
      url: "",
      init: function(token) {
        this.url = token.dictionary.resource.url + ":" + token.name;
        this.token = token;
        this.set();
        token.attach(this.set, this);
      },
      set: function() {
        return basis.Token.prototype.set.call(this, this.token.type == "markup" ? processMarkup(this.token.value, this.token.name + "@" + this.token.dictionary.resource.url) : "");
      },
      destroy: function() {
        basis.Token.prototype.destroy.call(this);
        this.token = null;
      }
    });
    function processMarkup(value, id) {
      return '<span class="basisjs-markup" data-basisjs-l10n="' + id + '">' + String(value) + "</span>";
    }
    function getL10nTemplate(token) {
      if (typeof token == "string") token = basis.l10n.token(token);
      if (!token) return null;
      var id = token.basisObjectId;
      var template = tokenTemplate[id];
      if (!template) template = tokenTemplate[id] = new Template(new L10nProxyToken(token));
      return template;
    }
    function genIsolateMarker() {
      return "i" + basis.genUID() + "__";
    }
    function isolateCss(css, prefix) {
      function jumpAfter(str, offset) {
        var index = css.indexOf(str, offset);
        i = index !== -1 ? index + str.length : sym.length;
      }
      function parseString(endSym) {
        var quote = sym[i];
        if (quote !== '"' && quote !== "'") return;
        for (i++; i < len && sym[i] !== quote; i++) if (sym[i] === "\\") i++;
        return true;
      }
      function parseBraces(endSym) {
        var bracket = sym[i];
        if (bracket === "(") {
          jumpAfter(")", i + 1);
          return true;
        }
        if (bracket === "[") {
          for (i++; i < len && sym[i] !== "]"; i++) parseString();
          return true;
        }
      }
      function parseComment() {
        if (sym[i] !== "/" || sym[i + 1] !== "*") return;
        jumpAfter("*/", i + 2);
        return true;
      }
      function parsePseudoContent() {
        for (; i < len && sym[i] != ")"; i++) if (parseComment() || parseBraces() || parsePseudo() || parseClassName()) continue;
      }
      function parsePseudo() {
        if (sym[i] !== ":") return;
        var m = css.substr(i + 1, CSS_FNSELECTOR_MAXLEN).match(CSS_FNSELECTOR);
        if (m) {
          i += m[0].length + 1;
          parsePseudoContent();
        }
        return true;
      }
      function parseAtRule() {
        if (sym[i] !== "@") return;
        var m = css.substr(i + 1, CSS_NESTED_ATRULE_MAXLEN).match(CSS_NESTED_ATRULE);
        if (m) {
          i += m[0].length;
          nestedStyleSheet = true;
        }
        return true;
      }
      function parseBlock() {
        if (sym[i] !== "{") return;
        if (nestedStyleSheet) {
          i++;
          parseStyleSheet(true);
          return;
        }
        for (i++; i < len && sym[i] !== "}"; i++) parseString() || parseBraces();
        return true;
      }
      function parseClassName() {
        if (sym[i] !== ".") return;
        var m = css.substr(i + 1, CSS_CLASSNAME_START_MAXLEN).match(CSS_CLASSNAME_START);
        if (m) {
          i++;
          result.push(css.substring(lastMatchPos, i), prefix);
          lastMatchPos = i;
        }
        return true;
      }
      function parseStyleSheet(nested) {
        for (nestedStyleSheet = false; i < len; i++) {
          if (parseComment() || parseAtRule() || parsePseudo() || parseBraces() || parseClassName()) continue;
          if (nested && sym[i] == "}") return;
          parseBlock();
        }
      }
      var result = [];
      var sym = css.split("");
      var len = sym.length;
      var lastMatchPos = 0;
      var i = 0;
      var nestedStyleSheet;
      if (!prefix) prefix = genIsolateMarker();
      parseStyleSheet(false);
      return result.join("") + css.substring(lastMatchPos);
    }
    var makeDeclaration = function() {
      var IDENT = /^[a-z_][a-z0-9_\-]*$/i;
      var CLASS_ATTR_PARTS = /(\S+)/g;
      var CLASS_ATTR_BINDING = /^((?:[a-z_][a-z0-9_\-]*)?(?::(?:[a-z_][a-z0-9_\-]*)?)?)\{((anim:)?[a-z_][a-z0-9_\-]*)\}$/i;
      var STYLE_ATTR_PARTS = /\s*[^:]+?\s*:(?:\(.*?\)|".*?"|'.*?'|[^;]+?)+(?:;|$)/gi;
      var STYLE_PROPERTY = /\s*([^:]+?)\s*:((?:\(.*?\)|".*?"|'.*?'|[^;]+?)+);?$/i;
      var STYLE_ATTR_BINDING = /\{([a-z_][a-z0-9_]*)\}/i;
      var ATTR_BINDING = /\{([a-z_][a-z0-9_]*|l10n:[a-z_][a-z0-9_]*(?:\.[a-z_][a-z0-9_]*)*(?:\.\{[a-z_][a-z0-9_]*\})?)\}/i;
      var NAMED_CHARACTER_REF = /&([a-z]+|#[0-9]+|#x[0-9a-f]{1,4});?/gi;
      var tokenMap = basis.NODE_ENV ? __nodejsRequire("./template/htmlentity.json") : {};
      var tokenElement = !basis.NODE_ENV ? document.createElement("div") : null;
      var includeStack = [];
      var styleNamespaceIsolate = {};
      function name(token) {
        return (token.prefix ? token.prefix + ":" : "") + token.name;
      }
      function namedCharReplace(m, token) {
        if (!tokenMap[token]) {
          if (token.charAt(0) == "#") {
            tokenMap[token] = String.fromCharCode(token.charAt(1) == "x" || token.charAt(1) == "X" ? parseInt(token.substr(2), 16) : token.substr(1));
          } else {
            if (tokenElement) {
              tokenElement.innerHTML = m;
              tokenMap[token] = tokenElement.firstChild ? tokenElement.firstChild.nodeValue : m;
            }
          }
        }
        return tokenMap[token] || m;
      }
      function untoken(value) {
        return value.replace(NAMED_CHARACTER_REF, namedCharReplace);
      }
      function refList(token) {
        var array = token.refs;
        if (!array || !array.length) return 0;
        return array;
      }
      function buildAttrExpression(parts) {
        var bindName;
        var names = [];
        var expression = [];
        var map = {};
        for (var j = 0; j < parts.length; j++) if (j % 2) {
          bindName = parts[j];
          if (!map[bindName]) {
            map[bindName] = names.length;
            names.push(bindName);
          }
          expression.push(map[bindName]);
        } else {
          if (parts[j]) expression.push(untoken(parts[j]));
        }
        return [ names, expression ];
      }
      function processAttr(name, value) {
        var bindings = 0;
        var parts;
        var m;
        if (value) {
          switch (name) {
            case "class":
              if (parts = value.match(CLASS_ATTR_PARTS)) {
                var newValue = [];
                bindings = [];
                for (var j = 0, part; part = parts[j]; j++) {
                  if (m = part.match(CLASS_ATTR_BINDING)) bindings.push([ m[1] || "", m[2] ]); else newValue.push(part);
                }
                value = newValue.join(" ");
              }
              break;
            case "style":
              var props = [];
              bindings = [];
              if (parts = value.match(STYLE_ATTR_PARTS)) {
                for (var j = 0, part; part = parts[j]; j++) {
                  var m = part.match(STYLE_PROPERTY);
                  var propertyName = m[1];
                  var value = m[2].trim();
                  var valueParts = value.split(STYLE_ATTR_BINDING);
                  if (valueParts.length > 1) {
                    var expr = buildAttrExpression(valueParts);
                    expr.push(propertyName);
                    bindings.push(expr);
                  } else props.push(propertyName + ": " + untoken(value));
                }
              } else {
                if (/\S/.test(value)) basis.dev.warn("Bad value for style attribute (value ignored):", value);
              }
              value = props.join("; ");
              if (value) value += ";";
              break;
            default:
              parts = value.split(ATTR_BINDING);
              if (parts.length > 1) bindings = buildAttrExpression(parts); else value = untoken(value);
          }
        }
        if (bindings && !bindings.length) bindings = 0;
        return {
          binding: bindings,
          value: value,
          type: ATTR_TYPE_BY_NAME[name] || 2
        };
      }
      function attrs(token, declToken, optimizeSize) {
        var attrs = token.attrs;
        var result = [];
        var styleAttr;
        var display;
        var m;
        for (var i = 0, attr; attr = attrs[i]; i++) {
          if (attr.prefix == "b") {
            switch (attr.name) {
              case "ref":
                var refs = (attr.value || "").trim().split(/\s+/);
                for (var j = 0; j < refs.length; j++) addTokenRef(declToken, refs[j]);
                break;
              case "show":
              case "hide":
                display = attr;
                break;
            }
            continue;
          }
          if (m = attr.name.match(ATTR_EVENT_RX)) {
            result.push(m[1] == attr.value ? [ TYPE_ATTRIBUTE_EVENT, m[1] ] : [ TYPE_ATTRIBUTE_EVENT, m[1], attr.value ]);
            continue;
          }
          var parsed = processAttr(attr.name, attr.value);
          var item = [ parsed.type, parsed.binding, refList(attr) ];
          if (parsed.type == 2) item.push(name(attr));
          if (parsed.value && (!optimizeSize || !parsed.binding || parsed.type != 2)) item.push(parsed.value);
          if (parsed.type == TYPE_ATTRIBUTE_STYLE) styleAttr = item;
          result.push(item);
        }
        if (display) {
          if (!styleAttr) {
            styleAttr = [ TYPE_ATTRIBUTE_STYLE, 0, 0 ];
            result.push(styleAttr);
          }
          if (!styleAttr[1]) styleAttr[1] = [];
          var displayExpr = buildAttrExpression((display.value || display.name).split(ATTR_BINDING));
          if (displayExpr[0].length - displayExpr[1].length) {
            styleAttr[3] = (styleAttr[3] ? styleAttr[3] + "; " : "") + (display.name == "show" ^ display.value === "" ? "" : "display: none");
          } else {
            if (display.name == "show") styleAttr[3] = (styleAttr[3] ? styleAttr[3] + "; " : "") + "display: none";
            styleAttr[1].push(displayExpr.concat("display", display.name));
          }
        }
        return result.length ? result : 0;
      }
      function addTokenRef(token, refName) {
        if (!token[TOKEN_REFS]) token[TOKEN_REFS] = [];
        arrayAdd(token[TOKEN_REFS], refName);
        if (refName != "element") token[TOKEN_BINDINGS] = token[TOKEN_REFS].length == 1 ? refName : 0;
      }
      function removeTokenRef(token, refName) {
        var idx = token[TOKEN_REFS].indexOf(refName);
        if (idx != -1) {
          var indexBinding = token[TOKEN_BINDINGS] && typeof token[TOKEN_BINDINGS] == "number";
          token[TOKEN_REFS].splice(idx, 1);
          if (indexBinding) if (idx == token[TOKEN_BINDINGS] - 1) token[TOKEN_BINDINGS] = refName;
          if (!token[TOKEN_REFS].length) token[TOKEN_REFS] = 0; else {
            if (indexBinding) token[TOKEN_BINDINGS] -= idx < token[TOKEN_BINDINGS] - 1;
          }
        }
      }
      function tokenAttrs(token) {
        var result = {};
        if (token.attrs) for (var i = 0, attr; attr = token.attrs[i]; i++) result[name(attr)] = attr.value;
        return result;
      }
      function addUnique(array, items) {
        for (var i = 0; i < items.length; i++) arrayAdd(array, items[i]);
      }
      function addStyles(array, items, prefix) {
        for (var i = 0, item; item = items[i]; i++) if (item[1] !== styleNamespaceIsolate) item[1] = prefix + item[1];
        array.unshift.apply(array, items);
      }
      function addStyle(template, token, src, isolatePrefix) {
        var url;
        if (src) {
          if (!/^(\.\/|\.\.|\/)/.test(src)) basis.dev.warn("Bad usage: <b:" + token.name + ' src="' + src + '"/>.\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.');
          url = path.resolve(template.baseURI + src);
        } else {
          var text = token.childs[0];
          url = basis.resource.virtual("css", text ? text.value : "", template.sourceUrl).url;
        }
        template.resources.push([ url, isolatePrefix ]);
        return url;
      }
      function process(tokens, template, options, context) {
        function modifyAttr(token, name, action) {
          var attrs = tokenAttrs(token);
          if (name) attrs.name = name;
          if (!attrs.name) {
            template.warns.push("Instruction <b:" + token.name + "> has no attribute name");
            return;
          }
          if (!IDENT.test(attrs.name)) {
            template.warns.push("Bad attribute name `" + attrs.name + "`");
            return;
          }
          var includedToken = tokenRefMap[attrs.ref || "element"];
          if (includedToken) {
            if (includedToken.token[TOKEN_TYPE] == TYPE_ELEMENT) {
              var itAttrs = includedToken.token;
              var isEvent = attrs.name.match(ATTR_EVENT_RX);
              var itType = isEvent ? TYPE_ATTRIBUTE_EVENT : ATTR_TYPE_BY_NAME[attrs.name] || TYPE_ATTRIBUTE;
              var valueIdx = ATTR_VALUE_INDEX[itType] || ATTR_VALUE;
              var itAttrToken = itAttrs && arraySearch(itAttrs, attrs.name, function(token) {
                if (token[TOKEN_TYPE] == TYPE_ATTRIBUTE_EVENT) return "event-" + token[1];
                return ATTR_NAME_BY_TYPE[token[TOKEN_TYPE]] || token[ATTR_NAME];
              }, ELEMENT_ATTRS);
              if (!itAttrToken && action != "remove") {
                if (isEvent) {
                  itAttrToken = [ itType, isEvent[1] ];
                } else {
                  itAttrToken = [ itType, 0, 0, itType == TYPE_ATTRIBUTE ? attrs.name : "" ];
                  if (itType == TYPE_ATTRIBUTE) itAttrToken.push("");
                }
                if (!itAttrs) {
                  itAttrs = [];
                  includedToken.token.push(itAttrs);
                }
                itAttrs.push(itAttrToken);
              }
              var classOrStyle = attrs.name == "class" || attrs.name == "style";
              switch (action) {
                case "set":
                  if (itAttrToken[TOKEN_TYPE] == TYPE_ATTRIBUTE_EVENT) {
                    if (attrs.value == isEvent[1]) itAttrToken.length = 2; else itAttrToken[valueIdx] = attrs.value;
                    return;
                  }
                  var parsed = processAttr(attrs.name, attrs.value);
                  itAttrToken[TOKEN_BINDINGS] = parsed.binding;
                  if (!options.optimizeSize || !itAttrToken[TOKEN_BINDINGS] || classOrStyle) itAttrToken[valueIdx] = parsed.value || ""; else itAttrToken.length = valueIdx;
                  if (classOrStyle) if (!itAttrToken[TOKEN_BINDINGS] && !itAttrToken[valueIdx]) {
                    arrayRemove(itAttrs, itAttrToken);
                    return;
                  }
                  break;
                case "append":
                  var parsed = processAttr(attrs.name, attrs.value);
                  if (!isEvent) {
                    if (parsed.binding) {
                      var attrBindings = itAttrToken[TOKEN_BINDINGS];
                      if (attrBindings) {
                        switch (attrs.name) {
                          case "style":
                            var oldBindingMap = {};
                            for (var i = 0, oldBinding; oldBinding = attrBindings[i]; i++) oldBindingMap[oldBinding[2]] = i;
                            for (var i = 0, newBinding; newBinding = parsed.binding[i]; i++) if (newBinding[2] in oldBindingMap) attrBindings[oldBindingMap[newBinding[2]]] = newBinding; else attrBindings.push(newBinding);
                            break;
                          case "class":
                            attrBindings.push.apply(attrBindings, parsed.binding);
                            break;
                          default:
                            parsed.binding[0].forEach(function(name) {
                              arrayAdd(this, name);
                            }, attrBindings[0]);
                            for (var i = 0; i < parsed.binding[1].length; i++) {
                              var value = parsed.binding[1][i];
                              if (typeof value == "number") value = attrBindings[0].indexOf(parsed.binding[0][value]);
                              attrBindings[1].push(value);
                            }
                        }
                      } else {
                        itAttrToken[TOKEN_BINDINGS] = parsed.binding;
                        if (!classOrStyle) itAttrToken[TOKEN_BINDINGS][1].unshift(itAttrToken[valueIdx]);
                      }
                    } else {
                      if (!classOrStyle && itAttrToken[TOKEN_BINDINGS]) itAttrToken[TOKEN_BINDINGS][1].push(attrs.value);
                    }
                  }
                  if (parsed.value) itAttrToken[valueIdx] = (itAttrToken[valueIdx] || "") + (itAttrToken[valueIdx] && (isEvent || classOrStyle) ? " " : "") + parsed.value;
                  if (classOrStyle) if (!itAttrToken[TOKEN_BINDINGS] && !itAttrToken[valueIdx]) {
                    arrayRemove(itAttrs, itAttrToken);
                    return;
                  }
                  break;
                case "remove":
                  if (itAttrToken) arrayRemove(itAttrs, itAttrToken);
                  break;
              }
            } else {
              template.warns.push("Attribute modificator is not reference to element token (reference name: " + (attrs.ref || "element") + ")");
            }
          }
        }
        var result = [];
        for (var i = 0, token, item; token = tokens[i]; i++) {
          var refs = refList(token);
          var bindings = refs && refs.length == 1 ? refs[0] : 0;
          switch (token.type) {
            case TYPE_ELEMENT:
              if (token.prefix == "b") {
                var elAttrs = tokenAttrs(token);
                switch (token.name) {
                  case "style":
                    var styleNamespace = elAttrs.namespace || elAttrs.ns;
                    var styleIsolate = styleNamespace ? styleNamespaceIsolate : context && context.isolate || "";
                    var src = addStyle(template, token, elAttrs.src, styleIsolate);
                    if (styleNamespace) {
                      if (src in styleNamespaceIsolate == false) styleNamespaceIsolate[src] = genIsolateMarker();
                      template.styleNSPrefix[styleNamespace] = styleNamespaceIsolate[src];
                    }
                    break;
                  case "isolate":
                    if (!template.isolate) template.isolate = elAttrs.prefix || options.isolate || genIsolateMarker(); else basis.dev.warn("<b:isolate> is set already to `" + template.isolate + "`");
                    break;
                  case "l10n":
                    if (template.l10nResolved) template.warns.push("<b:l10n> must be declared before any `l10n:` token (instruction ignored)");
                    if (elAttrs.src) {
                      if (!/^(\.\/|\.\.|\/)/.test(elAttrs.src)) basis.dev.warn("Bad usage: <b:" + token.name + ' src="' + elAttrs.src + '"/>.\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.');
                      template.dictURI = path.resolve(template.baseURI, elAttrs.src);
                    }
                    break;
                  case "define":
                    if ("name" in elAttrs && !template.defines[elAttrs.name]) {
                      switch (elAttrs.type) {
                        case "bool":
                          template.defines[elAttrs.name] = [ elAttrs["default"] == "true" ? 1 : 0 ];
                          break;
                        case "enum":
                          var values = elAttrs.values ? elAttrs.values.trim().split(" ") : [];
                          template.defines[elAttrs.name] = [ values.indexOf(elAttrs["default"]) + 1, values ];
                          break;
                        default:
                          template.warns.push("Bad define type `" + elAttrs.type + "` for " + elAttrs.name);
                      }
                    }
                    break;
                  case "text":
                    var text = token.childs[0];
                    tokens[i--] = basis.object.extend(text, {
                      refs: (elAttrs.ref || "").trim().split(/\s+/),
                      value: "notrim" in elAttrs ? text.value : text.value.replace(/^\s*[\r\n]+|[\r\n]\s*$/g, "")
                    });
                    break;
                  case "include":
                    var templateSrc = elAttrs.src;
                    if (templateSrc) {
                      var isTemplateRef = /^#\d+$/.test(templateSrc);
                      var isDocumentIdRef = /^id:/.test(templateSrc);
                      var url = isTemplateRef ? templateSrc.substr(1) : templateSrc;
                      var resource;
                      if (isTemplateRef) {
                        resource = templateList[url];
                      } else if (isDocumentIdRef) {
                        resource = resolveSourceByDocumentId(url.substr(3));
                      } else if (/^[a-z0-9\.]+$/i.test(url) && !/\.tmpl$/.test(url)) {
                        resource = getSourceByPath(url);
                      } else {
                        if (!/^(\.\/|\.\.|\/)/.test(url)) basis.dev.warn('Bad usage: <b:include src="' + url + '"/>.\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.');
                        resource = basis.resource(path.resolve(template.baseURI + url));
                      }
                      if (!resource) {
                        template.warns.push('<b:include src="' + templateSrc + '"> is not resolved, instruction ignored');
                        basis.dev.warn('<b:include src="' + templateSrc + '"> is not resolved, instruction ignored');
                        continue;
                      }
                      if (includeStack.indexOf(resource) == -1) {
                        var isolatePrefix = "isolate" in elAttrs ? elAttrs.isolate || genIsolateMarker() : "";
                        var decl;
                        if (!isDocumentIdRef) arrayAdd(template.deps, resource);
                        if (isTemplateRef) {
                          if (resource.source.bindingBridge) arrayAdd(template.deps, resource.source);
                          decl = getDeclFromSource(resource.source, resource.baseURI, true, options);
                        } else {
                          decl = getDeclFromSource(resource, resource.url ? path.dirname(resource.url) + "/" : "", true, options);
                        }
                        if (decl.resources && "no-style" in elAttrs == false) addStyles(template.resources, decl.resources, isolatePrefix);
                        if (decl.deps) addUnique(template.deps, decl.deps);
                        if (decl.l10n) addUnique(template.l10n, decl.l10n);
                        var tokenRefMap = normalizeRefs(decl.tokens);
                        var instructions = (token.childs || []).slice();
                        var styleNSPrefixMap = basis.object.slice(decl.styleNSPrefix);
                        if (elAttrs["class"]) instructions.push({
                          type: TYPE_ELEMENT,
                          prefix: "b",
                          name: "append-class",
                          attrs: [ {
                            type: TYPE_ATTRIBUTE,
                            name: "value",
                            value: elAttrs["class"]
                          } ]
                        });
                        if (elAttrs.id) instructions.push({
                          type: TYPE_ELEMENT,
                          prefix: "b",
                          name: "set-attr",
                          attrs: [ {
                            type: TYPE_ATTRIBUTE,
                            name: "name",
                            value: "id"
                          }, {
                            type: TYPE_ATTRIBUTE,
                            name: "value",
                            value: elAttrs.id
                          } ]
                        });
                        if (elAttrs.ref) if (tokenRefMap.element) elAttrs.ref.trim().split(/\s+/).map(function(refName) {
                          addTokenRef(tokenRefMap.element.token, refName);
                        });
                        for (var j = 0, child; child = instructions[j]; j++) {
                          if (child.type == TYPE_ELEMENT && child.prefix == "b") {
                            switch (child.name) {
                              case "style":
                                var childAttrs = tokenAttrs(child);
                                var styleNamespace = childAttrs.namespace || childAttrs.ns;
                                var styleIsolate = styleNamespace ? styleNamespaceIsolate : isolatePrefix;
                                var src = addStyle(template, child, childAttrs.src, styleIsolate);
                                if (styleNamespace) {
                                  if (src in styleNamespaceIsolate == false) styleNamespaceIsolate[src] = genIsolateMarker();
                                  styleNSPrefixMap[styleNamespace] = styleNamespaceIsolate[src];
                                }
                                break;
                              case "replace":
                              case "remove":
                              case "before":
                              case "after":
                                var replaceOrRemove = child.name == "replace" || child.name == "remove";
                                var childAttrs = tokenAttrs(child);
                                var ref = "ref" in childAttrs || !replaceOrRemove ? childAttrs.ref : "element";
                                var tokenRef = ref && tokenRefMap[ref];
                                if (tokenRef) {
                                  var pos = tokenRef.owner.indexOf(tokenRef.token);
                                  if (pos != -1) {
                                    var args = [ pos + (child.name == "after"), replaceOrRemove ];
                                    if (child.name != "remove") args = args.concat(process(child.childs, template, options) || []);
                                    tokenRef.owner.splice.apply(tokenRef.owner, args);
                                  }
                                }
                                break;
                              case "prepend":
                              case "append":
                                var childAttrs = tokenAttrs(child);
                                var ref = "ref" in childAttrs ? childAttrs.ref : "element";
                                var tokenRef = ref && tokenRefMap[ref];
                                var token = tokenRef && tokenRef.token;
                                if (token && token[TOKEN_TYPE] == TYPE_ELEMENT) {
                                  var childs = process(child.childs, template, options) || [];
                                  if (child.name == "prepend") token.splice.apply(token, [ ELEMENT_ATTRS, 0 ].concat(childs)); else token.push.apply(token, childs);
                                }
                                break;
                              case "attr":
                              case "set-attr":
                                modifyAttr(child, false, "set");
                                break;
                              case "append-attr":
                                modifyAttr(child, false, "append");
                                break;
                              case "remove-attr":
                                modifyAttr(child, false, "remove");
                                break;
                              case "class":
                              case "append-class":
                                modifyAttr(child, "class", "append");
                                break;
                              case "set-class":
                                modifyAttr(child, "class", "set");
                                break;
                              case "remove-class":
                                modifyAttr(child, "class", "remove");
                                break;
                              case "add-ref":
                                var childAttrs = tokenAttrs(child);
                                var ref = "ref" in childAttrs ? childAttrs.ref : "element";
                                var tokenRef = ref && tokenRefMap[ref];
                                var token = tokenRef && tokenRef.token;
                                if (token && childAttrs.name) addTokenRef(token, childAttrs.name);
                                break;
                              case "remove-ref":
                                var childAttrs = tokenAttrs(child);
                                var ref = "ref" in childAttrs ? childAttrs.ref : "element";
                                var tokenRef = ref && tokenRefMap[ref];
                                var token = tokenRef && tokenRef.token;
                                if (token) removeTokenRef(token, childAttrs.name || childAttrs.ref);
                                break;
                              default:
                                template.warns.push("Unknown instruction tag <b:" + child.name + ">");
                            }
                          } else decl.tokens.push.apply(decl.tokens, process([ child ], template, options) || []);
                        }
                        if (tokenRefMap.element) removeTokenRef(tokenRefMap.element.token, "element");
                        basis.object.complete(template.styleNSPrefix, styleNSPrefixMap);
                        if (isolatePrefix) isolateTokens(decl.tokens, isolatePrefix); else if (decl.isolate && !template.isolate) template.isolate = options.isolate || genIsolateMarker();
                        result.push.apply(result, decl.tokens);
                      } else {
                        var stack = includeStack.slice(includeStack.indexOf(resource) || 0).concat(resource).map(function(res) {
                          if (res instanceof Template) res = res.source;
                          if (res instanceof L10nProxyToken) return "{l10n:" + res.token.name + "@" + res.token.dictionary.resource.url + "}";
                          return res.url || "[inline template]";
                        });
                        template.warns.push("Recursion: ", stack.join(" -> "));
                        basis.dev.warn("Recursion in template: ", stack.join(" -> "));
                      }
                    }
                    break;
                }
                continue;
              }
              item = [ 1, bindings, refs, name(token) ];
              item.push.apply(item, attrs(token, item, options.optimizeSize) || []);
              item.push.apply(item, process(token.childs, template, options) || []);
              break;
            case TYPE_TEXT:
              if (refs && refs.length == 2 && arraySearch(refs, "element")) bindings = refs[+!refs.lastSearchIndex];
              if (bindings) {
                var l10nBinding = absl10n(bindings, template.dictURI);
                var parts = l10nBinding.split(/[:@\{]/);
                if (parts[0] == "l10n" && parts.length == 3) {
                  if (!parts[2]) {
                    arrayRemove(refs, bindings);
                    if (refs.length == 0) refs = null;
                    bindings = 0;
                    token.value = token.value.replace(/\}$/, "@undefined}");
                  } else {
                    var l10nId = parts.slice(1).join("@");
                    var l10nToken = basis.l10n.token(l10nId);
                    var l10nTemplate = getL10nTemplate(l10nToken);
                    template.l10nResolved = true;
                    if (l10nTemplate && l10nToken.type == "markup") {
                      tokens[i--] = tokenize('<b:include src="#' + l10nTemplate.templateId + '"/>')[0];
                      continue;
                    } else arrayAdd(template.l10n, l10nId);
                  }
                }
              }
              item = [ 3, bindings, refs ];
              if (!refs || token.value != "{" + refs.join("|") + "}") item.push(untoken(token.value));
              break;
            case TYPE_COMMENT:
              if (options.optimizeSize && !bindings && !refs) continue;
              item = [ 8, bindings, refs ];
              if (!options.optimizeSize) if (!refs || token.value != "{" + refs.join("|") + "}") item.push(untoken(token.value));
              break;
          }
          while (item[item.length - 1] === 0) item.pop();
          result.push(item);
        }
        return result.length ? result : 0;
      }
      function absl10n(value, dictURI) {
        if (typeof value != "string") return value;
        var parts = value.split(":");
        if (parts.length == 2 && parts[0] == "l10n" && parts[1].indexOf("@") == -1) parts[1] = parts[1] + "@" + dictURI;
        return parts.join(":");
      }
      function normalizeRefs(tokens, dictURI, map, stIdx) {
        if (!map) map = {};
        for (var i = stIdx || 0, token; token = tokens[i]; i++) {
          if (token[TOKEN_TYPE] == TYPE_ATTRIBUTE_EVENT) continue;
          var refs = token[TOKEN_REFS];
          if (refs) {
            for (var j = refs.length - 1, refName; refName = refs[j]; j--) {
              if (refName.indexOf(":") != -1) {
                removeTokenRef(token, refName);
                continue;
              }
              if (map[refName]) removeTokenRef(map[refName].token, refName);
              if (token[TOKEN_BINDINGS] == refName) token[TOKEN_BINDINGS] = j + 1;
              map[refName] = {
                owner: tokens,
                token: token
              };
            }
          }
          switch (token[TOKEN_TYPE]) {
            case TYPE_TEXT:
              token[TOKEN_BINDINGS] = absl10n(token[TOKEN_BINDINGS], dictURI);
              break;
            case TYPE_ATTRIBUTE:
              if (token[TOKEN_BINDINGS]) {
                var array = token[TOKEN_BINDINGS][0];
                for (var j = 0; j < array.length; j++) array[j] = absl10n(array[j], dictURI);
              }
              break;
            case TYPE_ELEMENT:
              normalizeRefs(token, dictURI, map, ELEMENT_ATTRS);
              break;
          }
        }
        return map;
      }
      function applyDefines(tokens, template, options, stIdx) {
        var unpredictable = 0;
        for (var i = stIdx || 0, token; token = tokens[i]; i++) {
          var tokenType = token[TOKEN_TYPE];
          if (tokenType == TYPE_ELEMENT) unpredictable += applyDefines(token, template, options, ELEMENT_ATTRS);
          if (tokenType == TYPE_ATTRIBUTE_CLASS || tokenType == TYPE_ATTRIBUTE && token[ATTR_NAME] == "class") {
            var bindings = token[TOKEN_BINDINGS];
            var valueIdx = ATTR_VALUE_INDEX[tokenType];
            if (bindings) {
              var newAttrValue = (token[valueIdx] || "").trim().split(" ");
              for (var k = 0, bind; bind = bindings[k]; k++) {
                if (bind.length > 2) continue;
                var bindName = bind[1].split(":").pop();
                var bindDef = template.defines[bindName];
                if (bindDef) {
                  bind.push.apply(bind, bindDef);
                  bindDef.used = true;
                  if (bindDef[0]) {
                    if (bindDef.length == 1) arrayAdd(newAttrValue, bind[0] + bindName); else arrayAdd(newAttrValue, bind[0] + bindDef[1][bindDef[0] - 1]);
                  }
                } else {
                  template.warns.push("Unpredictable value `" + bindName + "` in class binding: " + bind[0] + "{" + bind[1] + "}");
                  unpredictable++;
                }
              }
              token[valueIdx] = newAttrValue.join(" ");
              if (options.optimizeSize && !token[valueIdx]) token.length = valueIdx;
            }
          }
        }
        return unpredictable;
      }
      function isolateTokens(tokens, isolate, template, stIdx) {
        function processName(name) {
          var parts = name.split(":");
          if (parts.length == 1) return isolate + parts[0];
          if (!template) return name;
          if (!parts[0]) return parts[1];
          if (parts[0] in template.styleNSPrefix == false) {
            template.warns.push("Namespace `" + parts[0] + "` is not defined in template, no prefix added");
            return name;
          }
          return template.styleNSPrefix[parts[0]] + parts[1];
        }
        for (var i = stIdx || 0, token; token = tokens[i]; i++) {
          var tokenType = token[TOKEN_TYPE];
          if (tokenType == TYPE_ELEMENT) isolateTokens(token, isolate, template, ELEMENT_ATTRS);
          if (tokenType == TYPE_ATTRIBUTE_CLASS || tokenType == TYPE_ATTRIBUTE && token[ATTR_NAME] == "class") {
            var bindings = token[TOKEN_BINDINGS];
            var valueIndex = ATTR_VALUE_INDEX[tokenType];
            if (token[valueIndex]) token[valueIndex] = token[valueIndex].split(/\s+/).map(processName).join(" ");
            if (bindings) for (var k = 0, bind; bind = bindings[k]; k++) bind[0] = processName(bind[0]);
          }
        }
      }
      return function makeDeclaration(source, baseURI, options, sourceUrl, sourceOrigin) {
        options = options || {};
        var warns = [];
        var source_;
        var result = {
          sourceUrl: sourceUrl,
          baseURI: baseURI || "",
          tokens: null,
          resources: [],
          styleNSPrefix: {},
          deps: [],
          l10n: [],
          defines: {},
          unpredictable: true,
          warns: warns,
          isolate: false
        };
        result.dictURI = sourceUrl ? basis.path.resolve(sourceUrl) : baseURI || "";
        if (result.dictURI) {
          var extname = basis.path.extname(result.dictURI);
          if (extname && extname != ".l10n") result.dictURI = result.dictURI.substr(0, result.dictURI.length - extname.length) + ".l10n";
        }
        if (!source.templateTokens) {
          source_ = source;
          source = tokenize(String(source));
        }
        if (source.warns) warns.push.apply(warns, source.warns);
        includeStack.push(sourceOrigin !== true && sourceOrigin || {});
        result.tokens = process(source, result, options);
        includeStack.pop();
        if (!result.tokens) result.tokens = [ [ 3, 0, 0, "" ] ];
        if (source_) result.tokens.source_ = source_;
        addTokenRef(result.tokens[0], "element");
        normalizeRefs(result.tokens, result.dictURI);
        result.unpredictable = !!applyDefines(result.tokens, result, options);
        if (/^[^a-z]/i.test(result.isolate)) basis.dev.error("basis.template: isolation prefix `" + result.isolate + "` should not starts with symbol other than letter, otherwise it leads to incorrect css class names and broken styles");
        if (includeStack.length == 0) {
          isolateTokens(result.tokens, result.isolate || "", result);
          if (result.isolate) for (var i = 0, item; item = result.resources[i]; i++) if (item[1] !== styleNamespaceIsolate) item[1] = result.isolate + item[1];
          result.resources = result.resources.filter(function(item, idx, array) {
            return !basis.array.search(array, String(item), String, idx + 1);
          }).map(function(item) {
            var url = item[0];
            var isolate = item[1];
            if (isolate === styleNamespaceIsolate) isolate = styleNamespaceIsolate[url];
            if (!isolate) return url;
            var resource = basis.resource.virtual("css", "").ready(function(cssResource) {
              sourceResource();
              basis.object.extend(cssResource, {
                url: url + "?isolate-prefix=" + isolate,
                baseURI: basis.path.dirname(url) + "/"
              });
            });
            var sourceResource = basis.resource(url).ready(function(cssResource) {
              var cssText = isolateCss(cssResource.cssText || "", isolate);
              if (typeof btoa == "function") cssText += "\n/*# sourceMappingURL=data:application/json;base64," + btoa('{"version":3,"sources":["' + basis.path.origin + url + '"],' + '"mappings":"AAAA' + basis.string.repeat(";AACA", cssText.split("\n").length) + '"}') + " */";
              resource.update(cssText);
            });
            return resource.url;
          });
        }
        for (var key in result.defines) if (!result.defines[key].used) warns.push("Unused define for " + key);
        delete result.defines;
        delete result.l10nResolved;
        if (!warns.length) result.warns = false;
        return result;
      };
    }();
    function startUseResource(uri) {
      var resource = basis.resource(uri).fetch();
      if (typeof resource.startUse == "function") resource.startUse();
    }
    function stopUseResource(uri) {
      var resource = basis.resource(uri).fetch();
      if (typeof resource.stopUse == "function") resource.stopUse();
    }
    function templateSourceUpdate() {
      if (this.destroyBuilder) buildTemplate.call(this);
      for (var i = 0, attach; attach = this.attaches_[i]; i++) attach.handler.call(attach.context);
    }
    function cloneDecl(array) {
      var result = [];
      if (array.source_) result.source_ = array.source_;
      for (var i = 0; i < array.length; i++) result.push(Array.isArray(array[i]) ? cloneDecl(array[i]) : array[i]);
      return result;
    }
    function getDeclFromSource(source, baseURI, clone, options) {
      var result = source;
      var sourceUrl;
      if (typeof result == "function") {
        baseURI = "baseURI" in source ? source.baseURI : baseURI;
        sourceUrl = "url" in source ? source.url : sourceUrl;
        result = result();
      }
      if (result instanceof basis.Token) {
        baseURI = "baseURI" in source ? source.baseURI : baseURI;
        sourceUrl = "url" in source ? source.url : sourceUrl;
        result = result.get();
      }
      if (Array.isArray(result)) {
        if (clone) result = cloneDecl(result);
        result = {
          tokens: result
        };
      } else {
        if (typeof result != "object" || !Array.isArray(result.tokens)) result = String(result);
      }
      if (typeof result == "string") result = makeDeclaration(result, baseURI, options, sourceUrl, source);
      return result;
    }
    function l10nHandler(value) {
      if (this.type != "markup" && this.token.type == "markup") {
        buildTemplate.call(this.template);
      }
    }
    function buildTemplate() {
      var decl = getDeclFromSource(this.source, this.baseURI, false, {
        isolate: this.getIsolatePrefix()
      });
      var destroyBuilder = this.destroyBuilder;
      var funcs = this.builder(decl.tokens, this);
      var deps = this.deps_;
      var l10n = this.l10n_;
      if (deps) {
        this.deps_ = null;
        for (var i = 0, dep; dep = deps[i]; i++) dep.bindingBridge.detach(dep, buildTemplate, this);
      }
      if (l10n) for (var i = 0, item; item = l10n[i]; i++) item.token.bindingBridge.detach(item.token, l10nHandler, item);
      if (decl.deps && decl.deps.length) {
        deps = decl.deps;
        this.deps_ = deps;
        for (var i = 0, dep; dep = deps[i]; i++) dep.bindingBridge.attach(dep, buildTemplate, this);
      }
      if (decl.l10n) {
        l10n = decl.l10n;
        this.l10n_ = {};
        for (var i = 0, key; key = l10n[i]; i++) {
          var l10nToken = basis.l10n.token(key);
          l10nToken.bindingBridge.attach(l10nToken, l10nHandler, this.l10n_[key] = {
            template: this,
            token: l10nToken,
            type: l10nToken.type
          });
        }
      }
      this.createInstance = funcs.createInstance;
      this.clearInstance = funcs.destroyInstance;
      this.getBinding = function() {
        return {
          names: funcs.keys
        };
      };
      this.destroyBuilder = funcs.destroy;
      this.instances_ = funcs.instances_;
      this.decl_ = decl;
      var declResources = decl.resources && decl.resources.length > 0 ? decl.resources : null;
      if (declResources) for (var i = 0, res; res = declResources[i]; i++) startUseResource(res);
      if (this.resources) for (var i = 0, res; res = this.resources[i]; i++) stopUseResource(res);
      this.resources = declResources;
      if (destroyBuilder) destroyBuilder(true);
    }
    var sourceByDocumentIdResolvers = {};
    function getTemplateByDocumentId(id) {
      var resolver = resolveSourceByDocumentId(id);
      if (resolver.template) return resolver.template;
      var host = document.getElementById(id);
      var source = "";
      if (host && host.tagName == "SCRIPT" && host.type == "text/basis-template") source = host.textContent || host.text; else if (!host) basis.dev.warn("Template script element with id `" + id + "` not found"); else basis.dev.warn('Template should be declared in <script type="text/basis-template"> element (id `' + sourceId + "`)");
      return resolver.template = new Template(source);
    }
    function resolveSourceByDocumentId(sourceId) {
      var resolver = sourceByDocumentIdResolvers[sourceId];
      if (!resolver) {
        resolver = sourceByDocumentIdResolvers[sourceId] = function() {
          return getTemplateByDocumentId(sourceId).source;
        };
        resolver.id = sourceId;
        resolver.url = '<script id="' + sourceId + '"/>';
      }
      return resolver;
    }
    var Template = Class(null, {
      className: namespace + ".Template",
      __extend__: function(value) {
        if (value instanceof Template) return value;
        if (value instanceof TemplateSwitchConfig) return new TemplateSwitcher(value);
        return new Template(value);
      },
      source: "",
      baseURI: "",
      init: function(source) {
        if (templateList.length == 4096) throw "Too many templates (maximum 4096)";
        this.attaches_ = [];
        this.setSource(source || "");
        this.templateId = templateList.push(this) - 1;
      },
      bindingBridge: {
        attach: function(template, handler, context) {
          for (var i = 0, listener; listener = template.attaches_[i]; i++) if (listener.handler == handler && listener.context == context) return;
          template.attaches_.push({
            handler: handler,
            context: context
          });
        },
        detach: function(template, handler, context) {
          for (var i = 0, listener; listener = template.attaches_[i]; i++) if (listener.handler == handler && listener.context == context) {
            template.attaches_.splice(i, 1);
            return;
          }
        },
        get: function() {}
      },
      createInstance: function(object, actionCallback, updateCallback, bindings, bindingInterface) {
        buildTemplate.call(this);
        return this.createInstance(object, actionCallback, updateCallback, bindings, bindingInterface);
      },
      clearInstance: function(tmpl) {},
      getIsolatePrefix: function() {
        return "i" + this.templateId + "__";
      },
      getBinding: function(bindings) {
        buildTemplate.call(this);
        return this.getBinding(bindings);
      },
      setSource: function(source) {
        var oldSource = this.source;
        if (oldSource != source) {
          if (typeof source == "string") {
            var m = source.match(/^([a-z]+):/);
            if (m) {
              var prefix = m[1];
              source = source.substr(m[0].length);
              switch (prefix) {
                case "file":
                  source = basis.resource(source);
                  break;
                case "id":
                  source = resolveSourceByDocumentId(source);
                  break;
                case "tokens":
                  source = basis.string.toObject(source);
                  source.isDecl = true;
                  break;
                case "raw":
                  break;
                case "path":
                  source = getSourceByPath(source);
                  break;
                default:
                  basis.dev.warn(namespace + ".Template.setSource: Unknown prefix " + prefix + " for template source was ingnored.");
              }
            }
          }
          if (oldSource && oldSource.bindingBridge) {
            var tmplList = oldSource.url && tmplFilesMap[oldSource.url];
            if (tmplList) {
              arrayRemove(tmplList, this);
              if (!tmplList.length) delete tmplFilesMap[oldSource.url];
            }
            this.baseURI = "";
            this.source.bindingBridge.detach(oldSource, templateSourceUpdate, this);
          }
          if (source && source.bindingBridge) {
            if (source.url) {
              this.baseURI = path.dirname(source.url) + "/";
              if (!tmplFilesMap[source.url]) tmplFilesMap[source.url] = [];
              arrayAdd(tmplFilesMap[source.url], this);
            }
            source.bindingBridge.attach(source, templateSourceUpdate, this);
          }
          this.source = source;
          templateSourceUpdate.call(this);
        }
      },
      destroy: function() {
        if (this.destroyBuilder) this.destroyBuilder();
        this.attaches_ = null;
        this.createInstance = null;
        this.getBinding = null;
        this.resources = null;
        this.source = null;
        this.instances_ = null;
        this.decl_ = null;
      }
    });
    var TemplateSwitchConfig = function(config) {
      basis.object.extend(this, config);
    };
    var TemplateSwitcher = basis.Class(null, {
      className: namespace + ".TemplateSwitcher",
      ruleRet_: null,
      templates_: null,
      templateClass: Template,
      ruleEvents: null,
      rule: String,
      init: function(config) {
        this.ruleRet_ = [];
        this.templates_ = [];
        this.rule = config.rule;
        var events = config.events;
        if (events && events.length) {
          this.ruleEvents = {};
          for (var i = 0, eventName; eventName = events[i]; i++) this.ruleEvents[eventName] = true;
        }
        cleaner.add(this);
      },
      resolve: function(object) {
        var ret = this.rule(object);
        var idx = this.ruleRet_.indexOf(ret);
        if (idx == -1) {
          this.ruleRet_.push(ret);
          idx = this.templates_.push(new this.templateClass(ret)) - 1;
        }
        return this.templates_[idx];
      },
      destroy: function() {
        this.rule = null;
        this.templates_ = null;
        this.ruleRet_ = null;
      }
    });
    function switcher(events, rule) {
      var args = basis.array(arguments);
      var rule = args.pop();
      return new TemplateSwitchConfig({
        rule: rule,
        events: args.join(" ").trim().split(/\s+/)
      });
    }
    var Theme = Class(null, {
      className: namespace + ".Theme",
      get: getSourceByPath
    });
    var SourceWrapper = Class(basis.Token, {
      className: namespace + ".SourceWrapper",
      path: "",
      url: "",
      baseURI: "",
      init: function(value, path) {
        this.path = path;
        basis.Token.prototype.init.call(this, "");
      },
      get: function() {
        return this.value && this.value.bindingBridge ? this.value.bindingBridge.get(this.value) : this.value;
      },
      set: function() {
        var content = getThemeSource(currentThemeName, this.path);
        if (this.value != content) {
          if (this.value && this.value.bindingBridge) this.value.bindingBridge.detach(this.value, SourceWrapper.prototype.apply, this);
          this.value = content;
          this.url = content && content.url || "";
          this.baseURI = (typeof content == "object" || typeof content == "function") && "baseURI" in content ? content.baseURI : path.dirname(this.url) + "/";
          if (this.value && this.value.bindingBridge) this.value.bindingBridge.attach(this.value, SourceWrapper.prototype.apply, this);
          this.apply();
        }
      },
      destroy: function() {
        this.url = null;
        this.baseURI = null;
        if (this.value && this.value.bindingBridge) this.value.bindingBridge.detach(this.value, this.apply, this);
        basis.Token.prototype.destroy.call(this);
      }
    });
    function getSourceByPath() {
      var path = basis.array(arguments).join(".");
      var source = sourceByPath[path];
      if (!source) {
        source = new SourceWrapper("", path);
        sourceByPath[path] = source;
      }
      return source;
    }
    function normalize(list) {
      var used = {};
      var result = [];
      for (var i = 0; i < list.length; i++) if (!used[list[i]]) {
        used[list[i]] = true;
        result.push(list[i]);
      }
      return result;
    }
    function extendFallback(themeName, list) {
      var result = [];
      result.source = normalize(list).join("/");
      var used = {
        base: true
      };
      for (var i = 0; i < list.length; i++) {
        var name = list[i] || "base";
        if (name == themeName || used[name]) continue;
        var theme = getTheme(name);
        used[name] = true;
        result.push(name);
        list.splice.apply(list, [ i + 1, 0 ].concat(themes[name].fallback));
      }
      result.unshift(themeName);
      if (themeName != "base") result.push("base");
      result.value = result.join("/");
      return result;
    }
    function getThemeSource(name, path) {
      var sourceList = themes[name].sourcesList;
      for (var i = 0, map; map = sourceList[i]; i++) if (map.hasOwnProperty(path)) return map[path];
      return "";
    }
    function themeHasEffect(themeName) {
      return themes[currentThemeName].fallback.indexOf(themeName) != -1;
    }
    function syncCurrentThemePath(path) {
      getSourceByPath(path).set();
    }
    function syncCurrentTheme(changed) {
      basis.dev.log("re-apply templates");
      for (var path in sourceByPath) syncCurrentThemePath(path);
    }
    function getTheme(name) {
      if (!name) name = "base";
      if (themes[name]) return themes[name].theme;
      if (!/^([a-z0-9\_\-]+)$/.test(name)) throw "Bad name for theme - " + name;
      var sources = {};
      var sourceList = [ sources ];
      var themeInterface = new Theme;
      themes[name] = {
        theme: themeInterface,
        sources: sources,
        sourcesList: sourceList,
        fallback: []
      };
      var addSource = function(path, source) {
        if (path in sources == false) {
          sources[path] = source;
          if (themeHasEffect(name)) syncCurrentThemePath(path);
        } else basis.dev.warn("Template path `" + path + "` is already defined for theme `" + name + "` (definition ignored).");
        return getSourceByPath(path);
      };
      basis.object.extend(themeInterface, {
        name: name,
        fallback: function(value) {
          if (themeInterface !== baseTheme && arguments.length > 0) {
            var newFallback = typeof value == "string" ? value.split("/") : [];
            var changed = {};
            newFallback = extendFallback(name, newFallback);
            if (themes[name].fallback.source != newFallback.source) {
              themes[name].fallback.source = newFallback.source;
              basis.dev.log("fallback changed");
              for (var themeName in themes) {
                var curFallback = themes[themeName].fallback;
                var newFallback = extendFallback(themeName, (curFallback.source || "").split("/"));
                if (newFallback.value != curFallback.value) {
                  changed[themeName] = true;
                  themes[themeName].fallback = newFallback;
                  var sourceList = themes[themeName].sourcesList;
                  sourceList.length = newFallback.length;
                  for (var i = 0; i < sourceList.length; i++) sourceList[i] = themes[newFallback[i]].sources;
                }
              }
            }
            var currentFallback = themes[currentThemeName].fallback;
            for (var themeName in changed) {
              if (themeHasEffect(themeName)) {
                syncCurrentTheme();
                break;
              }
            }
          }
          var result = themes[name].fallback.slice(1);
          result.source = themes[name].fallback.source;
          return result;
        },
        define: function(what, wherewith) {
          if (typeof what == "function") what = what();
          if (typeof what == "string") {
            if (typeof wherewith == "object") {
              var namespace = what;
              var dictionary = wherewith;
              var result = {};
              for (var key in dictionary) if (dictionary.hasOwnProperty(key)) result[key] = addSource(namespace + "." + key, dictionary[key]);
              return result;
            } else {
              if (arguments.length == 1) {
                return getSourceByPath(what);
              } else {
                return addSource(what, wherewith);
              }
            }
          } else {
            if (typeof what == "object") {
              var dictionary = what;
              for (var path in dictionary) if (dictionary.hasOwnProperty(path)) addSource(path, dictionary[path]);
              return themeInterface;
            } else {
              basis.dev.warn("Wrong first argument for basis.template.Theme#define");
            }
          }
        },
        apply: function() {
          if (name != currentThemeName) {
            currentThemeName = name;
            syncCurrentTheme();
            for (var i = 0, handler; handler = themeChangeHandlers[i]; i++) handler.fn.call(handler.context, name);
            basis.dev.info("Template theme switched to `" + name + "`");
          }
          return themeInterface;
        },
        getSource: function(path, withFallback) {
          return withFallback ? getThemeSource(name, path) : sources[path];
        },
        drop: function(path) {
          if (sources.hasOwnProperty(path)) {
            delete sources[path];
            if (themeHasEffect(name)) syncCurrentThemePath(path);
          }
        }
      });
      themes[name].fallback = extendFallback(name, []);
      sourceList.push(themes.base.sources);
      return themeInterface;
    }
    var themes = {};
    var sourceByPath = {};
    var baseTheme = getTheme();
    var currentThemeName = "base";
    var themeChangeHandlers = [];
    function onThemeChange(fn, context, fire) {
      themeChangeHandlers.push({
        fn: fn,
        context: context
      });
      if (fire) fn.call(context, currentThemeName);
    }
    cleaner.add({
      destroy: function() {
        for (var path in sourceByPath) sourceByPath[path].destroy();
        themes = null;
        sourceByPath = null;
        for (var i = 0, template; template = templateList[i]; i++) template.destroy();
        templateList = null;
      }
    });
    module.exports = {
      DECLARATION_VERSION: DECLARATION_VERSION,
      TYPE_ELEMENT: TYPE_ELEMENT,
      TYPE_ATTRIBUTE: TYPE_ATTRIBUTE,
      TYPE_ATTRIBUTE_CLASS: TYPE_ATTRIBUTE_CLASS,
      TYPE_ATTRIBUTE_STYLE: TYPE_ATTRIBUTE_STYLE,
      TYPE_ATTRIBUTE_EVENT: TYPE_ATTRIBUTE_EVENT,
      TYPE_TEXT: TYPE_TEXT,
      TYPE_COMMENT: TYPE_COMMENT,
      TOKEN_TYPE: TOKEN_TYPE,
      TOKEN_BINDINGS: TOKEN_BINDINGS,
      TOKEN_REFS: TOKEN_REFS,
      ATTR_NAME: ATTR_NAME,
      ATTR_VALUE: ATTR_VALUE,
      ATTR_NAME_BY_TYPE: ATTR_NAME_BY_TYPE,
      ELEMENT_NAME: ELEMENT_NAME,
      ELEMENT_ATTRS: ELEMENT_ATTRS,
      ELEMENT_CHILDS: ELEMENT_CHILDS,
      TEXT_VALUE: TEXT_VALUE,
      COMMENT_VALUE: COMMENT_VALUE,
      L10nProxyToken: L10nProxyToken,
      TemplateSwitchConfig: TemplateSwitchConfig,
      TemplateSwitcher: TemplateSwitcher,
      Template: Template,
      SourceWrapper: SourceWrapper,
      switcher: switcher,
      tokenize: tokenize,
      isolateCss: isolateCss,
      getDeclFromSource: getDeclFromSource,
      makeDeclaration: makeDeclaration,
      getL10nTemplate: getL10nTemplate,
      Theme: Theme,
      theme: getTheme,
      getThemeList: function() {
        return basis.object.keys(themes);
      },
      currentTheme: function() {
        return themes[currentThemeName].theme;
      },
      setTheme: function(name) {
        return getTheme(name).apply();
      },
      onThemeChange: onThemeChange,
      define: baseTheme.define,
      get: getSourceByPath,
      getPathList: function() {
        return basis.object.keys(sourceByPath);
      }
    };
    getTheme("base").define({
      "#1": basis.resource("./0.tmpl"),
      "#2": basis.resource("./1.tmpl"),
      "#3": basis.resource("./2.tmpl"),
      "#4": basis.resource("./3.tmpl"),
      "#5": basis.resource("./4.tmpl"),
      "#6": basis.resource("./5.tmpl"),
      "#7": basis.resource("./6.tmpl"),
      "#8": basis.resource("./7.tmpl"),
      "#9": basis.resource("./8.tmpl"),
      "#a": basis.resource("./9.tmpl")
    });
  },
  "7.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./8.js");
    basis.require("./2.js");
    basis.require("./6.js");
    basis.require("./9.js");
    var namespace = this.path;
    var document = global.document;
    var domEvent = basis.dom.event;
    var arrayFrom = basis.array.from;
    var camelize = basis.string.camelize;
    var l10nToken = basis.l10n.token;
    var getFunctions = basis.template.htmlfgen.getFunctions;
    var TemplateSwitchConfig = basis.template.TemplateSwitchConfig;
    var TemplateSwitcher = basis.template.TemplateSwitcher;
    var Template = basis.template.Template;
    var TYPE_ELEMENT = basis.template.TYPE_ELEMENT;
    var TYPE_ATTRIBUTE = basis.template.TYPE_ATTRIBUTE;
    var TYPE_TEXT = basis.template.TYPE_TEXT;
    var TYPE_COMMENT = basis.template.TYPE_COMMENT;
    var TOKEN_TYPE = basis.template.TOKEN_TYPE;
    var TOKEN_BINDINGS = basis.template.TOKEN_BINDINGS;
    var TOKEN_REFS = basis.template.TOKEN_REFS;
    var ATTR_NAME = basis.template.ATTR_NAME;
    var ATTR_VALUE = basis.template.ATTR_VALUE;
    var ATTR_NAME_BY_TYPE = basis.template.ATTR_NAME_BY_TYPE;
    var ELEMENT_NAME = basis.template.ELEMENT_NAME;
    var TEXT_VALUE = basis.template.TEXT_VALUE;
    var COMMENT_VALUE = basis.template.COMMENT_VALUE;
    var eventAttr = /^event-(.+)+/;
    var basisTemplateIdMarker = "basisTemplateId_" + basis.genUID();
    var tmplEventListeners = {};
    var templates = {};
    var namespaceURI = {
      svg: "http://www.w3.org/2000/svg"
    };
    var afterEventAction = {};
    var insideElementEvent = {};
    var MOUSE_ENTER_LEAVE_SUPPORT = "onmouseenter" in document.documentElement;
    var CAPTURE_FALLBACK = !document.addEventListener && "__basisTemplate" + parseInt(1e9 * Math.random());
    if (CAPTURE_FALLBACK) global[CAPTURE_FALLBACK] = function(eventName, event) {
      domEvent.fireEvent(document, eventName);
      event.returnValue = true;
      var listener = tmplEventListeners[eventName];
      if (listener) listener(new domEvent.Event(event));
    };
    var CLONE_NORMALIZATION_TEXT_BUG = function() {
      var element = document.createElement("div");
      element.appendChild(document.createTextNode("a"));
      element.appendChild(document.createTextNode("a"));
      return element.cloneNode(true).childNodes.length == 1;
    }();
    var SET_CLASS_ATTRIBUTE_BUG = function() {
      var element = document.createElement("div");
      element.setAttribute("class", "a");
      return !element.className;
    }();
    var SET_STYLE_ATTRIBUTE_BUG = function() {
      var element = document.createElement("div");
      element.setAttribute("style", "position:absolute");
      return element.style.position != "absolute";
    }();
    var IS_SET_STYLE_SAFE = !!function() {
      try {
        return document.documentElement.style.color = "x";
      } catch (e) {}
    }();
    if (typeof Node != "undefined" && !Node.prototype.contains) Node.prototype.contains = function(child) {
      return !!(this.compareDocumentPosition(child) & 16);
    };
    var l10nTemplates = {};
    function getL10nTemplate(token) {
      var template = basis.template.getL10nTemplate(token);
      var id = template.templateId;
      var htmlTemplate = l10nTemplates[id];
      if (!htmlTemplate) htmlTemplate = l10nTemplates[id] = new HtmlTemplate(template.source);
      return htmlTemplate;
    }
    function createEventHandler(attrName) {
      return function(event) {
        if (event.type == "click" && event.which == 3) return;
        var bubble = insideElementEvent[event.type] || event.type != "mouseenter" && event.type != "mouseleave";
        var attrCursor = event.sender;
        var attr;
        while (attrCursor) {
          attr = attrCursor.getAttribute && attrCursor.getAttribute(attrName);
          if (!bubble || typeof attr == "string") break;
          attrCursor = attrCursor.parentNode;
        }
        if (typeof attr == "string") {
          var cursor = attrCursor;
          var actionTarget = cursor;
          var refId;
          var tmplRef;
          if (insideElementEvent[event.type]) {
            var relTarget = event.relatedTarget;
            if (relTarget && (cursor === relTarget || cursor.contains(relTarget))) cursor = null;
          }
          while (cursor) {
            refId = cursor[basisTemplateIdMarker];
            if (typeof refId == "number") {
              if (tmplRef = resolveInstanceById(refId)) break;
            }
            cursor = cursor.parentNode;
          }
          if (tmplRef && tmplRef.action) {
            var actions = attr.trim().split(/\s+/);
            event.actionTarget = actionTarget;
            for (var i = 0, actionName; actionName = actions[i++]; ) switch (actionName) {
              case "prevent-default":
                event.preventDefault();
                break;
              case "stop-propagation":
                event.stopPropagation();
                break;
              default:
                tmplRef.action.call(tmplRef.context, actionName, event);
            }
          }
        }
        if (event.type in afterEventAction) afterEventAction[event.type](event, attrCursor);
      };
    }
    var buildHtml = function(tokens, parent) {
      function emulateEvent(origEventName, emulEventName) {
        regEventHandler(emulEventName);
        insideElementEvent[origEventName] = true;
        afterEventAction[emulEventName] = function(event) {
          event = new domEvent.Event(event);
          event.type = origEventName;
          tmplEventListeners[origEventName](event);
        };
        afterEventAction[origEventName] = function(event, cursor) {
          cursor = cursor && cursor.parentNode;
          if (cursor) {
            event = new domEvent.Event(event);
            event.type = origEventName;
            event.sender = cursor;
            tmplEventListeners[origEventName](event);
          }
        };
      }
      function regEventHandler(eventName) {
        if (!tmplEventListeners[eventName]) {
          tmplEventListeners[eventName] = createEventHandler("event-" + eventName);
          if (!CAPTURE_FALLBACK) {
            if (!MOUSE_ENTER_LEAVE_SUPPORT && eventName == "mouseenter") return emulateEvent(eventName, "mouseover");
            if (!MOUSE_ENTER_LEAVE_SUPPORT && eventName == "mouseleave") return emulateEvent(eventName, "mouseout");
            for (var i = 0, names = domEvent.browserEvents(eventName), browserEventName; browserEventName = names[i]; i++) domEvent.addGlobalHandler(browserEventName, tmplEventListeners[eventName]);
          }
        }
      }
      function setEventAttribute(eventName, actions) {
        regEventHandler(eventName);
        if (CAPTURE_FALLBACK) result.setAttribute("on" + eventName, CAPTURE_FALLBACK + '("' + eventName + '",event)');
        result.setAttribute("event-" + eventName, actions);
      }
      function setAttribute(name, value) {
        if (SET_CLASS_ATTRIBUTE_BUG && name == "class") name = "className";
        if (SET_STYLE_ATTRIBUTE_BUG && name == "style") return result.style.cssText = value;
        result.setAttribute(name, value);
      }
      var result = parent || document.createDocumentFragment();
      for (var i = parent ? 4 : 0, token; token = tokens[i]; i++) {
        switch (token[TOKEN_TYPE]) {
          case TYPE_ELEMENT:
            var tagName = token[ELEMENT_NAME];
            var parts = tagName.split(/:/);
            var element = parts.length > 1 ? document.createElementNS(namespaceURI[parts[0]], tagName) : document.createElement(tagName);
            buildHtml(token, element);
            result.appendChild(element);
            break;
          case TYPE_ATTRIBUTE:
            var attrName = token[ATTR_NAME];
            var attrValue = token[ATTR_VALUE];
            var eventName = attrName.replace(/^event-/, "");
            if (eventName != attrName) {
              setEventAttribute(eventName, attrValue);
            } else {
              if (attrName != "class" && attrName != "style" ? !token[TOKEN_BINDINGS] : attrValue) setAttribute(attrName, attrValue || "");
            }
            break;
          case 4:
          case 5:
            var attrValue = token[ATTR_VALUE - 1];
            if (attrValue) setAttribute(ATTR_NAME_BY_TYPE[token[TOKEN_TYPE]], attrValue);
            break;
          case 6:
            setEventAttribute(token[1], token[2] || token[1]);
            break;
          case TYPE_COMMENT:
            result.appendChild(document.createComment(token[COMMENT_VALUE] || (token[TOKEN_REFS] ? "{" + token[TOKEN_REFS].join("|") + "}" : "")));
            break;
          case TYPE_TEXT:
            if (CLONE_NORMALIZATION_TEXT_BUG && i && tokens[i - 1][TOKEN_TYPE] == TYPE_TEXT) result.appendChild(document.createComment(""));
            result.appendChild(document.createTextNode(token[TEXT_VALUE] || (token[TOKEN_REFS] ? "{" + token[TOKEN_REFS].join("|") + "}" : "") || (token[TOKEN_BINDINGS] ? "{" + token[TOKEN_BINDINGS] + "}" : "")));
            break;
        }
      }
      if (!parent && tokens.length == 1) result = result.firstChild;
      return result;
    };
    function resolveTemplateById(refId) {
      var templateId = refId & 4095;
      var object = templates[templateId];
      return object && object.template;
    }
    function resolveInstanceById(refId) {
      var templateId = refId & 4095;
      var instanceId = refId >> 12;
      var object = templates[templateId];
      return object && object.instances[instanceId];
    }
    function resolveObjectById(refId) {
      var templateRef = resolveInstanceById(refId);
      return templateRef && templateRef.context;
    }
    function resolveTmplById(refId) {
      var templateRef = resolveInstanceById(refId);
      return templateRef && templateRef.tmpl;
    }
    function getDebugInfoById(refId) {
      var templateRef = resolveInstanceById(refId);
      return templateRef && templateRef.debug && templateRef.debug();
    }
    var builder = function() {
      var WHITESPACE = /\s+/;
      var W3C_DOM_NODE_SUPPORTED = typeof Node == "function" && document instanceof Node;
      var CLASSLIST_SUPPORTED = global.DOMTokenList && document && document.documentElement.classList instanceof global.DOMTokenList;
      var bind_node = W3C_DOM_NODE_SUPPORTED ? function(domRef, oldNode, newValue) {
        var newNode = newValue && newValue instanceof Node ? newValue : domRef;
        if (newNode !== oldNode) oldNode.parentNode.replaceChild(newNode, oldNode);
        return newNode;
      } : function(domRef, oldNode, newValue) {
        var newNode = newValue && typeof newValue == "object" ? newValue : domRef;
        if (newNode !== oldNode) {
          try {
            oldNode.parentNode.replaceChild(newNode, oldNode);
          } catch (e) {
            newNode = domRef;
            if (oldNode !== newNode) oldNode.parentNode.replaceChild(newNode, oldNode);
          }
        }
        return newNode;
      };
      var bind_element = function(domRef, oldNode, newValue) {
        var newNode = bind_node(domRef, oldNode, newValue);
        if (newNode === domRef && typeof newValue == "string") domRef.innerHTML = newValue;
        return newNode;
      };
      var bind_comment = bind_node;
      var bind_textNode = function(domRef, oldNode, newValue) {
        var newNode = bind_node(domRef, oldNode, newValue);
        if (newNode === domRef) domRef.nodeValue = newValue;
        return newNode;
      };
      var bind_attrClass = CLASSLIST_SUPPORTED ? function(domRef, oldClass, newValue, prefix, anim) {
        var newClass = newValue ? prefix + newValue : "";
        if (newClass != oldClass) {
          if (oldClass) domRef.classList.remove(oldClass);
          if (newClass) {
            domRef.classList.add(newClass);
            if (anim) {
              domRef.classList.add(newClass + "-anim");
              basis.nextTick(function() {
                domRef.classList.remove(newClass + "-anim");
              });
            }
          }
        }
        return newClass;
      } : function(domRef, oldClass, newValue, prefix, anim) {
        var newClass = newValue ? prefix + newValue : "";
        if (newClass != oldClass) {
          var className = domRef.className;
          var classNameIsObject = typeof className != "string";
          var classList;
          if (classNameIsObject) className = className.baseVal;
          classList = className.split(WHITESPACE);
          if (oldClass) basis.array.remove(classList, oldClass);
          if (newClass) {
            classList.push(newClass);
            if (anim) {
              basis.array.add(classList, newClass + "-anim");
              basis.nextTick(function() {
                var classList = (classNameIsObject ? domRef.className.baseVal : domRef.className).split(WHITESPACE);
                basis.array.remove(classList, newClass + "-anim");
                if (classNameIsObject) domRef.className.baseVal = classList.join(" "); else domRef.className = classList.join(" ");
              });
            }
          }
          if (classNameIsObject) domRef.className.baseVal = classList.join(" "); else domRef.className = classList.join(" ");
        }
        return newClass;
      };
      var bind_attrStyle = IS_SET_STYLE_SAFE ? function(domRef, propertyName, oldValue, newValue) {
        if (oldValue !== newValue) domRef.style[camelize(propertyName)] = newValue;
        return newValue;
      } : function(domRef, propertyName, oldValue, newValue) {
        if (oldValue !== newValue) {
          try {
            domRef.style[camelize(propertyName)] = newValue;
          } catch (e) {}
        }
        return newValue;
      };
      var bind_attr = function(domRef, attrName, oldValue, newValue) {
        if (oldValue !== newValue) {
          if (newValue) domRef.setAttribute(attrName, newValue); else domRef.removeAttribute(attrName);
        }
        return newValue;
      };
      function updateAttach() {
        this.set(this.name, this.value);
      }
      function resolveValue(bindingName, value, Attaches) {
        var bridge = value && value.bindingBridge;
        var oldAttach = this.attaches && this.attaches[bindingName];
        var tmpl = null;
        if (bridge || oldAttach) {
          if (bridge) {
            if (!oldAttach || value !== oldAttach.value) {
              if (oldAttach) {
                if (oldAttach.tmpl) {
                  oldAttach.tmpl.element.toString = null;
                  getL10nTemplate(oldAttach.value).clearInstance(oldAttach.tmpl);
                }
                oldAttach.value.bindingBridge.detach(oldAttach.value, updateAttach, oldAttach);
              }
              if (value.type == "markup" && value instanceof basis.l10n.Token) {
                var template = getL10nTemplate(value);
                var context = this.context;
                var bindings = this.bindings;
                var bindingInterface = this.bindingInterface;
                tmpl = template.createInstance(context, null, function onRebuild() {
                  tmpl = newAttach.tmpl = template.createInstance(context, null, onRebuild, bindings, bindingInterface);
                  tmpl.element.toString = function() {
                    return value.value;
                  };
                  updateAttach.call(newAttach);
                }, bindings, bindingInterface);
                tmpl.element.toString = function() {
                  return value.value;
                };
              }
              if (!this.attaches) this.attaches = new Attaches;
              var newAttach = this.attaches[bindingName] = {
                name: bindingName,
                value: value,
                tmpl: tmpl,
                set: this.tmpl.set
              };
              bridge.attach(value, updateAttach, newAttach);
            } else tmpl = value && value.type == "markup" ? oldAttach.tmpl : null;
            if (tmpl) return tmpl.element;
            value = bridge.get(value);
          } else {
            if (oldAttach) {
              if (oldAttach.tmpl) {
                oldAttach.tmpl.element.toString = null;
                getL10nTemplate(oldAttach.value).clearInstance(oldAttach.tmpl);
              }
              oldAttach.value.bindingBridge.detach(oldAttach.value, updateAttach, oldAttach);
              this.attaches[bindingName] = null;
            }
          }
        }
        return value;
      }
      function createBindingUpdater(names, getters) {
        var name1 = names[0];
        var name2 = names[1];
        var getter1 = getters[name1];
        var getter2 = getters[name2];
        switch (names.length) {
          case 1:
            return function bindingUpdater1(object) {
              this(name1, getter1(object));
            };
          case 2:
            return function bindingUpdater2(object) {
              this(name1, getter1(object));
              this(name2, getter2(object));
            };
          default:
            var getters_ = names.map(function(name) {
              return getters[name];
            });
            return function bindingUpdaterN(object) {
              for (var i = 0; i < names.length; i++) this(names[i], getters_[i](object));
            };
        }
      }
      function makeHandler(events, getters) {
        for (var name in events) events[name] = createBindingUpdater(events[name], getters);
        return name ? events : null;
      }
      function createBindingFunction(keys) {
        var bindingCache = {};
        return function getBinding(bindings, obj, set, bindingInterface) {
          if (!bindings) return {};
          var cacheId = "bindingId" in bindings ? bindings.bindingId : null;
          if (!cacheId) basis.dev.warn("basis.template.Template.getBinding: bindings has no bindingId property, cache is not used");
          var result = bindingCache[cacheId];
          if (!result) {
            var names = [];
            var getters = {};
            var events = {};
            for (var i = 0, bindingName; bindingName = keys[i]; i++) {
              var binding = bindings[bindingName];
              var getter = binding && binding.getter;
              if (getter) {
                getters[bindingName] = getter;
                names.push(bindingName);
                if (binding.events) {
                  var eventList = String(binding.events).trim().split(/\s+|\s*,\s*/);
                  for (var j = 0, eventName; eventName = eventList[j]; j++) {
                    if (events[eventName]) events[eventName].push(bindingName); else events[eventName] = [ bindingName ];
                  }
                }
              }
            }
            result = {
              names: names,
              sync: createBindingUpdater(names, getters),
              handler: makeHandler(events, getters)
            };
            if (cacheId) bindingCache[cacheId] = result;
          }
          if (obj && set) result.sync.call(set, obj);
          if (!bindingInterface) return;
          if (result.handler) bindingInterface.attach(obj, result.handler, set);
          return result.handler;
        };
      }
      var tools = {
        bind_textNode: bind_textNode,
        bind_node: bind_node,
        bind_element: bind_element,
        bind_comment: bind_comment,
        bind_attr: bind_attr,
        bind_attrClass: bind_attrClass,
        bind_attrStyle: bind_attrStyle,
        resolve: resolveValue,
        l10nToken: l10nToken,
        createBindingFunction: createBindingFunction
      };
      return function(tokens) {
        var fn = getFunctions(tokens, true, this.source.url, tokens.source_, !CLONE_NORMALIZATION_TEXT_BUG, basisTemplateIdMarker);
        var createInstance;
        var instances = {};
        var l10nMap = {};
        var l10nLinks = [];
        var seed = 0;
        var proto = buildHtml(tokens);
        var id = this.templateId;
        templates[id] = {
          template: this,
          instances: instances
        };
        if (fn.createL10nSync) {
          var l10nProtoSync = fn.createL10nSync(proto, l10nMap, bind_attr, CLONE_NORMALIZATION_TEXT_BUG);
          for (var i = 0, key; key = fn.l10nKeys[i]; i++) l10nProtoSync(key, l10nToken(key).value);
          if (fn.l10nKeys) for (var i = 0, key; key = fn.l10nKeys[i]; i++) {
            var link = {
              path: key,
              token: l10nToken(key),
              handler: function(value) {
                l10nProtoSync(this.path, value);
                for (var key in instances) instances[key].tmpl.set(this.path, value);
              }
            };
            link.token.attach(link.handler, link);
            l10nLinks.push(link);
            link = null;
          }
        }
        createInstance = fn.createInstance(id, instances, proto, tools, l10nMap, CLONE_NORMALIZATION_TEXT_BUG);
        return {
          createInstance: function(obj, onAction, onRebuild, bindings, bindingInterface) {
            var instanceId = seed++;
            var instance = createInstance(instanceId, obj, onAction, onRebuild, bindings, bindingInterface);
            instances[instanceId] = instance;
            return instance.tmpl;
          },
          destroyInstance: function(tmpl) {
            var instanceId = tmpl.templateId_;
            var instance = instances[instanceId];
            if (instance) {
              if (instance.handler) instance.bindingInterface.detach(instance.context, instance.handler, instance.tmpl.set);
              for (var key in instance.attaches) resolveValue.call(instance, key, null);
              delete instances[instanceId];
            }
          },
          keys: fn.keys,
          instances_: instances,
          destroy: function(rebuild) {
            for (var i = 0, link; link = l10nLinks[i]; i++) link.token.detach(link.handler, link);
            for (var key in instances) {
              var instance = instances[key];
              if (rebuild && instance.rebuild) instance.rebuild.call(instance.context);
              if (!rebuild || key in instances) {
                if (instance.handler) instance.bindingInterface.detach(instance.context, instance.handler, instance.tmpl.set);
                for (var key in instance.attaches) resolveValue.call(key, null);
              }
            }
            if (templates[id] && templates[id].instances === instances) delete templates[id];
            fn = null;
            proto = null;
            l10nMap = null;
            l10nLinks = null;
            l10nProtoSync = null;
            instances = null;
          }
        };
      };
    }();
    var HtmlTemplate = Template.subclass({
      className: namespace + ".Template",
      __extend__: function(value) {
        if (value instanceof HtmlTemplate) return value;
        if (value instanceof TemplateSwitchConfig) return new HtmlTemplateSwitcher(value);
        return new HtmlTemplate(value);
      },
      builder: builder
    });
    var HtmlTemplateSwitcher = TemplateSwitcher.subclass({
      className: namespace + ".TemplateSwitcher",
      templateClass: HtmlTemplate
    });
    module.exports = {
      marker: basisTemplateIdMarker,
      Template: HtmlTemplate,
      TemplateSwitcher: HtmlTemplateSwitcher
    };
    basis.template.extend({
      getDebugInfoById: getDebugInfoById,
      buildHtml: buildHtml,
      resolveTemplateById: resolveTemplateById,
      resolveObjectById: resolveObjectById,
      resolveTmplById: resolveTmplById
    });
  },
  "y.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./k.js");
    var moment = basis.require("./v.js");
    module.exports = basis.ui.calendar.Calendar.subclass({
      childNodes: [ "Year", "YearDecade" ],
      action: {
        click: function() {}
      },
      handler: {
        change: function() {
          this.owner.emit_monthChange(this.selectedDate.value);
        },
        update: function() {
          var date = moment().year(parseInt(this.data.year)).month(this.data.month);
          this.selectedDate.set(date.toDate());
        }
      }
    });
  },
  "k.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./l.js");
    basis.require("./1.js");
    basis.require("./2.js");
    var namespace = this.path;
    var Class = basis.Class;
    var arrayFrom = basis.array.from;
    var getter = basis.getter;
    var createEvent = basis.event.create;
    var UINode = basis.ui.Node;
    var YEAR = "year";
    var MONTH = "month";
    var DAY = "day";
    var HOUR = "hour";
    var FORWARD = true;
    var BACKWARD = false;
    var monthNumToRef = basis.date.monthNumToAbbr;
    var dict = basis.l10n.dictionary("./0.l10n");
    var templates = basis.template.define(namespace, {
      Calendar: basis.resource("./d.tmpl"),
      Section: basis.resource("./e.tmpl"),
      SectionMonth: basis.resource("./f.tmpl"),
      Node: basis.resource("./g.tmpl")
    });
    function unpackDate(date) {
      return {
        hour: date.getHours(),
        day: date.getDate() - 1,
        month: date.getMonth(),
        year: date.getFullYear()
      };
    }
    function binarySearchIntervalPos(arr, value) {
      if (!arr.length) return -1;
      var pos;
      var compareValue;
      var l = 0;
      var r = arr.length - 1;
      var lv;
      var rv;
      do {
        compareValue = arr[pos = l + r >> 1];
        if (value < (lv = compareValue.periodStart)) r = pos - 1; else if (value > (rv = compareValue.periodEnd)) l = pos + 1; else return value >= lv && value <= rv ? pos : -1;
      } while (l <= r);
      return -1;
    }
    var DAY_COUNT_MASK = {};
    var MAX_DAY_MASK = 2147483647;
    (function() {
      var i = 32;
      var mask = MAX_DAY_MASK;
      while (--i) {
        DAY_COUNT_MASK[i] = mask;
        mask >>= 1;
      }
    })();
    var PERIOD_TITLE = {
      century: function(period) {
        return period.periodStart.getFullYear() + " - " + period.periodEnd.getFullYear();
      },
      decade: function(period) {
        return period.periodStart.getFullYear() + " - " + period.periodEnd.getFullYear();
      },
      year: function(period) {
        return period.periodStart.getFullYear();
      },
      quarter: function(period) {
        return dict.token("quarter");
      },
      month: function(period) {
        return dict.token("monthShort").token(monthNumToRef[period.periodStart.getMonth()]);
      },
      day: function(period) {
        return period.periodStart.getDate();
      }
    };
    var PERIOD = {
      century: [ YEAR, 100, 0, 0, 100, 0, 0 ],
      decade: [ YEAR, 10, 0, 0, 10, 0, 0 ],
      year: [ YEAR, 1, 0, 0, 1, 0, 0 ],
      quarter: [ MONTH, 1, 3, 0, 0, 3, 0 ],
      month: [ MONTH, 1, 1, 0, 0, 1, 0 ],
      day: [ DAY, 1, 1, 1, 0, 0, 1 ]
    };
    function getPeriod(periodName, date) {
      var result = {};
      var mod = PERIOD[periodName];
      if (mod) {
        var y = date.getFullYear();
        var m = date.getMonth();
        var d = date.getDate();
        y = y - y % mod[1];
        m = mod[2] ? m - m % mod[2] : 0;
        d = mod[3] ? d : 1;
        result.periodStart = new Date(y, m, d);
        result.periodEnd = new Date(new Date(y + mod[4], m + mod[5], d + mod[6]) - 1);
      } else {
        result.periodStart = new Date(date);
        result.periodEnd = new Date(date);
      }
      return result;
    }
    var CalendarNode = Class(UINode, {
      className: namespace + ".Calendar.Node",
      childClass: null,
      periodStart: null,
      periodEnd: null,
      emit_periodChanged: createEvent("periodChanged"),
      emit_select: function() {
        UINode.prototype.emit_select.call(this);
        this.focus();
      },
      template: templates.Node,
      binding: {
        nodePeriodName: "nodePeriodName",
        title: {
          events: "periodChanged",
          getter: function(node) {
            return node.parentNode && PERIOD_TITLE[node.nodePeriodName](node);
          }
        },
        before: {
          events: "periodChanged",
          getter: function(node) {
            return node.parentNode && node.periodStart < node.parentNode.periodStart;
          }
        },
        after: {
          events: "periodChanged",
          getter: function(node) {
            return node.parentNode && node.periodEnd > node.parentNode.periodEnd;
          }
        }
      },
      action: {
        click: function(event) {
          var calendar = this.parentNode && this.parentNode.parentNode;
          if (calendar && !this.isDisabled()) calendar.templateAction("click", event, this);
        }
      },
      isPeriodEnabled: function() {
        return true;
      },
      setPeriod: function(period, selectedDate, rebuild) {
        if (rebuild || this.periodStart - period.periodStart || this.periodEnd - period.periodEnd) {
          this.periodStart = period.periodStart;
          this.periodEnd = period.periodEnd;
          this.setDisabled(!this.isPeriodEnabled(this.periodStart, this.periodEnd));
          if (selectedDate) {
            if (selectedDate >= this.periodStart && selectedDate <= this.periodEnd) this.select(); else this.unselect();
          }
          this.emit_periodChanged();
        }
      }
    });
    function getPeriods(section) {
      var result = [];
      var nodePeriod = getPeriod(section.nodePeriodName, basis.date.add(new Date(section.periodStart), section.nodePeriodUnit, -section.nodePeriodUnitCount * section.getInitOffset(section.periodStart)));
      for (var i = 0; i < section.nodeCount; i++) {
        result.push(nodePeriod);
        nodePeriod = getPeriod(section.nodePeriodName, basis.date.add(new Date(nodePeriod.periodStart), section.nodePeriodUnit, section.nodePeriodUnitCount));
      }
      return result;
    }
    var CalendarSection = Class(UINode, {
      className: namespace + ".CalendarSection",
      emit_periodChanged: createEvent("periodChanged"),
      emit_selectedDateChanged: createEvent("selectedDateChanged"),
      template: templates.Section,
      binding: {
        sectionName: "sectionName",
        title: {
          events: "periodChanged",
          getter: function(node) {
            return node.getTitle(node.periodStart);
          }
        },
        tabTitle: {
          events: "selectedDateChanged",
          getter: function(node) {
            return node.getTabTitle(node.selectedDate);
          }
        }
      },
      childClass: CalendarNode,
      minDate: null,
      maxDate: null,
      periodStart: null,
      periodEnd: null,
      selectedDate: null,
      isPrevPeriodEnabled: true,
      isNextPeriodEnabled: true,
      periodName: "period",
      nodeCount: 12,
      nodePeriodName: "-",
      nodePeriodUnit: "-",
      nodePeriodUnitCount: 1,
      selection: true,
      init: function() {
        this.childNodes = getPeriods(this).map(function(period) {
          return {
            nodePeriodName: this.nodePeriodName
          };
        }, this);
        UINode.prototype.init.call(this);
        var selectedDate = this.selectedDate || new Date;
        this.selectedDate = null;
        this.setViewDate(selectedDate);
        this.setSelectedDate(selectedDate);
      },
      getNodeByDate: function(date) {
        if (date && this.periodStart <= date && date <= this.periodEnd) {
          var pos = binarySearchIntervalPos(this.childNodes, date);
          if (pos != -1) return this.childNodes[pos];
        }
        return null;
      },
      isPeriodEnabled: function() {
        return true;
      },
      setPeriod: function(period, rebuild) {
        if (rebuild || this.periodStart - period.periodStart || this.periodEnd - period.periodEnd) {
          var oldPeriodStart = this.periodStart;
          var oldPeriodEnd = this.periodEnd;
          this.periodStart = period.periodStart;
          this.periodEnd = period.periodEnd;
          var periods = getPeriods(this);
          this.minDate = periods[0].periodStart;
          this.maxDate = periods[periods.length - 1].periodEnd;
          if (this.firstChild) for (var i = 0, child; child = this.childNodes[i]; i++) child.setPeriod(periods[i], this.selectedDate, rebuild);
          this.emit_periodChanged(oldPeriodStart, oldPeriodEnd);
        }
      },
      setSelectedDate: function(date) {
        if (this.selectedDate - date) {
          var oldSelectedDate = this.selectedDate;
          this.selectedDate = date;
          var node = this.getNodeByDate(this.selectedDate);
          if (node) node.select(); else {
            if (this.selectedDate) this.setViewDate(this.selectedDate); else this.selection.clear();
          }
          this.emit_selectedDateChanged(oldSelectedDate);
        }
      },
      prevPeriod: function() {
        if (this.isPrevPeriodEnabled) this.setPeriod(getPeriod(this.periodName, new Date(Number(this.periodStart) - 1)));
      },
      nextPeriod: function() {
        if (this.isNextPeriodEnabled) this.setPeriod(getPeriod(this.periodName, new Date(Number(this.periodEnd) + 1)));
      },
      setViewDate: function(date) {
        this.setPeriod(getPeriod(this.periodName, date));
      },
      rebuild: function() {
        this.setPeriod(getPeriod(this.periodName, this.selectedDate), true);
      },
      getInitOffset: function() {
        return 0;
      },
      getTitle: function() {
        return "-";
      },
      getTabTitle: function() {
        return "-";
      }
    });
    CalendarSection.Month = Class(CalendarSection, {
      className: namespace + ".CalendarSection.Month",
      sectionName: "Month",
      periodName: MONTH,
      nodeCount: 6 * 7,
      nodePeriodName: DAY,
      nodePeriodUnit: DAY,
      getTabTitle: function(date) {
        return date.getDate();
      },
      getInitOffset: function(date) {
        return 1 + (basis.date.set(new Date(date), DAY, 1).getDay() + 5) % 7;
      },
      template: templates.SectionMonth,
      binding: {
        year: {
          events: "periodChanged",
          getter: function(node) {
            return node.periodStart.getFullYear();
          }
        },
        title: dict.token("month").compute("periodChanged", function(node) {
          return monthNumToRef[node.periodStart.getMonth()];
        })
      }
    });
    CalendarSection.Year = Class(CalendarSection, {
      className: namespace + ".CalendarSection.Year",
      sectionName: "Year",
      periodName: YEAR,
      nodePeriodName: MONTH,
      nodePeriodUnit: MONTH,
      getTitle: function(date) {
        return date.getFullYear();
      },
      binding: {
        tabTitle: dict.token("month").compute("selectedDateChanged", function(node) {
          return monthNumToRef[node.selectedDate.getMonth()];
        })
      }
    });
    CalendarSection.YearDecade = Class(CalendarSection, {
      className: namespace + ".CalendarSection.YearDecade",
      sectionName: "YearDecade",
      periodName: "decade",
      nodePeriodName: YEAR,
      nodePeriodUnit: YEAR,
      getInitOffset: function() {
        return 1;
      },
      getTabTitle: function(date) {
        return date.getFullYear();
      },
      getTitle: function(date) {
        return date.getFullYear() + " - " + this.periodEnd.getFullYear();
      }
    });
    CalendarSection.Century = Class(CalendarSection, {
      className: namespace + ".CalendarSection.Century",
      sectionName: "Century",
      periodName: "century",
      nodePeriodName: "decade",
      nodePeriodUnit: YEAR,
      nodePeriodUnitCount: 10,
      getTabTitle: function(date) {
        var year = date.getFullYear();
        var start = year - year % 10;
        return start + "-" + basis.number.lead(Number(start.toString().substr(-2)) + 9, 2);
      },
      getInitOffset: function() {
        return 1;
      }
    });
    CalendarSection.YearQuarters = Class(CalendarSection, {
      className: namespace + ".CalendarSection.YearQuarter",
      sectionName: "YearQuarter",
      periodName: YEAR,
      nodeCount: 4,
      nodePeriodName: "quarter",
      nodePeriodUnit: MONTH,
      nodePeriodUnitCount: 3
    });
    CalendarSection.Quarter = Class(CalendarSection, {
      className: namespace + ".CalendarSection.Quarter",
      sectionName: "Quarter",
      periodName: "quarter",
      nodeCount: 3,
      nodePeriodName: MONTH,
      nodePeriodUnit: MONTH,
      binding: {
        title: dict.token("quarter").compute("periodChanged", function(node) {
          return 1;
        })
      }
    });
    var Calendar = Class(UINode, {
      className: namespace + ".Calendar",
      emit_change: createEvent("change"),
      emit_childNodesModified: function(delta) {
        if (delta.inserted) for (var i = 0, section; section = delta.inserted[i++]; ) {
          section.isPeriodEnabled = this.isPeriodEnabled;
          section.childNodes.forEach(function(child) {
            child.isPeriodEnabled = this.isPeriodEnabled;
          }, this);
          section.setViewDate(this.date.value);
          this.selectedDate.link(section, section.setSelectedDate);
          section.rebuild();
        }
        if (delta.deleted) for (var i = 0, section; section = delta.deleted[i++]; ) this.selectedDate.unlink(section, section.setSelectedDate);
        UINode.prototype.emit_childNodesModified.call(this, delta);
        if (this.selection && !this.selection.itemCount && this.firstChild) this.firstChild.select();
      },
      template: templates.Calendar,
      binding: {
        today: function() {
          return basis.date.format(new Date, "%D.%M.%Y");
        }
      },
      action: {
        moveNext: function() {
          this.selection.pick().nextPeriod();
        },
        movePrev: function() {
          this.selection.pick().prevPeriod();
        },
        selectToday: function() {
          this.selectedDate.set(new Date);
        }
      },
      templateAction: function(actionName, event, node) {
        UINode.prototype.templateAction.call(this, actionName, event);
        if (node instanceof CalendarNode) {
          var newDate = node.periodStart;
          var activeSection = this.selection.pick();
          this.selectedDate.set(basis.date.add(new Date(this.selectedDate.value), activeSection.nodePeriodUnit, basis.date.diff(this.selectedDate.value, activeSection.nodePeriodUnit, newDate)));
          this.nextSection(BACKWARD);
        }
      },
      satellite: {
        shadowTabs: basis.ui.ShadowNodeList.subclass({
          className: namespace + ".ShadowTabs",
          getChildNodesElement: function(host) {
            return host.tmpl.sectionTabs;
          },
          childClass: {
            className: namespace + ".ShadowTab",
            getElement: function(node) {
              return node.tmpl.tabElement;
            }
          }
        })
      },
      selection: true,
      childClass: CalendarSection,
      childFactory: function(nameOrClass) {
        var SectionClass = nameOrClass;
        if (typeof nameOrClass == "string") SectionClass = CalendarSection[nameOrClass];
        if (!basis.Class.isClass(SectionClass) || !SectionClass.isSubclassOf(CalendarSection)) {
          basis.dev.warn(nameOrClass + " is not a valid value for child of basis.ui.calendat.Calendar");
          return;
        }
        return new SectionClass;
      },
      date: null,
      childNodes: [ "Month", "Year", "YearDecade" ],
      minDate: null,
      maxDate: null,
      map: null,
      periodEnableByDefault: true,
      init: function() {
        var now = new Date;
        this.selectedDate = new basis.data.Value({
          value: new Date(this.date || now)
        });
        this.date = new basis.data.Value({
          value: new Date(this.date || now)
        });
        this.isPeriodEnabled = this.isPeriodEnabled.bind(this);
        UINode.prototype.init.call(this);
        if (this.sections) {
          basis.dev.warn("basis.ui.calendar.Calendar#sections is deprecated, use childNodes instead");
          this.setChildNodes(this.sections);
        }
      },
      setMinDate: function(date) {
        if (this.minDate != date) {
          this.minDate = date;
          for (var i = 0, section; section = this.childNodes[i]; i++) section.rebuild();
        }
      },
      setMaxDate: function(date) {
        if (this.maxDate != date) {
          this.maxDate = date;
          for (var i = 0, section; section = this.childNodes[i]; i++) section.rebuild();
        }
      },
      setSection: function(sectionName) {
        var section = basis.array.search(this.childNodes, "sectionName", sectionName);
        if (section) section.select();
      },
      nextSection: function(forward) {
        var activeSection = this.selection.pick();
        var section = forward ? activeSection.nextSibling : activeSection.previousSibling;
        if (section) {
          section.select();
          section.setViewDate(this.selectedDate.value);
        } else {
          if (!forward) this.emit_change();
        }
      },
      selectDate: function(date) {
        if (date - this.date.value != 0) this.date.set(new Date(date));
      },
      getNextPeriod: function(date, forward) {
        if (!this.isNextPeriodEnabled(date, forward)) return false;
        if (this.map) {
          var offset = forward ? 1 : -1;
          var startMark = forward ? "start" : "till";
          var endMark = forward ? "till" : "start";
          var cursor = basis.date.add(new Date(date), "millisecond", offset);
          var map = this.map[this.periodEnableByDefault ? "disabled" : "enabled"];
          if (map) {
            var period = getPeriod(YEAR, cursor);
            if (period.periodEnd.getFullYear() == cursor.getFullYear()) period[startMark] = cursor;
            while (!this.isPeriodEnabled(period.periodStart, period.periodEnd)) period = getPeriod(YEAR, basis.date.add(cursor, YEAR, offset));
            period[endMark] = getPeriod(MONTH, period[startMark])[endMark];
            while (!this.isPeriodEnabled(period.periodStart, period.periodEnd)) period = getPeriod(MONTH, basis.date.add(cursor, MONTH, offset));
            var s = unpackDate(period[startMark]);
            var t = unpackDate(period[endMark]);
            var month = map[t.year] && map[t.year][t.month];
            if (month) {
              if (this.periodEnableByDefault) {
                var mask = DAY_COUNT_MASK[period.periodEnd.getMonthDayCount()];
                month = month & mask ^ mask;
              }
              for (var i = s.day; i != t.day + offset; i += offset) if (month >> i & 1) {
                cursor = new Date(s.year, s.month, i + 1);
                break;
              }
            } else return getPeriod(DAY, period[startMark]);
          }
        }
        return getPeriod(DAY, cursor);
      },
      isNextPeriodEnabled: function(date, forward) {
        if (!forward && this.minDate && this.minDate > date) return false;
        if (forward && this.maxDate && this.maxDate < date) return false;
        if (this.map) {
          if (this.periodEnableByDefault) {
            if (!forward && this.minDate) return this.isPeriodEnabled(this.minDate, date);
            if (forward && this.maxDate) return this.isPeriodEnabled(date, this.maxDate);
          } else {
            var offset = forward ? 1 : -1;
            var curYear = date.getFullYear();
            var firstDate = basis.date.add(new Date(date), "millisecond", offset);
            var firstYear = firstDate.getFullYear();
            var years = basis.object.keys(this.map.enable).filter(function(year) {
              return offset * year >= offset * firstYear;
            });
            var yearCount = years.length;
            if (yearCount) {
              years = years.sort(function(a, b) {
                return offset * (a > b) || -offset * (a < b);
              });
              for (var i = 0; i < yearCount; i++) {
                var period = getPeriod(YEAR, new Date(years[i], 0));
                if (this.isPeriodEnabled(forward && years[i] == curYear ? firstDate : period.periodStart, !forward && years[i] == curYear ? firstDate : period.periodEnd)) return true;
              }
            }
            return false;
          }
        }
        return true;
      },
      isPeriodEnabled: function(periodStart, periodEnd) {
        function checkMapDays(mode, month, sday, tday) {
          var result;
          if (!mode) return month >> sday;
          if (mode == 1) return month & DAY_COUNT_MASK[tday + 1];
          return month;
        }
        if (this.minDate && this.minDate > periodEnd) return false;
        if (this.maxDate && this.maxDate < periodStart) return false;
        var map = this.map && this.map[this.periodEnableByDefault ? "disabled" : "enabled"];
        if (map) {
          var s = unpackDate(periodStart);
          var e = unpackDate(periodEnd);
          var monthIndex = s.month;
          var year;
          var month;
          var mask;
          var cursor = new Date(s.year, s.month);
          var monthMark = 11 - s.month;
          var monthCount = monthMark + 1 + (e.year - s.year - 1) * 12 + (e.month + 1) - 1;
          if (this.periodEnableByDefault) {
            if (monthCount == 0) {
              return !(year = map[s.year]) || !(month = year[s.month]) || (month ^ MAX_DAY_MASK) >> s.day & DAY_COUNT_MASK[e.day - s.day + 1];
            }
            for (var i = 0; i <= monthCount; i++) {
              if (!i || monthMark == i % 12) {
                year = map[cursor.getFullYear()];
                if (!year) return true;
              }
              month = year[monthIndex = cursor.getMonth()];
              if (!month) return true;
              mask = DAY_COUNT_MASK[cursor.getMonthDayCount()];
              if (checkMapDays(i / monthCount, month & mask ^ mask, s.day, e.day)) return true;
              cursor.setMonth(monthIndex + 1);
            }
            return false;
          } else {
            if (monthCount == 0) return (year = map[s.year]) && (month = year[s.month]) && month >> s.day & DAY_COUNT_MASK[e.day - s.day + 1];
            for (var i = 0; i <= monthCount; i++) {
              if (!i || monthMark == i % 12 || !year) {
                year = map[cursor.getFullYear()];
                if (!year) {
                  i += 12;
                  cursor.setMonth(monthIndex + 12);
                  continue;
                }
              }
              month = year[monthIndex = cursor.getMonth()];
              if (month && checkMapDays(i / monthCount, month, s.day, e.day)) return true;
              cursor.setMonth(monthIndex + 1);
            }
            return false;
          }
        }
        return true;
      },
      destroy: function() {
        UINode.prototype.destroy.call(this);
        this.date.destroy();
        this.date = null;
        this.selectedDate.destroy();
        this.selectedDate = null;
        delete this.isPeriodEnabled;
        this.tabElementMap_ = null;
      }
    });
    module.exports = {
      Calendar: Calendar,
      CalendarSection: CalendarSection
    };
  },
  "l.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    var namespace = this.path;
    var ISO_FORMAT = "%Y-%M-%D" + "T" + "%H:%I:%S.%Z" + "Z";
    var reISOFormat = /^(\d{1,4})-(\d\d?)-(\d\d?)(?:[T ](\d\d?):(\d\d?):(\d\d?)(?:\.(\d+))?)?$/;
    var reFormat = /%([yYdDmMhHipPIsSzZ])/g;
    var reIsoStringSplit = /\D/;
    var reIsoTimezoneDesignator = /(.{10,})([\-\+]\d{1,2}):?(\d{1,2})?$/;
    var MONTH_DAY_COUNT = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
    var monthNumToAbbr = [ "jan", "feb", "mar", "apr", "may", "jun", "jul", "aug", "sep", "oct", "nov", "dec" ];
    var dayNumToAbbr = [ "mon", "tue", "wed", "thr", "fri", "sat", "sun" ];
    var DIFF_BASE = {
      day: 24 * 3600 * 1e3,
      hour: 3600 * 1e3,
      minute: 60 * 1e3,
      second: 1e3
    };
    var DATE_PART = "year month day hour minute second millisecond".split(" ");
    var GETTER = {};
    var SETTER = {};
    basis.object.iterate({
      year: "FullYear",
      month: "Month",
      day: "Date",
      hour: "Hours",
      minute: "Minutes",
      second: "Seconds",
      millisecond: "Milliseconds"
    }, function(key, name) {
      GETTER[key] = function(date) {
        return date["get" + name]();
      };
      SETTER[key] = function(date, value) {
        return date["set" + name](value);
      };
    });
    function lead2(num) {
      return num < 10 ? "0" + num : num;
    }
    function lead3(num) {
      return num < 100 ? "0" + lead2(num) : num;
    }
    function isLeapYear(value) {
      if (value instanceof Date) value = value.getFullYear();
      return !!(!(value % 400) || value % 100 && !(value % 4));
    }
    function getMonthDayCount(dateOrMonth, year) {
      var month;
      if (dateOrMonth instanceof Date) {
        year = dateOrMonth.getFullYear();
        month = dateOrMonth.getMonth();
      } else {
        month = dateOrMonth - 1;
      }
      return month == 1 ? 28 + isLeapYear(year) : MONTH_DAY_COUNT[month];
    }
    function dateFormat(date, format, useUTC) {
      var result = "";
      for (var i = 0, chr, val; i < format.length; i++) {
        chr = format.charAt(i);
        if (chr == "%") switch (chr = format.charAt(++i)) {
          case "y":
            result += String(useUTC ? date.getUTCFullYear() : date.getFullYear()).substr(2);
            break;
          case "Y":
            result += useUTC ? date.getUTCFullYear() : date.getFullYear();
            break;
          case "d":
            result += useUTC ? date.getUTCDate() : date.getDate();
            break;
          case "D":
            result += lead2(useUTC ? date.getUTCDate() : date.getDate());
            break;
          case "m":
            result += useUTC ? date.getUTCMonth() + 1 : date.getMonth() + 1;
            break;
          case "M":
            result += lead2(useUTC ? date.getUTCMonth() + 1 : date.getMonth() + 1);
            break;
          case "h":
            result += useUTC ? date.getUTCHours() : date.getHours();
            break;
          case "H":
            result += lead2(useUTC ? date.getUTCHours() : date.getHours());
            break;
          case "i":
            result += lead2((useUTC ? date.getUTCHours() : date.getHours()) % 12 || 12);
            break;
          case "p":
            result += (useUTC ? date.getUTCHours() : date.getHours()) > 12 ? "pm" : "am";
            break;
          case "P":
            result += (useUTC ? date.getUTCHours() : date.getHours()) > 12 ? "PM" : "AM";
            break;
          case "I":
            result += lead2(useUTC ? date.getUTCMinutes() : date.getMinutes());
            break;
          case "s":
            result += useUTC ? date.getUTCSeconds() : date.getSeconds();
            break;
          case "S":
            result += lead2(useUTC ? date.getUTCSeconds() : date.getSeconds());
            break;
          case "z":
            result += useUTC ? date.getUTCMilliseconds() : date.getMilliseconds();
            break;
          case "Z":
            result += lead3(useUTC ? date.getUTCMilliseconds() : date.getMilliseconds());
            break;
          case "%":
            result += "%";
            i--;
            break;
          default:
            result += "%" + chr;
        } else result += chr;
      }
      return result;
    }
    var fromISOString = function() {
      function fastDateParse(y, m, d, h, i, s, ms) {
        var date = new Date(y, m - 1, d, h || 0, 0, s || 0, ms ? ms.substr(0, 3) : 0);
        date.setMinutes((i || 0) - tz - date.getTimezoneOffset());
        return date;
      }
      var tz;
      return function(isoDateString) {
        tz = 0;
        return fastDateParse.apply(null, String(isoDateString || "").replace(reIsoTimezoneDesignator, function(m, pre, h, i) {
          tz = i ? h * 60 + i * 1 : h * 1;
          return pre;
        }).split(reIsoStringSplit));
      };
    }();
    function toISOString(this_) {
      return dateFormat(this_, ISO_FORMAT, true);
    }
    function toISODateString(this_) {
      return dateFormat(this_, "%Y-%M-%D", true);
    }
    function toISOTimeString(this_) {
      return dateFormat(this_, "%H:%I:%S.%Z", true);
    }
    function add(this_, part, value) {
      var getter = GETTER[part];
      if (!getter) {
        basis.dev.warn("basis.date.add: Unknown date part `" + part + "`, date not changed");
        return this_;
      }
      var day;
      if (part == "year" || part == "month") {
        day = this_.getDate();
        if (day > 28) this_.setDate(1);
      }
      SETTER[part](this_, getter(this_) + value);
      if (day > 28) {
        var monthDayCount = getMonthDayCount(this_);
        this_.setDate(Math.min(day, monthDayCount));
      }
      return this_;
    }
    function diff(this_, part, date) {
      if (part == "year" || part == "month") {
        var dir = Number(this_) - Number(date) > 0 ? -1 : 1;
        var left = dir > 0 ? this_ : date;
        var right = dir > 0 ? date : this_;
        var ly = left.getFullYear();
        var ry = right.getFullYear();
        var ydiff = ry - ly;
        if (part == "year") return dir * ydiff;
        var lm = left.getMonth();
        var rm = right.getMonth();
        var mdiff = ydiff ? (ydiff > 1 ? (ydiff - 1) * 12 : 0) + (12 - 1 - lm) + (rm + 1) : rm - lm;
        return dir * mdiff;
      } else {
        var diff = Math.floor((date - this_) / DIFF_BASE[part]);
        return diff + Number(GETTER[part](new Date(date - diff * DIFF_BASE[part])) - GETTER[part](this_) != 0);
      }
    }
    function set(this_, part, value) {
      var setter = SETTER[part];
      if (!setter) {
        basis.dev.warn("basis.date.set: Unknown date part `" + part + "`, date not changed");
        return this_;
      }
      var day;
      if (part == "year" || part == "month") {
        day = this_.getDate();
        if (day > 28) this_.setDate(1);
      }
      setter(this_, value);
      if (day > 28) {
        var monthDayCount = getMonthDayCount(this_);
        this_.setDate(Math.min(day, monthDayCount));
      }
      return this_;
    }
    function get(this_, part) {
      if (GETTER[part]) return GETTER[part](this_);
      basis.dev.warn("basis.date.get: Unknown date part `" + part + "`");
    }
    function fromDate(this_, date) {
      if (date instanceof Date) {
        this_.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        this_.setTime(date.getTime());
      }
      return this_;
    }
    basis.object.complete(Date.prototype, {
      toISOString: function() {
        return toISOString(this);
      },
      toJSON: function() {
        return this.toISOString();
      }
    });
    module.exports = {
      monthNumToAbbr: monthNumToAbbr,
      dayNumToAbbr: dayNumToAbbr,
      fromISOString: fromISOString,
      format: dateFormat,
      toISOString: toISOString,
      toISODateString: toISODateString,
      toISOTimeString: toISOTimeString,
      isLeapYear: isLeapYear,
      getMonthDayCount: getMonthDayCount,
      add: add,
      set: set,
      get: get,
      diff: diff,
      fromDate: fromDate
    };
  },
  "8.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    var namespace = this.path;
    var document = global.document;
    var $null = basis.fn.$null;
    var arrayFrom = basis.array.from;
    var W3CSUPPORT = !!document.addEventListener;
    var EVENT_HOLDER = "__basisEvents";
    var KEY = {
      BACKSPACE: 8,
      TAB: 9,
      CTRL_ENTER: 10,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      ESC: 27,
      ESCAPE: 27,
      SPACE: 32,
      PAGEUP: 33,
      PAGEDOWN: 34,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      INSERT: 45,
      DELETE: 46,
      F1: 112,
      F2: 113,
      F3: 114,
      F4: 115,
      F5: 116,
      F6: 117,
      F7: 118,
      F8: 119,
      F9: 120,
      F10: 121,
      F11: 122,
      F12: 123
    };
    var MOUSE_LEFT = {
      VALUE: 1,
      BIT: 1
    };
    var MOUSE_MIDDLE = {
      VALUE: 2,
      BIT: 4
    };
    var MOUSE_RIGHT = {
      VALUE: 3,
      BIT: 2
    };
    var BROWSER_EVENTS = {
      mousewheel: [ "mousewheel", "DOMMouseScroll" ]
    };
    function browserEvents(eventName) {
      return BROWSER_EVENTS[eventName] || [ eventName ];
    }
    var Event = basis.Class(null, {
      className: namespace + ".Event",
      KEY: KEY,
      init: function(event) {
        event = wrap(event);
        for (var name in event) if (name != "returnValue" && name != "keyLocation" && name != "layerX" && name != "layerY") if (typeof event[name] != "function" && name in this == false) this[name] = event[name];
        var target = sender(event);
        basis.object.extend(this, {
          event_: event,
          sender: target,
          target: target,
          key: key(event),
          charCode: charCode(event),
          mouseLeft: mouseButton(event, MOUSE_LEFT),
          mouseMiddle: mouseButton(event, MOUSE_MIDDLE),
          mouseRight: mouseButton(event, MOUSE_RIGHT),
          mouseX: mouseX(event),
          mouseY: mouseY(event),
          wheelDelta: wheelDelta(event)
        });
      },
      stopBubble: function() {
        cancelBubble(this.event_);
      },
      stopPropagation: function() {
        cancelBubble(this.event_);
      },
      preventDefault: function() {
        cancelDefault(this.event_);
      },
      die: function() {
        this.stopBubble();
        this.preventDefault();
      }
    });
    function wrap(event) {
      return event instanceof Event ? event.event_ : event || global.event;
    }
    function getNode(ref) {
      return typeof ref == "string" ? document.getElementById(ref) : ref;
    }
    function sender(event) {
      var target = event.target || event.srcElement || document;
      return target.nodeType == 3 ? target.parentNode : target;
    }
    function cancelBubble(event) {
      if (event.stopPropagation) event.stopPropagation(); else event.cancelBubble = true;
    }
    function cancelDefault(event) {
      if (event.preventDefault) event.preventDefault(); else event.returnValue = false;
    }
    function kill(event, node) {
      node = getNode(node);
      if (node) addHandler(node, event, kill); else {
        cancelDefault(event);
        cancelBubble(event);
      }
    }
    function key(event) {
      return event.keyCode || event.which || 0;
    }
    function charCode(event) {
      return event.charCode || event.keyCode || 0;
    }
    function mouseButton(event, button) {
      if (typeof event.which == "number") return event.which == button.VALUE; else return !!(event.button & button.BIT);
    }
    function mouseX(event) {
      if (event.changedTouches) return event.changedTouches[0].pageX; else if ("pageX" in event) return event.pageX; else return "clientX" in event ? event.clientX + (document.compatMode == "CSS1Compat" ? document.documentElement.scrollLeft : document.body.scrollLeft) : 0;
    }
    function mouseY(event) {
      if (event.changedTouches) return event.changedTouches[0].pageY; else if ("pageY" in event) return event.pageY; else return "clientY" in event ? event.clientY + (document.compatMode == "CSS1Compat" ? document.documentElement.scrollTop : document.body.scrollTop) : 0;
    }
    function wheelDelta(event) {
      var delta = 0;
      if ("wheelDelta" in event) delta = event.wheelDelta; else if (event.type == "DOMMouseScroll") delta = -event.detail;
      return delta && delta / Math.abs(delta);
    }
    var globalHandlers = {};
    var captureHandlers = {};
    var noCaptureScheme = !W3CSUPPORT;
    function observeGlobalEvents(event) {
      var handlers = arrayFrom(globalHandlers[event.type]);
      var captureHandler = captureHandlers[event.type];
      var wrappedEvent = new Event(event);
      if (captureHandler) {
        captureHandler.handler.call(captureHandler.thisObject, wrappedEvent);
        kill(event);
        return;
      }
      if (handlers) {
        for (var i = handlers.length; i-- > 0; ) {
          var handlerObject = handlers[i];
          handlerObject.handler.call(handlerObject.thisObject, wrappedEvent);
        }
      }
    }
    function captureEvent(eventType, handler, thisObject) {
      if (captureHandlers[eventType]) releaseEvent(eventType);
      addGlobalHandler(eventType, handler, thisObject);
      captureHandlers[eventType] = {
        handler: handler,
        thisObject: thisObject
      };
    }
    function releaseEvent(eventType) {
      var handlerObject = captureHandlers[eventType];
      if (handlerObject) {
        removeGlobalHandler(eventType, handlerObject.handler, handlerObject.thisObject);
        delete captureHandlers[eventType];
      }
    }
    function addGlobalHandler(eventType, handler, thisObject) {
      var handlers = globalHandlers[eventType];
      if (handlers) {
        for (var i = 0, item; item = handlers[i]; i++) if (item.handler === handler && item.thisObject === thisObject) return;
      } else {
        if (noCaptureScheme) addHandler(document, eventType, $null); else document.addEventListener(eventType, observeGlobalEvents, true);
        handlers = globalHandlers[eventType] = [];
      }
      handlers.push({
        handler: handler,
        thisObject: thisObject
      });
    }
    function removeGlobalHandler(eventType, handler, thisObject) {
      var handlers = globalHandlers[eventType];
      if (handlers) {
        for (var i = 0, item; item = handlers[i]; i++) {
          if (item.handler === handler && item.thisObject === thisObject) {
            handlers.splice(i, 1);
            if (!handlers.length) {
              delete globalHandlers[eventType];
              if (noCaptureScheme) removeHandler(document, eventType, $null); else document.removeEventListener(eventType, observeGlobalEvents, true);
            }
            return;
          }
        }
      }
    }
    function addHandler(node, eventType, handler, thisObject) {
      node = getNode(node);
      if (!node) throw "basis.event.addHandler: can't attach event listener to undefined";
      if (typeof handler != "function") throw "basis.event.addHandler: handler is not a function";
      if (!node[EVENT_HOLDER]) node[EVENT_HOLDER] = {};
      var handlerObject = {
        handler: handler,
        thisObject: thisObject
      };
      var handlers = node[EVENT_HOLDER];
      var eventTypeHandlers = handlers[eventType];
      if (!eventTypeHandlers) {
        eventTypeHandlers = handlers[eventType] = [ handlerObject ];
        eventTypeHandlers.fireEvent = function(event) {
          event = wrap(event);
          if (noCaptureScheme && event && globalHandlers[eventType]) {
            if (typeof event.returnValue == "undefined") {
              observeGlobalEvents(event);
              if (event.cancelBubble === true) return;
              if (typeof event.returnValue == "undefined") event.returnValue = true;
            }
          }
          for (var i = 0, wrappedEvent = new Event(event), item; item = eventTypeHandlers[i++]; ) item.handler.call(item.thisObject, wrappedEvent);
        };
        if (W3CSUPPORT) node.addEventListener(eventType, eventTypeHandlers.fireEvent, false); else node.attachEvent("on" + eventType, eventTypeHandlers.fireEvent);
      } else {
        for (var i = 0, item; item = eventTypeHandlers[i]; i++) if (item.handler === handler && item.thisObject === thisObject) return;
        eventTypeHandlers.push(handlerObject);
      }
    }
    function addHandlers(node, handlers, thisObject) {
      node = getNode(node);
      for (var eventType in handlers) addHandler(node, eventType, handlers[eventType], thisObject);
    }
    function removeHandler(node, eventType, handler, thisObject) {
      node = getNode(node);
      var handlers = node[EVENT_HOLDER];
      if (handlers) {
        var eventTypeHandlers = handlers[eventType];
        if (eventTypeHandlers) {
          for (var i = 0, item; item = eventTypeHandlers[i]; i++) {
            if (item.handler === handler && item.thisObject === thisObject) {
              eventTypeHandlers.splice(i, 1);
              if (!eventTypeHandlers.length) clearHandlers(node, eventType);
              return;
            }
          }
        }
      }
    }
    function clearHandlers(node, eventType) {
      node = getNode(node);
      var handlers = node[EVENT_HOLDER];
      if (handlers) {
        if (typeof eventType != "string") {
          for (eventType in handlers) clearHandlers(node, eventType);
        } else {
          var eventTypeHandlers = handlers[eventType];
          if (eventTypeHandlers) {
            if (node.removeEventListener) node.removeEventListener(eventType, eventTypeHandlers.fireEvent, false); else node.detachEvent("on" + eventType, eventTypeHandlers.fireEvent);
            delete handlers[eventType];
          }
        }
      }
    }
    function fireEvent(node, eventType, event) {
      node = getNode(node);
      var handlers = node[EVENT_HOLDER];
      if (handlers && handlers[eventType]) handlers[eventType].fireEvent(event);
    }
    function onUnload(handler, thisObject) {
      addHandler(global, "unload", handler, thisObject);
    }
    var tagNameEventMap = {};
    function getEventInfo(eventName, tagName) {
      if (!tagName) tagName = "div";
      var id = tagName + "-" + eventName;
      if (tagNameEventMap[id]) return tagNameEventMap[id]; else {
        var supported = false;
        var bubble = false;
        if (!W3CSUPPORT) {
          var onevent = "on" + eventName;
          var host = document.createElement("div");
          var target = host.appendChild(document.createElement(tagName));
          host[onevent] = function() {
            bubble = true;
          };
          try {
            target.fireEvent(onevent);
            supported = true;
          } catch (e) {}
        }
        return tagNameEventMap[id] = {
          supported: supported,
          bubble: bubble
        };
      }
    }
    function wrapEventFunction(fn) {
      return function(event, arg) {
        return fn(wrap(event), arg);
      };
    }
    module.exports = {
      W3CSUPPORT: W3CSUPPORT,
      browserEvents: browserEvents,
      getEventInfo: getEventInfo,
      KEY: KEY,
      MOUSE_LEFT: MOUSE_LEFT,
      MOUSE_RIGHT: MOUSE_RIGHT,
      MOUSE_MIDDLE: MOUSE_MIDDLE,
      Event: Event,
      sender: wrapEventFunction(sender),
      cancelBubble: wrapEventFunction(cancelBubble),
      cancelDefault: wrapEventFunction(cancelDefault),
      kill: wrapEventFunction(kill),
      key: wrapEventFunction(key),
      charCode: wrapEventFunction(charCode),
      mouseButton: wrapEventFunction(mouseButton),
      mouseX: wrapEventFunction(mouseX),
      mouseY: wrapEventFunction(mouseY),
      wheelDelta: wrapEventFunction(wheelDelta),
      addGlobalHandler: addGlobalHandler,
      removeGlobalHandler: removeGlobalHandler,
      captureEvent: captureEvent,
      releaseEvent: releaseEvent,
      addHandler: addHandler,
      addHandlers: addHandlers,
      removeHandler: removeHandler,
      clearHandlers: clearHandlers,
      fireEvent: fireEvent,
      onUnload: onUnload,
      wrap: wrap
    };
  },
  "9.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./6.js");
    var TYPE_ELEMENT = basis.template.TYPE_ELEMENT;
    var TYPE_ATTRIBUTE = basis.template.TYPE_ATTRIBUTE;
    var TYPE_TEXT = basis.template.TYPE_TEXT;
    var TYPE_COMMENT = basis.template.TYPE_COMMENT;
    var TOKEN_TYPE = basis.template.TOKEN_TYPE;
    var TOKEN_BINDINGS = basis.template.TOKEN_BINDINGS;
    var TOKEN_REFS = basis.template.TOKEN_REFS;
    var ATTR_NAME = basis.template.ATTR_NAME;
    var ATTR_NAME_BY_TYPE = basis.template.ATTR_NAME_BY_TYPE;
    var ELEMENT_NAME = basis.template.ELEMENT_NAME;
    var ELEMENT_ATTRS = basis.template.ELEMENT_ATTRS;
    var ELEMENT_CHILDS = basis.template.ELEMENT_CHILDS;
    var TEXT_VALUE = basis.template.TEXT_VALUE;
    var COMMENT_VALUE = basis.template.COMMENT_VALUE;
    var tmplFunctions = {};
    var inlineSeed = 1;
    var buildPathes = function() {
      var PATH_REF_NAME = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
      var pathList;
      var refList;
      var bindingList;
      var markedElementList;
      var rootPath;
      var attrExprId;
      function putRefs(refs, pathIdx) {
        for (var i = 0, refName; refName = refs[i]; i++) if (refName.indexOf(":") == -1) refList.push(refName + ":" + pathIdx);
      }
      function putPath(path) {
        var len = pathList.length;
        var pathRef = PATH_REF_NAME[len] || "r" + len;
        pathList.push(pathRef + "=" + path);
        return pathRef;
      }
      function putBinding(binding) {
        bindingList.push(binding);
      }
      function processTokens(tokens, path, noTextBug, templateMarker) {
        var localPath;
        var refs;
        var myRef;
        var explicitRef;
        var bindings;
        for (var i = 0, cp = 0, closeText = 0, token; token = tokens[i]; i++, cp++, explicitRef = false) {
          if (!i) localPath = path + ".firstChild"; else {
            if (!tokens[i + 1]) localPath = path + ".lastChild"; else {
              if (token[TOKEN_TYPE] == tokens[i - 1][TOKEN_TYPE] && token[TOKEN_TYPE] == TYPE_TEXT) closeText++;
              localPath = path + ".childNodes[" + (noTextBug ? cp : cp + (closeText ? " + " + closeText + " * TEXT_BUG" : "")) + "]";
            }
          }
          if (refs = token[TOKEN_REFS]) {
            explicitRef = true;
            localPath = putPath(localPath);
            putRefs(refs, localPath);
          }
          if (token[TOKEN_BINDINGS]) {
            if (token[TOKEN_BINDINGS] && typeof token[TOKEN_BINDINGS] == "number") token[TOKEN_BINDINGS] = token[TOKEN_REFS][token[TOKEN_BINDINGS] - 1];
            if (!explicitRef) {
              explicitRef = true;
              localPath = putPath(localPath);
            }
            putBinding([ token[TOKEN_TYPE], localPath, token[TOKEN_BINDINGS] ]);
          }
          if (token[TOKEN_TYPE] == TYPE_ELEMENT) {
            myRef = -1;
            if (path == rootPath) markedElementList.push(localPath + "." + templateMarker);
            if (!explicitRef) {
              localPath = putPath(localPath);
              myRef = pathList.length;
            }
            var attrs = [];
            var children = [];
            for (var j = ELEMENT_ATTRS, t; t = token[j]; j++) if (t[TOKEN_TYPE] == TYPE_ELEMENT || t[TOKEN_TYPE] == TYPE_TEXT || t[TOKEN_TYPE] == TYPE_COMMENT) children.push(t); else attrs.push(t);
            for (var j = 0, attr; attr = attrs[j]; j++) {
              if (attr[TOKEN_TYPE] == 6) continue;
              var attrName = ATTR_NAME_BY_TYPE[attr[TOKEN_TYPE]] || attr[ATTR_NAME];
              if (refs = attr[TOKEN_REFS]) {
                explicitRef = true;
                putRefs(refs, putPath(localPath + '.getAttributeNode("' + attrName + '")'));
              }
              if (bindings = attr[TOKEN_BINDINGS]) {
                explicitRef = true;
                switch (attrName) {
                  case "class":
                    for (var k = 0, binding; binding = bindings[k]; k++) putBinding([ 2, localPath, binding[1], attrName, binding[0] ].concat(binding.slice(2)));
                    break;
                  case "style":
                    for (var k = 0, property; property = bindings[k]; k++) {
                      attrExprId++;
                      for (var m = 0, bindName; bindName = property[0][m]; m++) putBinding([ 2, localPath, bindName, attrName, property[0], property[1], property[2], property[3], attrExprId ]);
                    }
                    break;
                  default:
                    attrExprId++;
                    for (var k = 0, bindName; bindName = bindings[0][k]; k++) putBinding([ 2, localPath, bindName, attrName, bindings[0], bindings[1], token[ELEMENT_NAME], attrExprId ]);
                }
              }
            }
            if (children.length) processTokens(children, localPath, noTextBug);
            if (!explicitRef && myRef == pathList.length) pathList.pop();
          }
        }
      }
      return function(tokens, path, noTextBug, templateMarker) {
        pathList = [];
        refList = [];
        bindingList = [];
        markedElementList = [];
        rootPath = path || "_";
        attrExprId = 0;
        processTokens(tokens, rootPath, noTextBug, templateMarker);
        return {
          path: pathList,
          ref: refList,
          binding: bindingList,
          markedElementList: markedElementList
        };
      };
    }();
    var buildBindings = function() {
      var L10N_BINDING = /\.\{([a-zA-Z_][a-zA-Z0-9_\-]*)\}/;
      var SPECIAL_ATTR_MAP = {
        disabled: "*",
        checked: [ "input" ],
        indeterminate: [ "input" ],
        value: [ "input", "textarea", "select" ],
        minlength: [ "input" ],
        maxlength: [ "input" ],
        readonly: [ "input" ],
        selected: [ "option" ],
        multiple: [ "select" ]
      };
      var SPECIAL_ATTR_SINGLE = {
        disabled: true,
        checked: true,
        selected: true,
        readonly: true,
        multiple: true,
        indeterminate: true
      };
      var bindFunctions = {
        1: "bind_element",
        3: "bind_textNode",
        8: "bind_comment"
      };
      function buildAttrExpression(binding, special, l10n) {
        var expression = [];
        var symbols = binding[5];
        var dictionary = binding[4];
        var exprVar;
        var colonPos;
        for (var j = 0; j < symbols.length; j++) {
          if (typeof symbols[j] == "string") expression.push('"' + symbols[j].replace(/"/g, '\\"') + '"'); else {
            exprVar = dictionary[symbols[j]];
            colonPos = exprVar.indexOf(":");
            if (colonPos == -1) {
              expression.push(special == "l10n" ? '"{' + exprVar + '}"' : special == "bool" ? "(__" + exprVar + '||"")' : "__" + exprVar);
            } else {
              var bindingName = null;
              var l10nPath = exprVar.substr(colonPos + 1).replace(L10N_BINDING, function(m, name) {
                bindingName = name;
                return "";
              });
              if (bindingName) expression.push(l10n[exprVar.substr(colonPos + 1)]); else expression.push('__l10n["' + l10nPath + '"]');
            }
          }
        }
        if (expression.length == 1) expression.push('""');
        return expression.join("+");
      }
      return function(bindings) {
        function putBindCode(type) {
          toolsUsed[type] = true;
          bindCode.push(bindVar + "=" + type + "(" + basis.array(arguments, 1) + ");");
        }
        var bindMap = {};
        var bindCode;
        var bindVar;
        var varList = [];
        var result = [];
        var varName;
        var l10nMap;
        var l10nCompute = [];
        var l10nBindings = {};
        var l10nBindSeed = 1;
        var specialAttr;
        var attrExprId;
        var attrExprMap = {};
        var debugList = [];
        var toolsUsed = {
          resolve: true
        };
        for (var i = 0, binding; binding = bindings[i]; i++) {
          var bindType = binding[0];
          var domRef = binding[1];
          var bindName = binding[2];
          if ([ "get", "set", "templateId_" ].indexOf(bindName) != -1) {
            basis.dev.warn("binding name `" + bindName + "` is prohibited, binding ignored");
            continue;
          }
          var namePart = bindName.split(":");
          var anim = namePart[0] == "anim";
          if (anim) bindName = namePart[1];
          bindCode = bindMap[bindName];
          bindVar = "_" + i;
          varName = "__" + bindName;
          if (namePart[0] == "l10n" && namePart[1]) {
            var l10nFullPath = namePart[1];
            var l10nBinding = null;
            var l10nName = l10nFullPath.replace(L10N_BINDING, function(m, name) {
              l10nBinding = name;
              return "";
            });
            if (l10nBinding) {
              if (l10nFullPath in l10nBindings == false) {
                varName = "$l10n_" + l10nBindSeed++;
                l10nBindings[l10nFullPath] = varName;
                l10nCompute.push('set("' + varName + '",' + varName + ")");
                varList.push(varName + '=tools.l10nToken("' + l10nName + '").computeToken()');
                bindCode = bindMap[l10nBinding];
                if (!bindCode) {
                  bindCode = bindMap[l10nBinding] = [];
                  varList.push("__" + l10nBinding);
                }
                bindCode.push(varName + ".set(__" + l10nBinding + ");");
              }
              bindName = l10nBindings[l10nFullPath];
              bindVar = "_" + i;
              varName = "__" + bindName;
              bindCode = bindMap[bindName];
              if (!bindCode) {
                bindCode = bindMap[bindName] = [];
                varList.push(varName);
              }
              if (bindType == TYPE_TEXT) {
                debugList.push("{" + [ 'binding:"' + bindName + '"', "dom:" + domRef, "val:" + bindVar, 'attachment:instance.attaches&&instance.attaches["' + bindName + '"]&&instance.attaches["' + bindName + '"].value' ] + "}");
                varList.push(bindVar + "=" + domRef);
                putBindCode(bindFunctions[bindType], domRef, bindVar, "value");
              } else {
                attrName = '"' + binding[ATTR_NAME] + '"';
                debugList.push("{" + [ 'binding:"' + l10nFullPath + '"', "dom:" + domRef, "attr:" + attrName, "val:" + bindVar, 'attachment:instance.attaches&&instance.attaches["' + bindName + '"]&&instance.attaches["' + bindName + '"].value' ] + "}");
                varList.push(bindVar);
                putBindCode("bind_attr", domRef, attrName, bindVar, buildAttrExpression(binding, false, l10nBindings));
              }
              continue;
            }
            if (!l10nMap) l10nMap = {};
            if (!bindMap[l10nName]) {
              bindMap[l10nName] = [];
              l10nMap[l10nName] = [];
            }
            bindCode = bindMap[l10nName];
            bindCode.l10n = true;
            if (bindType == TYPE_TEXT) {
              debugList.push("{" + [ 'binding:"' + l10nFullPath + '"', "dom:" + domRef, 'val:__l10n["' + l10nName + '"]', 'attachment:l10nToken("' + l10nName + '")' ] + "}");
              toolsUsed.l10nToken = true;
              l10nMap[l10nName].push(domRef + ".nodeValue=value;");
              bindCode.push(domRef + '.nodeValue=__l10n["' + l10nName + '"]' + (l10nBinding ? "[__" + l10nBinding + "]" : "") + ";");
              continue;
            } else {
              l10nMap[l10nName].push("bind_attr(" + [ domRef, '"' + binding[ATTR_NAME] + '"', "NaN", buildAttrExpression(binding, "l10n", l10nBindings) ] + ");");
            }
          }
          if (!bindCode) {
            bindCode = bindMap[bindName] = [];
            varList.push(varName);
          }
          if (bindType != TYPE_ATTRIBUTE) {
            debugList.push("{" + [ 'binding:"' + bindName + '"', "dom:" + domRef, "val:" + (bindCode.nodeBind ? varName : bindVar), "updates:$$" + bindName, 'attachment:instance.attaches&&instance.attaches["' + bindName + '"]&&instance.attaches["' + bindName + '"].value' ] + "}");
            if (!bindCode.nodeBind) {
              varList.push(bindVar + "=" + domRef);
              putBindCode(bindFunctions[bindType], domRef, bindVar, "value");
              bindCode.nodeBind = bindVar;
            } else {
              switch (bindType) {
                case TYPE_ELEMENT:
                  putBindCode(bindFunctions[bindType], domRef, domRef, "value!==null?String(value):null");
                  break;
                case TYPE_TEXT:
                  bindCode.push(domRef + ".nodeValue=value;");
                  break;
              }
            }
          } else {
            var attrName = binding[ATTR_NAME];
            switch (attrName) {
              case "class":
                var defaultExpr = "";
                var valueExpr = "value";
                var prefix = binding[4];
                var bindingLength = binding.length;
                if (bindingLength >= 6) {
                  if (bindingLength == 6 || typeof binding[6] == "string") {
                    if (bindingLength == 6) {
                      valueExpr = 'value?"' + bindName + '":""';
                      if (binding[5]) defaultExpr = prefix + bindName;
                    } else {
                      prefix = "";
                      valueExpr = 'value?"' + binding[6] + '":""';
                      if (binding[5]) defaultExpr = binding[6];
                    }
                  } else {
                    if (!binding[6].length) continue;
                    if (bindingLength == 7) {
                      valueExpr = binding[6].map(function(val) {
                        return 'value=="' + val + '"';
                      }).join("||") + '?value:""';
                      if (binding[5]) defaultExpr = prefix + binding[6][binding[5] - 1];
                    } else {
                      prefix = "";
                      valueExpr = binding[6].map(function(val, idx) {
                        return 'value=="' + val + '"?"' + this[idx] + '"';
                      }, binding[7]).join(":") + ':""';
                      if (binding[5]) defaultExpr = binding[7][binding[5] - 1];
                    }
                  }
                } else {
                  valueExpr = 'typeof value=="string"||typeof value=="number"?value:(value?"' + bindName + '":"")';
                }
                varList.push(bindVar + '="' + defaultExpr + '"');
                putBindCode("bind_attrClass", domRef, bindVar, valueExpr, '"' + prefix + '"', anim);
                break;
              case "style":
                var expr = buildAttrExpression(binding, false, l10nBindings);
                attrExprId = binding[8];
                if (!attrExprMap[attrExprId]) {
                  attrExprMap[attrExprId] = bindVar;
                  varList.push(bindVar + "=" + (binding[7] == "hide" ? '""' : '"none"'));
                }
                if (binding[7]) expr = expr.replace(/\+""$/, "") + (binding[7] == "hide" ? '?"none":""' : '?"":"none"');
                bindVar = attrExprMap[attrExprId];
                putBindCode("bind_attrStyle", domRef, '"' + binding[6] + '"', bindVar, expr);
                break;
              default:
                specialAttr = SPECIAL_ATTR_MAP[attrName];
                attrExprId = binding[7];
                if (!attrExprMap[attrExprId]) {
                  varList.push(bindVar + "=" + buildAttrExpression(binding, "l10n", l10nBindings));
                  attrExprMap[attrExprId] = bindVar;
                }
                bindVar = attrExprMap[attrExprId];
                putBindCode("bind_attr", domRef, '"' + attrName + '"', bindVar, specialAttr && SPECIAL_ATTR_SINGLE[attrName] ? buildAttrExpression(binding, "bool", l10nBindings) + '?"' + attrName + '":""' : buildAttrExpression(binding, false, l10nBindings));
                if (specialAttr && (specialAttr == "*" || specialAttr.indexOf(binding[6].toLowerCase()) != -1)) bindCode.push("if(" + domRef + "." + attrName + "!=" + bindVar + ")" + domRef + "." + attrName + "=" + (SPECIAL_ATTR_SINGLE[attrName] ? "!!" + bindVar : bindVar) + ";");
            }
            debugList.push("{" + [ 'binding:"' + bindName + '"', "dom:" + domRef, 'attr:"' + attrName + '"', "val:" + bindVar, 'attachment:instance.attaches&&instance.attaches["' + bindName + '"]&&instance.attaches["' + bindName + '"].value' ] + "}");
          }
        }
        result.push(";function set(bindName,value){" + 'if(typeof bindName!="string")');
        for (var bindName in bindMap) if (bindMap[bindName].nodeBind) {
          result.push("if(bindName===" + bindMap[bindName].nodeBind + ")" + 'bindName="' + bindName + '";' + "else ");
        }
        result.push("return;");
        result.push("value=resolve.call(instance,bindName,value,Attaches);" + "switch(bindName){");
        for (var bindName in bindMap) {
          if (bindName.indexOf("@") == -1) varList.push("$$" + bindName + "=0");
          result.push('case"' + bindName + '":' + (bindMap[bindName].l10n ? bindMap[bindName].join("") : "if(__" + bindName + "!==value)" + "{" + "$$" + bindName + "++;" + "__" + bindName + "=value;" + bindMap[bindName].join("") + "}") + "break;");
        }
        result.push("}}");
        var toolsVarList = [];
        for (var key in toolsUsed) toolsVarList.push(key + "=tools." + key);
        return {
          debugList: debugList,
          keys: basis.object.keys(bindMap).filter(function(key) {
            return key.indexOf("@") == -1;
          }),
          tools: toolsVarList,
          vars: varList,
          set: result.join(""),
          l10n: l10nMap,
          l10nCompute: l10nCompute
        };
      };
    }();
    function compileFunction(args, body) {
      try {
        return new Function(args, body);
      } catch (e) {
        basis.dev.error("Can't build template function: " + e + "\n", "function(" + args + "){\n" + body + "\n}");
      }
    }
    var getFunctions = function(tokens, debug, uri, source, noTextBug, templateMarker) {
      var fn = tmplFunctions[uri && basis.path.relative(uri)];
      if (fn) return fn;
      var paths = buildPathes(tokens, "_", noTextBug, templateMarker);
      var bindings = buildBindings(paths.binding);
      var objectRefs = paths.markedElementList.join("=");
      var createInstance;
      var fnBody;
      var result = {
        keys: bindings.keys,
        l10nKeys: basis.object.keys(bindings.l10n)
      };
      if (tokens.length == 1) paths.path[0] = "a=_";
      if (!uri) uri = basis.path.baseURI + "inline_template" + inlineSeed++ + ".tmpl";
      if (bindings.l10n) {
        var code = [];
        for (var key in bindings.l10n) code.push('case"' + key + '":' + 'if(value==null)value="{' + key + '}";' + "__l10n[token]=value;" + bindings.l10n[key].join("") + "break;");
        result.createL10nSync = compileFunction([ "_", "__l10n", "bind_attr", "TEXT_BUG" ], (source ? "\n// " + source.split(/\r\n?|\n\r?/).join("\n// ") + "\n\n" : "") + "var " + paths.path + ";" + "return function(token, value){" + "switch(token){" + code.join("") + "}" + "}" + "\n\n//# sourceURL=" + basis.path.origin + uri + "_l10n");
      }
      result.createInstance = compileFunction([ "tid", "map", "proto", "tools", "__l10n", "TEXT_BUG" ], (source ? "\n// " + source.split(/\r\n?|\n\r?/).join("\n// ") + "\n\n" : "") + "var getBindings=tools.createBindingFunction([" + bindings.keys.map(function(key) {
        return '"' + key + '"';
      }) + "])," + (bindings.tools.length ? bindings.tools + "," : "") + "Attaches=function(){};" + "Attaches.prototype={" + bindings.keys.map(function(key) {
        return key + ":null";
      }) + "};" + "return function createInstance_(id,obj,onAction,onRebuild,bindings,bindingInterface){" + "var _=proto.cloneNode(true)," + paths.path.concat(bindings.vars) + "," + "instance={" + "context:obj," + "action:onAction," + "rebuild:onRebuild," + (debug ? "debug:function debug(){return[" + bindings.debugList + "]}," : "") + "handler:null," + "bindings:bindings," + "bindingInterface:bindingInterface," + "attaches:null," + "tmpl:{" + [ paths.ref, "templateId_:id", "set:set" ] + "}" + "}" + (objectRefs ? ";if(obj||onAction)" + objectRefs + "=(id<<12)|tid" : "") + bindings.set + ";if(bindings)instance.handler=getBindings(bindings,obj,set,bindingInterface)" + ";" + bindings.l10nCompute + ";return instance" + "}" + "\n\n//# sourceURL=" + basis.path.origin + uri);
      return result;
    };
    module.exports = {
      getFunctions: getFunctions
    };
  },
  "s.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {},
  "a.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./b.js");
    basis.require("./c.js");
    basis.require("./4.js");
    var namespace = this.path;
    var ua = basis.ua;
    var escapeValue = global.encodeURIComponent;
    var FormData = global.FormData;
    var extend = basis.object.extend;
    var objectSlice = basis.object.slice;
    var objectMerge = basis.object.merge;
    var createTransportEvent = basis.net.createTransportEvent;
    var createRequestEvent = basis.net.createRequestEvent;
    var AbstractRequest = basis.net.AbstractRequest;
    var AbstractTransport = basis.net.AbstractTransport;
    var STATE_UNSENT = 0;
    var STATE_OPENED = 1;
    var STATE_HEADERS_RECEIVED = 2;
    var STATE_LOADING = 3;
    var STATE_DONE = 4;
    var STATE = basis.data.STATE;
    var METHODS = "HEAD GET POST PUT PATCH DELETE TRACE LINK UNLINK CONNECT".split(" ");
    var IS_POST_REGEXP = /POST/i;
    var IS_METHOD_WITH_BODY = /^(POST|PUT|PATCH|LINK|UNLINK)$/i;
    var XHRSupport = "native";
    var createXmlHttpRequest = function() {
      if ("XMLHttpRequest" in global) return function() {
        return new XMLHttpRequest;
      };
      var ActiveXObject = global.ActiveXObject;
      if (ActiveXObject) {
        var progID = [ "MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP" ];
        for (var i = 0; XHRSupport = progID[i]; i++) try {
          if (new ActiveXObject(XHRSupport)) return function() {
            return new ActiveXObject(XHRSupport);
          };
        } catch (e) {}
      }
      throw new Error(XHRSupport = "XMLHttpRequest is not supported!");
    }();
    function setRequestHeaders(xhr, requestData) {
      var headers = {};
      if (IS_METHOD_WITH_BODY.test(requestData.method)) {
        if (!FormData || requestData.postBody instanceof FormData == false) headers["Content-Type"] = requestData.contentType + (requestData.encoding ? ";charset=" + requestData.encoding : "");
      } else {
        if (ua.test("ie")) {
          headers["If-Modified-Since"] = "Thu, 01 Jan 1970 00:00:00 GMT";
        }
      }
      basis.object.iterate(extend(headers, requestData.headers), function(key, value) {
        if (value != null && typeof value != "function") this.setRequestHeader(key, value);
      }, xhr);
    }
    function setResponseType(xhr, requestData) {
      if (requestData.responseType && requestData.asynchronous && "responseType" in xhr) try {
        xhr.responseType = requestData.responseType;
      } catch (e) {
        basis.dev.warn("Can't set resposeType `" + requestData.responseType + "` to XMLHttpRequest", requestData);
      }
    }
    function safeJsonParse(content, url) {
      try {
        return basis.json.parse(content);
      } catch (e) {
        basis.dev.warn("basis.net.ajax: Can't parse JSON from " + url, {
          url: url,
          content: content
        });
      }
    }
    function readyStateChangeHandler(readyState) {
      var xhr = this.xhr;
      var newState;
      var newStateData;
      var aborted;
      this.sendDelayTimer_ = clearTimeout(this.sendDelayTimer_);
      if (!xhr) return;
      if (typeof readyState != "number") readyState = xhr.readyState;
      if (readyState == this.prevReadyState_) return;
      this.prevReadyState_ = readyState;
      if (this.debug) basis.dev.log("State: (" + readyState + ") " + [ "UNSENT", "OPENED", "HEADERS_RECEIVED", "LOADING", "DONE" ][readyState]);
      this.emit_readyStateChanged(readyState);
      if (readyState == STATE_DONE) {
        this.clearTimeout();
        xhr.onreadystatechange = basis.fn.$undef;
        aborted = xhr.status == 0;
        if (!aborted && !xhr.responseType) aborted = typeof xhr.responseText == "unknown" || !xhr.responseText && !xhr.getAllResponseHeaders();
        if (aborted) {
          this.emit_abort();
          newState = this.stateOnAbort;
        } else {
          this.processResponse();
          if (this.isSuccessful()) {
            newState = STATE.READY;
            this.emit_success(this.getResponseData());
          } else {
            newState = STATE.ERROR;
            newStateData = this.getResponseError();
            if (!newStateData && this.data.error) {
              basis.dev.warn("Request#getResponseError should not update request data, but returns error data. Please, fix your method implementation, as data updating is deprecated behaviour.");
              newStateData = this.data.error;
            }
            this.emit_failure(newStateData);
          }
        }
        this.emit_complete(this);
      } else newState = STATE.PROCESSING;
      this.setState(newState, newStateData);
    }
    var Request = AbstractRequest.subclass({
      className: namespace + ".Request",
      requestStartTime: 0,
      timeout: 3e4,
      timer_: null,
      sendDelay: null,
      sendDelayTimer_: null,
      lastRequestUrl_: null,
      debug: false,
      emit_readyStateChanged: createRequestEvent("readyStateChanged"),
      init: function() {
        AbstractRequest.prototype.init.call(this);
        this.xhr = createXmlHttpRequest();
      },
      isIdle: function() {
        return this.xhr.readyState == STATE_DONE || this.xhr.readyState == STATE_UNSENT;
      },
      isSuccessful: function() {
        var status = this.xhr.status;
        return status >= 200 && status < 300 || status == 304;
      },
      processResponse: function() {
        this.update({
          contentType: this.xhr.getResponseHeader("content-type"),
          status: this.xhr.status
        });
      },
      getResponseData: function() {
        var xhr = this.xhr;
        if (!xhr.responseType) if (this.responseType == "json" || /^application\/json/i.test(this.data.contentType)) return safeJsonParse(xhr.responseText, this.lastRequestUrl_);
        if ("response" in xhr) return xhr.response;
        return xhr.responseText;
      },
      processErrorResponse: function() {
        basis.dev.warn(namespace + ".Request#processErrorResponse is deprecated now, use Request#getResponseError instead");
        return this.getResponseError();
      },
      getResponseError: function() {
        return {
          code: "SERVER_ERROR",
          msg: !this.responseType ? this.xhr.responseText : this.xhr.response || this.xhr.statusText || "Error"
        };
      },
      prepare: basis.fn.$true,
      prepareRequestData: function(requestData) {
        var params = [];
        var url = requestData.url;
        requestData = objectSlice(requestData);
        for (var key in requestData.params) {
          var value = requestData.params[key];
          if (value == null || value.toString() == null) continue;
          params.push(escapeValue(key) + "=" + escapeValue(value.toString()));
        }
        params = params.join("&");
        if (!requestData.postBody && IS_METHOD_WITH_BODY.test(requestData.method)) {
          requestData.postBody = params || "";
          params = "";
        }
        if (requestData.routerParams) url = url.replace(/:([a-z\_\-][a-z0-9\_\-]+)/gi, function(m, key) {
          if (key in requestData.routerParams) return requestData.routerParams[key]; else return m;
        });
        if (params) url += (url.indexOf("?") == -1 ? "?" : "&") + params;
        requestData.requestUrl = url;
        return requestData;
      },
      doRequest: function() {
        this.send(this.prepareRequestData(this.requestData));
      },
      send: function(requestData) {
        this.update({
          contentType: "",
          status: ""
        });
        if (ua.test("gecko1.8.1-") && requestData.asynchronous) this.xhr = createXmlHttpRequest();
        this.emit_start();
        var xhr = this.xhr;
        this.prevReadyState_ = -1;
        xhr.onreadystatechange = readyStateChangeHandler.bind(this);
        if (!requestData.asynchronous) readyStateChangeHandler.call(this, STATE_UNSENT);
        xhr.open(requestData.method, requestData.requestUrl, requestData.asynchronous);
        this.lastRequestUrl_ = requestData.requestUrl;
        setResponseType(xhr, requestData);
        this.responseType = requestData.responseType || "";
        setRequestHeaders(xhr, requestData);
        this.setTimeout(this.timeout);
        var postBody = requestData.postBody;
        if (IS_METHOD_WITH_BODY.test(requestData.method) && ua.test("ie9-")) {
          if (typeof postBody == "object" && typeof postBody.documentElement != "undefined" && typeof postBody.xml == "string") postBody = postBody.xml; else if (typeof postBody == "string") postBody = postBody.replace(/\r/g, ""); else if (postBody == null || postBody == "") postBody = "[No data]";
        }
        if (this.sendDelay) {
          if (this.sendDelayTimer_) this.sendDelayTimer_ = clearTimeout(this.sendDelayTimer_);
          this.sendDelayTimer_ = setTimeout(function() {
            this.sendDelayTimer_ = null;
            if (this.xhr === xhr && xhr.readyState == STATE_OPENED) xhr.send(postBody);
          }.bind(this), this.sendDelay);
        } else xhr.send(postBody);
        if (this.debug) basis.dev.log("Request over, waiting for response");
        return true;
      },
      repeat: function() {
        if (this.requestData) {
          this.abort();
          this.doRequest();
        }
      },
      abort: function() {
        if (!this.isIdle()) {
          this.clearTimeout();
          this.xhr.abort();
          if (this.xhr.readyState != STATE_DONE && this.xhr.readyState != STATE_UNSENT) readyStateChangeHandler.call(this, STATE_DONE);
        }
      },
      setTimeout: function(timeout) {
        if (!this.xhr.asynchronous) return;
        if ("ontimeout" in this.xhr) {
          this.xhr.timeout = timeout;
          this.xhr.ontimeout = this.timeoutAbort.bind(this);
        } else this.timer_ = setTimeout(this.timeoutAbort.bind(this), timeout);
      },
      clearTimeout: function() {
        if (this.timer_) this.timer_ = clearTimeout(this.timer_);
      },
      timeoutAbort: function() {
        this.update({
          error: {
            code: "TIMEOUT_ERROR",
            message: "Timeout error"
          }
        });
        this.emit_timeout(this);
        this.abort();
      },
      destroy: function() {
        this.abort();
        this.xhr = null;
        AbstractRequest.prototype.destroy.call(this);
      }
    });
    var Transport = AbstractTransport.subclass({
      className: namespace + ".Transport",
      requestClass: Request,
      emit_readyStateChanged: createTransportEvent("readyStateChanged"),
      asynchronous: true,
      method: "GET",
      contentType: "application/x-www-form-urlencoded",
      encoding: null,
      requestHeaders: basis.Class.extensibleProperty(),
      responseType: "",
      params: null,
      routerParams: null,
      url: "",
      postBody: null,
      init: function() {
        AbstractTransport.prototype.init.call(this);
        this.params = objectSlice(this.params);
        this.routerParams = objectSlice(this.routerParams);
      },
      setParam: function(name, value) {
        this.params[name] = value;
      },
      setParams: function(params) {
        this.clearParams();
        for (var key in params) this.setParam(key, params[key]);
      },
      removeParam: function(name) {
        delete this.params[name];
      },
      clearParams: function() {
        for (var key in this.params) delete this.params[key];
      },
      prepareRequestData: function(requestData) {
        if (!requestData.url && !this.url) throw new Error("URL is not defined");
        extend(requestData, {
          headers: objectMerge(this.requestHeaders, requestData.headers),
          params: objectMerge(this.params, requestData.params),
          routerParams: objectMerge(this.routerParams, requestData.routerParams)
        });
        basis.object.complete(requestData, {
          asynchronous: this.asynchronous,
          url: this.url,
          method: this.method,
          contentType: this.contentType,
          encoding: this.encoding,
          postBody: this.postBody,
          responseType: this.responseType
        });
        return requestData;
      }
    });
    module.exports = {
      Request: Request,
      Transport: Transport,
      request: function(config, successCallback, failureCallback) {
        if (typeof config == "string") config = {
          url: config,
          asynchronous: !!(successCallback || failureCallback)
        };
        var transport = new Transport(config);
        transport.addHandler({
          success: successCallback && function(sender, req, data) {
            successCallback(data);
          },
          failure: failureCallback && function(sender, req, error) {
            failureCallback(error);
          },
          complete: function() {
            basis.nextTick(function() {
              transport.destroy();
            });
          }
        });
        var req = transport.request();
        if (!req.requestData.asynchronous) return req.getResponseData();
      }
    };
  },
  "b.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    var namespace = this.path;
    var document = global.document;
    var userAgent = global.navigator && global.navigator.userAgent || "";
    var opera = global.opera;
    var versions = {};
    var answers = {};
    var browserName = "unknown";
    var browserPrettyName = "unknown";
    var browserNames = {
      MSIE: [ "Internet Explorer", "msie", "ie" ],
      Gecko: [ "Gecko", "gecko" ],
      Safari: [ "Safari", "safari" ],
      "iPhone OS": [ "iPhone", "iphone" ],
      AdobeAir: [ "AdobeAir", "air" ],
      AppleWebKit: [ "WebKit" ],
      Chrome: [ "Chrome", "chrome" ],
      FireFox: [ "FireFox", "firefox", "ff" ],
      Iceweasel: [ "FireFox", "firefox", "ff" ],
      Shiretoko: [ "FireFox", "firefox", "ff" ],
      Opera: [ "Opera", "opera" ]
    };
    for (var name in browserNames) {
      if (name == "MSIE" && opera) continue;
      if (name == "Safari" && /chrome/i.test(userAgent)) continue;
      if (name == "AppleWebKit" && /iphone/i.test(userAgent)) continue;
      if (userAgent.match(new RegExp(name + "." + "(\\d+(\\.\\d+)*)", "i"))) {
        var names = browserNames[name];
        var version = opera && typeof opera.version == "function" ? opera.version() : RegExp.$1;
        var verNumber = versionToInt(version);
        browserName = names[0] + verNumber;
        browserPrettyName = names[0] + " " + version;
        for (var j = 0; j < names.length; j++) versions[names[j].toLowerCase()] = verNumber;
      }
    }
    function versionToInt(version) {
      var base = 1e6;
      var part = String(version).split(".");
      for (var i = 0, result = 0; i < 4 && i < part.length; i++, base /= 100) result += part[i] * base;
      return result;
    }
    function testBrowser(browserName) {
      var forTest = browserName.toLowerCase();
      if (forTest in answers) return answers[forTest];
      var m = forTest.match(/^([a-z]+)(([\d\.]+)([+-=]?))?$/i);
      if (m) {
        answers[forTest] = false;
        var name = m[1].toLowerCase();
        var version = versionToInt(m[3]);
        var operation = m[4] || "=";
        var cmpVersion = versions[name];
        if (cmpVersion) return answers[forTest] = !version || operation == "=" && cmpVersion == version || operation == "+" && cmpVersion >= version || operation == "-" && cmpVersion < version;
      } else {
        basis.dev.warn("Bad browser version description in Browser.test() function: " + forTest);
      }
      return false;
    }
    var cookies = {
      set: function(name, value, expire, path, domain) {
        document.cookie = name + "=" + (value == null ? "" : escape(value)) + ";path=" + (path || (location.pathname.indexOf("/") == 0 ? "" : "/") + location.pathname) + (expire ? ";expires=" + (new Date(Date.now() + expire * 1e3)).toGMTString() : "") + (domain ? ";domain=" + domain : "");
      },
      get: function(name) {
        var m = document.cookie.match(new RegExp("(^|;)\\s*" + name + "\\s*=\\s*(.*?)\\s*(;|$)"));
        return m && unescape(m[2]);
      },
      remove: function(name, path, domain) {
        document.cookie = name + "=;expires=" + (new Date(0)).toGMTString() + ";path=" + (path || (location.pathname.indexOf("/") == 0 ? "" : "/") + location.pathname) + (domain ? ";domain=" + domain : "");
      }
    };
    module.exports = {
      prettyName: browserPrettyName,
      is: testBrowser,
      test: function() {
        return basis.array(arguments).some(testBrowser);
      },
      cookies: cookies
    };
  },
  "c.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./4.js");
    var namespace = this.path;
    var extend = basis.object.extend;
    var arrayFrom = basis.array.from;
    var objectSlice = basis.object.slice;
    var objectMerge = basis.object.merge;
    var createEvent = basis.event.create;
    var STATE = basis.data.STATE;
    var DataObject = basis.data.Object;
    var Emitter = basis.event.Emitter;
    function createTransportEvent(eventName) {
      var event = createEvent(eventName);
      return function transportEvent() {
        event.apply(transportDispatcher, arguments);
        if (this.service) event.apply(this.service, arguments);
        event.apply(this, arguments);
      };
    }
    function createRequestEvent(eventName) {
      var event = createEvent(eventName);
      return function requestEvent() {
        var args = [ this ].concat(arrayFrom(arguments));
        event.apply(transportDispatcher, args);
        if (this.transport) this.transport["emit_" + eventName].apply(this.transport, args);
        event.apply(this, arguments);
      };
    }
    var inprogressTransports = [];
    var transportDispatcher = new Emitter({
      abort: function() {
        var result = arrayFrom(inprogressTransports);
        for (var i = 0; i < result.length; i++) result[i].abort();
        return result;
      },
      handler: {
        start: function(request) {
          basis.array.add(inprogressTransports, request.transport);
        },
        complete: function(request) {
          basis.array.remove(inprogressTransports, request.transport);
        }
      }
    });
    var AbstractRequest = DataObject.subclass({
      className: namespace + ".AbstractRequest",
      influence: null,
      initData: null,
      requestData: null,
      transport: null,
      stateOnAbort: STATE.UNDEFINED,
      emit_start: createRequestEvent("start"),
      emit_timeout: createRequestEvent("timeout"),
      emit_abort: createRequestEvent("abort"),
      emit_success: createRequestEvent("success"),
      emit_failure: createRequestEvent("failure"),
      emit_complete: createRequestEvent("complete"),
      emit_stateChanged: function(oldState) {
        DataObject.prototype.emit_stateChanged.call(this, oldState);
        if (this.influence) for (var i = 0; i < this.influence.length; i++) this.influence[i].setState(this.state, this.state.data);
      },
      init: function() {
        DataObject.prototype.init.call(this);
        this.influence = [];
      },
      setInfluence: function(influence) {
        this.influence = arrayFrom(influence);
      },
      clearInfluence: function() {
        this.influence = null;
      },
      doRequest: basis.fn.$undef,
      getResponseData: basis.fn.$undef,
      destroy: function() {
        DataObject.prototype.destroy.call(this);
        this.initData = null;
        this.requestData = null;
        this.clearInfluence();
      }
    });
    var TRANSPORT_REQUEST_HANDLER = {
      start: function(sender, request) {
        basis.array.add(this.inprogressRequests, request);
      },
      complete: function(sender, request) {
        basis.array.remove(this.inprogressRequests, request);
      }
    };
    var TRANSPORT_POOL_LIMIT_HANDLER = {
      complete: function() {
        var nextRequest = this.requestQueue.shift();
        if (nextRequest) {
          basis.nextTick(function() {
            nextRequest.doRequest();
          });
        }
      }
    };
    var AbstractTransport = Emitter.subclass({
      className: namespace + ".AbstractTransport",
      requestClass: AbstractRequest,
      requests: null,
      poolLimit: null,
      poolHashGetter: basis.fn.$true,
      emit_start: createTransportEvent("start"),
      emit_timeout: createTransportEvent("timeout"),
      emit_abort: createTransportEvent("abort"),
      emit_success: createTransportEvent("success"),
      emit_failure: createTransportEvent("failure"),
      emit_complete: createTransportEvent("complete"),
      init: function() {
        this.requests = {};
        this.requestQueue = [];
        this.inprogressRequests = [];
        Emitter.prototype.init.call(this);
        this.addHandler(TRANSPORT_REQUEST_HANDLER, this);
        if (this.poolLimit) this.addHandler(TRANSPORT_POOL_LIMIT_HANDLER, this);
      },
      getRequestByHash: function(requestHashId) {
        var request = this.requests[requestHashId];
        if (!request) {
          for (var id in this.requests) if (this.requests[id].isIdle() && this.requestQueue.indexOf(this.requests[id]) == -1) {
            request = this.requests[id];
            delete this.requests[id];
            break;
          }
          if (!request) request = new this.requestClass({
            transport: this
          });
          this.requests[requestHashId] = request;
        }
        return request;
      },
      prepare: basis.fn.$true,
      prepareRequestData: basis.fn.$self,
      request: function(config) {
        if (!this.prepare()) return;
        var requestData = objectSlice(config);
        var requestHashId = this.poolHashGetter(this.prepareRequestData(requestData));
        var request = this.getRequestByHash(requestHashId, true);
        if (request.initData) request.abort();
        request.initData = requestData;
        request.requestData = requestData;
        request.setInfluence(requestData.influence || this.influence);
        if (this.poolLimit && this.inprogressRequests.length >= this.poolLimit) {
          this.requestQueue.push(request);
          request.setState(STATE.PROCESSING);
        } else request.doRequest();
        return request;
      },
      abort: function() {
        for (var i = 0, request; request = this.inprogressRequests[i]; i++) request.abort();
        for (var i = 0, request; request = this.requestQueue[i]; i++) request.setState(STATE.ERROR);
        this.inprogressRequests = [];
        this.requestQueue = [];
      },
      stop: function() {
        if (!this.stopped) {
          this.stoppedRequests = this.inprogressRequests.concat(this.requestQueue);
          this.abort();
          this.stopped = true;
        }
      },
      resume: function() {
        if (this.stoppedRequests) {
          for (var i = 0, request; request = this.stoppedRequests[i]; i++) request.transport.request(request.initData);
          this.stoppedRequests = null;
        }
        this.stopped = false;
      },
      destroy: function() {
        for (var i in this.requests) this.requests[i].destroy();
        this.requests = {};
        this.inprogressRequests = null;
        this.requestQueue = null;
        this.stoppedRequests = null;
        Emitter.prototype.destroy.call(this);
      }
    });
    module.exports = {
      createTransportEvent: createTransportEvent,
      createRequestEvent: createRequestEvent,
      transportDispatcher: transportDispatcher,
      AbstractRequest: AbstractRequest,
      AbstractTransport: AbstractTransport
    };
  },
  "z.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    basis.require("./i.js");
    basis.require("./m.js");
    var ajax = basis.require("./a.js");
    module.exports = function() {
      function userAuthenticated(data) {
        node.update({
          loginDisplay: "none",
          loggedInAs: data.user.name
        });
      }
      var node = new basis.ui.Node({
        autoDelegate: true,
        container: basis.dom.get("auth"),
        template: basis.template.get("#6"),
        data: {
          loginDisplay: "block",
          username: "victor",
          password: "victor1",
          loggedInAs: ""
        },
        satellite: {
          username: {
            instanceOf: basis.ui.field.Text.subclass({
              action: {
                keyup: function(event) {
                  this.owner.update({
                    username: event.sender.value
                  });
                }
              }
            }),
            config: function(owner) {
              return {
                value: owner.data.username
              };
            }
          },
          password: {
            instanceOf: basis.ui.field.Password.subclass({
              action: {
                keyup: function(event) {
                  this.owner.update({
                    password: event.sender.value
                  });
                }
              }
            }),
            config: function(owner) {
              return {
                value: owner.data.password
              };
            }
          }
        },
        binding: {
          loginDisplay: "data:",
          loggedInAs: "data:",
          button: new basis.ui.button.Button({
            caption: "Sign in",
            click: function() {
              this.owner.action.signIn(this.owner, this.owner.data);
            }
          }),
          username: "satellite:username",
          password: "satellite:password"
        },
        action: {
          signIn: function(self, data) {
            profile.signIn.request({
              postBody: JSON.stringify({
                username: data.username,
                password: data.password
              })
            });
          }
        }
      });
      var profile = {
        whoami: new ajax.Transport({
          url: "http://localhost:8888/whoami",
          method: "GET",
          handler: {
            success: function(transport, request, response) {
              if (response.success) {
                userAuthenticated(response);
              }
            }
          }
        }),
        signIn: new ajax.Transport({
          url: "http://localhost:8888/login",
          method: "POST",
          contentType: "application/json",
          handler: {
            success: function(transport, request, response) {
              if (response.success) {
                userAuthenticated(response);
              } else {
                alert("Authentication failed");
              }
            },
            failure: function() {
              alert("Authentication failed");
            }
          }
        })
      };
      profile.whoami.request();
      return node;
    };
  },
  "m.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./2.js");
    basis.require("./3.js");
    basis.require("./j.js");
    basis.require("./8.js");
    basis.require("./5.js");
    basis.require("./n.js");
    basis.require("./1.js");
    basis.require("./o.js");
    var namespace = this.path;
    var Class = basis.Class;
    var Event = basis.dom.event;
    var DOM = basis.dom;
    var complete = basis.object.complete;
    var getter = basis.getter;
    var arrayFrom = basis.array.from;
    var createEvent = basis.event.create;
    var events = basis.event.events;
    var l10nToken = basis.l10n.token;
    var Property = basis.data.value.Property;
    var Selection = basis.dom.wrapper.Selection;
    var UINode = basis.ui.Node;
    var Popup = basis.ui.popup.Popup;
    var dict = basis.l10n.dictionary("./2.l10n");
    var templates = basis.template.define(namespace, {
      Example: basis.resource("./k.tmpl"),
      Description: basis.resource("./l.tmpl"),
      Counter: basis.resource("./m.tmpl"),
      Field: basis.resource("./n.tmpl"),
      File: basis.resource("./o.tmpl"),
      Hidden: basis.resource("./p.tmpl"),
      Text: basis.resource("./q.tmpl"),
      Password: basis.resource("./r.tmpl"),
      Textarea: basis.resource("./s.tmpl"),
      Checkbox: basis.resource("./t.tmpl"),
      Label: basis.resource("./u.tmpl"),
      RadioGroup: basis.resource("./v.tmpl"),
      RadioGroupItem: basis.resource("./w.tmpl"),
      CheckGroup: basis.resource("./x.tmpl"),
      CheckGroupItem: basis.resource("./y.tmpl"),
      Select: basis.resource("./z.tmpl"),
      SelectItem: basis.resource("./10.tmpl"),
      Combobox: basis.resource("./11.tmpl"),
      ComboboxItem: basis.resource("./12.tmpl"),
      ComboboxDropdownList: basis.resource("./13.tmpl"),
      MatchInput: basis.resource("./14.tmpl")
    });
    basis.template.define(namespace + ".native", {
      text: basis.resource("./15.tmpl"),
      password: basis.resource("./16.tmpl"),
      textarea: basis.resource("./17.tmpl"),
      checkbox: basis.resource("./18.tmpl"),
      radio: basis.resource("./19.tmpl"),
      select: basis.resource("./1a.tmpl"),
      file: basis.resource("./1b.tmpl")
    });
    var VALIDITY_INDETERMINATE = "indeterminate";
    var VALIDITY_VALID = "valid";
    var VALIDITY_INVALID = "invalid";
    function getFieldValue(field) {
      return field.getValue();
    }
    var Field = UINode.subclass({
      className: namespace + ".Field",
      childClass: null,
      nextFieldOnEnter: true,
      serializable: true,
      name: "",
      title: "",
      validators: null,
      validity: VALIDITY_INDETERMINATE,
      error: "",
      example: null,
      focused: false,
      defaultValue: undefined,
      value: undefined,
      focusable: true,
      emit_commit: createEvent("commit"),
      emit_change: createEvent("change", "oldValue"),
      emit_validityChanged: createEvent("validityChanged", "oldValidity"),
      emit_errorChanged: createEvent("errorChanged"),
      emit_exampleChanged: createEvent("exampleChanged"),
      emit_descriptionChanged: createEvent("descriptionChanged"),
      emit_fieldInput: createEvent("fieldInput", "event"),
      emit_fieldChange: createEvent("fieldChange", "event"),
      emit_fieldKeydown: createEvent("fieldKeydown", "event"),
      emit_fieldKeypress: createEvent("fieldKeypress", "event"),
      emit_fieldKeyup: createEvent("fieldKeyup", "event") && function(event) {
        if (this.nextFieldOnEnter) {
          if (event.key == event.KEY.ENTER || event.key == event.KEY.CTRL_ENTER) {
            event.preventDefault();
            this.commit();
          } else {
            if (event.key != event.KEY.TAB) this.setValidity();
          }
        }
        events.fieldKeyup.call(this, event);
      },
      emit_fieldFocus: createEvent("fieldFocus", "event") && function(event) {
        this.focused = true;
        events.fieldFocus.call(this, event);
      },
      emit_fieldBlur: createEvent("fieldBlur", "event") && function(event) {
        this.validate(true);
        this.focused = false;
        events.fieldBlur.call(this, event);
      },
      template: templates.Field,
      binding: {
        focused: {
          events: "fieldFocus fieldBlur",
          getter: function(node) {
            return node.focused ? "focused" : "";
          }
        },
        name: "name",
        titleText: "title",
        value: {
          events: "change",
          getter: function(node) {
            return node.getValue();
          }
        },
        defaultValue: {
          getter: "defaultValue"
        },
        validity: {
          events: "validityChanged",
          getter: "validity"
        },
        error: {
          events: "errorChanged",
          getter: "error"
        },
        example: "satellite:",
        description: "satellite:"
      },
      action: "focus blur change keydown keypress keyup input".split(" ").reduce(function(res, item) {
        var eventName = "emit_field" + basis.string.capitalize(item);
        res[item] = function(event) {
          this.syncFieldValue_();
          this[eventName](event);
        };
        return res;
      }, {}),
      satellite: {
        example: {
          events: "exampleChanged",
          existsIf: function(owner) {
            return owner.example;
          },
          instanceOf: UINode.subclass({
            className: namespace + ".Example",
            template: templates.Example,
            binding: {
              example: "owner.example"
            },
            listen: {
              owner: {
                exampleChanged: function() {
                  this.updateBind("example");
                }
              }
            }
          })
        },
        description: {
          events: "descriptionChanged",
          existsIf: function(owner) {
            return owner.description;
          },
          instanceOf: UINode.subclass({
            className: namespace + ".Description",
            template: templates.Description,
            binding: {
              description: "owner.description"
            },
            listen: {
              owner: {
                descriptionChanged: function() {
                  this.updateBind("description");
                }
              }
            }
          })
        }
      },
      init: function() {
        this.validators = arrayFrom(this.validators);
        if (typeof this.defaultValue == "undefined") this.defaultValue = this.value;
        UINode.prototype.init.call(this);
        if (this.value) this.setValue(this.value);
      },
      setExample: function(example) {
        if (example != this.example) {
          this.example = example;
          this.emit_exampleChanged();
        }
      },
      setDescription: function(description) {
        if (description != this.description) {
          this.description = description;
          this.emit_descriptionChanged();
        }
      },
      syncFieldValue_: function() {
        this.setValue(this.getValue());
      },
      getValue: function() {
        return this.value;
      },
      setValue: function(newValue) {
        if (this.value !== newValue) {
          var oldValue = this.value;
          this.value = newValue;
          this.emit_change(oldValue);
        }
      },
      reset: function() {
        this.setValue(this.defaultValue);
        this.setValidity();
      },
      attachValidator: function(validator, validate) {
        if (basis.array.add(this.validators, validator) && validate) this.validate();
      },
      detachValidator: function(validator, validate) {
        if (basis.array.remove(this.validators, validator) && validate) this.validate();
      },
      setValidity: function(validity, message) {
        if (!validity) validity = VALIDITY_INDETERMINATE;
        if (this.validity !== validity) {
          this.validity = validity;
          this.emit_validityChanged();
        }
        if (!message || validity != VALIDITY_INVALID) message = "";
        if (this.error != message) {
          this.error = message;
          this.emit_errorChanged();
        }
      },
      validate: function(onlyValid) {
        var error;
        this.setValidity();
        for (var i = 0; i < this.validators.length; i++) if (error = this.validators[i](this)) {
          if (!onlyValid) this.setValidity(VALIDITY_INVALID, error.message);
          return error;
        }
        if (this.getValue() != "") this.setValidity(VALIDITY_VALID);
      },
      commit: function() {
        this.emit_commit();
      },
      destroy: function() {
        this.validators = null;
        this.error = null;
        this.example = null;
        UINode.prototype.destroy.call(this);
      }
    });
    var File = Field.subclass({
      className: namespace + ".File",
      template: templates.File
    });
    var TextField = Field.subclass({
      className: namespace + ".TextField",
      emit_minLengthChanged: createEvent("minLengthChanged"),
      emit_maxLengthChanged: createEvent("maxLengthChanged"),
      defaultValue: "",
      readOnly: false,
      minLength: 0,
      maxLength: 0,
      autocomplete: "",
      placeholder: "",
      binding: {
        minlength: {
          events: "minLengthChanged",
          getter: function(field) {
            return field.minLength > 0 ? field.minLength : "";
          }
        },
        maxlength: {
          events: "maxLengthChanged",
          getter: function(field) {
            return field.maxLength > 0 ? field.maxLength : "";
          }
        },
        readonly: function(node) {
          return node.readOnly ? "readonly" : "";
        },
        autocomplete: "autocomplete",
        placeholder: "placeholder"
      },
      init: function() {
        if (typeof this.value == "undefined") this.value = "";
        Field.prototype.init.call(this);
        var minLength = this.minLength;
        delete this.minLength;
        this.setMinLength(minLength);
        var maxLength = this.maxLength;
        delete this.maxLength;
        this.setMaxLength(maxLength);
      },
      setValue: function(newValue) {
        return Field.prototype.setValue.call(this, newValue == null ? "" : String(newValue));
      },
      setReadOnly: function(readOnly) {
        this.readOnly = !!readOnly;
        this.updateBind("readonly");
      },
      setMinLength: function(len) {
        len = Math.max(parseInt(len, 10) || 0, 0);
        if (this.minLength != len) {
          if (!this.minLength ^ !len) {
            if (len) this.attachValidator(Validator.MinLength); else this.detachValidator(Validator.MinLength);
          }
          this.minLength = len;
          this.emit_minLengthChanged();
        }
      },
      setMaxLength: function(len) {
        len = Math.max(parseInt(len, 10) || 0, 0);
        if (this.maxLength != len) {
          if (!this.maxLength ^ !len) {
            if (len) this.attachValidator(Validator.MaxLength); else this.detachValidator(Validator.MaxLength);
          }
          this.maxLength = len;
          this.emit_maxLengthChanged();
        }
      },
      syncFieldValue_: function() {
        if (this.tmpl && this.tmpl.field) this.setValue(this.tmpl.field.value);
      }
    });
    var Hidden = TextField.subclass({
      className: namespace + ".Hidden",
      focusable: false,
      template: templates.Hidden
    });
    var Text = TextField.subclass({
      className: namespace + ".Text",
      template: templates.Text
    });
    var Password = TextField.subclass({
      className: namespace + ".Password",
      template: templates.Password
    });
    var Textarea = TextField.subclass({
      className: namespace + ".Textarea",
      nextFieldOnEnter: false,
      symbolsLeft: 0,
      emit_symbolsLeftChanged: createEvent("symbolsLeftChanged"),
      emit_fieldFocus: !window.opera ? TextField.prototype.emit_fieldFocus : function(event) {
        this.contentEditable = true;
        this.contentEditable = false;
        TextField.prototype.emit_fieldFocus.call(this, event);
      },
      template: templates.Textarea,
      binding: {
        availChars: {
          events: "symbolsLeftChanged",
          getter: "symbolsLeft"
        },
        counter: "satellite:"
      },
      action: {
        updateSymbolsLeft: function() {
          this.updateSymbolsLeft();
        }
      },
      satellite: {
        counter: {
          events: "maxLengthChanged",
          existsIf: function(owner) {
            return owner.maxLength > 0;
          },
          instanceOf: UINode.subclass({
            className: namespace + ".Counter",
            template: templates.Counter,
            binding: {
              availChars: function(node) {
                return node.owner.symbolsLeft;
              }
            },
            listen: {
              owner: {
                symbolsLeftChanged: function() {
                  this.updateBind("availChars");
                }
              }
            }
          })
        }
      },
      init: function() {
        TextField.prototype.init.call(this);
        this.updateSymbolsLeft();
      },
      updateSymbolsLeft: function() {
        var symbolsLeft = this.maxLength ? this.maxLength - this.getValue().length : -1;
        if (symbolsLeft <= 0) symbolsLeft = 0;
        if (this.symbolsLeft != symbolsLeft) {
          this.symbolsLeft = symbolsLeft;
          this.emit_symbolsLeftChanged();
        }
      }
    });
    var Checkbox = Field.subclass({
      className: namespace + ".Checkbox",
      value: false,
      indeterminate: false,
      template: templates.Checkbox,
      binding: {
        indeterminate: "indeterminate",
        checked: {
          events: "change",
          getter: function(field) {
            return field.value ? "checked" : "";
          }
        }
      },
      emit_change: function(event) {
        Field.prototype.emit_change.call(this, event);
        this.syncIndeterminate();
      },
      toggle: function() {
        this.setValue(!this.getValue());
      },
      setValue: function(value) {
        return Field.prototype.setValue.call(this, !!value);
      },
      syncFieldValue_: function() {
        if (this.tmpl && this.tmpl.field) this.setValue(!!this.tmpl.field.checked);
      },
      syncIndeterminate: function() {
        this.indeterminate = !this.indeterminate;
        this.updateBind("indeterminate");
        this.indeterminate = !this.indeterminate;
        this.updateBind("indeterminate");
      },
      setIndeterminate: function(value) {
        this.indeterminate = !!value;
        this.syncIndeterminate();
      }
    });
    var Label = Field.subclass({
      className: namespace + ".Label",
      focusable: false,
      template: templates.Label
    });
    var ComplexFieldItem = UINode.subclass({
      className: namespace + ".ComplexFieldItem",
      childClass: null,
      name: "",
      binding: {
        name: "name",
        title: function(node) {
          return node.getTitle();
        },
        value: function(node) {
          return node.getValue();
        },
        checked: {
          events: "select unselect",
          getter: function(item) {
            return item.selected ? "checked" : "";
          }
        }
      },
      action: {
        select: function(event) {
          if (!this.isDisabled()) {
            this.select(this.contextSelection ? this.contextSelection.multiple : false);
            if (event.sender.tagName != "INPUT") event.die();
          }
        }
      },
      titleGetter: basis.getter(function(item) {
        return item.title || item.getValue();
      }),
      valueGetter: getter("value"),
      getTitle: function() {
        return this.titleGetter(this);
      },
      getValue: function() {
        return this.valueGetter(this);
      },
      setName: function(name) {
        if (this.name != name) {
          this.name = name;
          this.updateBind("name");
        }
      }
    });
    var COMPLEXFIELD_SELECTION_HANDLER = {
      itemsChanged: function() {
        this.emit_change();
      }
    };
    var ComplexField = Class(Field, {
      className: namespace + ".ComplexField",
      childClass: ComplexFieldItem,
      selection: {
        multiple: false
      },
      binding: {
        multiple: function(node) {
          return node.selection.multiple;
        }
      },
      listen: {
        selection: {
          itemsChanged: function() {
            this.emit_change();
          }
        }
      },
      getValue: function() {
        var value = this.selection.getItems().map(getFieldValue);
        return this.selection.multiple ? value : value[0];
      },
      setValue: function(value) {
        var selected;
        if (this.selection.multiple) selected = this.childNodes.filter(function(item) {
          return this.indexOf(item.getValue()) != -1;
        }, arrayFrom(value)); else selected = [ basis.array.search(this.childNodes, value, getFieldValue) ];
        this.selection.set(selected);
      }
    });
    var RadioGroup = ComplexField.subclass({
      className: namespace + ".RadioGroup",
      template: templates.RadioGroup,
      childClass: {
        className: namespace + ".RadioGroupItem",
        template: templates.RadioGroupItem
      }
    });
    var CheckGroup = ComplexField.subclass({
      className: namespace + ".CheckGroup",
      template: templates.CheckGroup,
      selection: {
        multiple: true
      },
      childClass: {
        className: namespace + ".CheckGroupItem",
        template: templates.CheckGroupItem
      }
    });
    var Select = ComplexField.subclass({
      className: namespace + ".Select",
      template: templates.Select,
      templateSync: function() {
        ComplexField.prototype.templateSync.call(this);
        this.syncFieldValue_();
      },
      syncFieldValue_: function() {
        if (this.tmpl && this.tmpl.field) {
          var selected;
          if (this.selection.multiple && this.tmpl.field.selectedIndex != -1) selected = this.childNodes.filter(function(item) {
            return item.tmpl && item.tmpl.field && item.tmpl.field.selected;
          }); else selected = [ this.childNodes[this.tmpl.field.selectedIndex] ];
          this.selection.set(selected);
        }
      },
      childClass: {
        className: namespace + ".SelectItem",
        template: templates.SelectItem
      }
    });
    var ComboboxPopupHandler = {
      show: function() {
        this.updateBind("opened");
      },
      hide: function() {
        this.updateBind("opened");
      }
    };
    var ComboboxItem = ComplexFieldItem.subclass({
      className: namespace + ".ComboboxItem",
      template: templates.ComboboxItem,
      binding: {
        title: function(node) {
          return node.getTitle() || " ";
        }
      },
      action: {
        select: function(event) {
          if (!this.isDisabled()) {
            this.select();
            var owner = this.parentNode || this.owner;
            if (owner) owner.hide();
            event.die();
          }
        }
      }
    });
    var COMBOBOX_SELECTION_HANDLER = {
      itemsChanged: function(selection) {
        this.setDelegate(selection.pick());
      }
    };
    var Combobox = ComplexField.subclass({
      className: namespace + ".Combobox",
      childClass: ComboboxItem,
      emit_change: function(event) {
        ComplexField.prototype.emit_change.call(this, event);
        var value = this.getValue();
        if (this.property) this.property.set(value);
      },
      emit_childNodesModified: function(delta) {
        ComplexField.prototype.emit_childNodesModified.call(this, delta);
        if (this.property) this.setValue(this.property.value);
      },
      caption: null,
      popup: null,
      popupClass: Popup.subclass({
        className: namespace + ".ComboboxDropdownList",
        template: templates.ComboboxDropdownList,
        autorotate: 1,
        templateSync: function() {
          Popup.prototype.templateSync.call(this);
          if (this.owner && this.owner.childNodesElement) DOM.insert(this.tmpl.content || this.element, this.owner.childNodesElement);
        }
      }),
      property: null,
      template: templates.Combobox,
      binding: {
        captionItem: "satellite:",
        hiddenField: "satellite:",
        opened: function(node) {
          return node.popup.visible ? "opened" : "";
        }
      },
      satellite: {
        hiddenField: {
          existsIf: function(owner) {
            return owner.name;
          },
          instanceOf: Hidden.subclass({
            className: namespace + ".ComboboxHidden",
            getValue: function() {
              return this.owner.getValue();
            },
            listen: {
              owner: {
                change: function() {
                  this.updateBind("value");
                }
              }
            }
          }),
          config: function(owner) {
            return {
              name: owner.name,
              value: owner.getValue()
            };
          }
        }
      },
      action: {
        togglePopup: function() {
          if (this.isDisabled() || this.popup.visible) this.hide(); else this.show();
        },
        keyup: function(event) {
          var cur = this.selection.pick();
          var next;
          switch (event.key) {
            case event.KEY.DOWN:
              if (event.altKey) {
                if (this.popup.visible) this.hide(); else if (!this.isDisabled()) this.show();
                return;
              }
              next = basis.array.search(DOM.axis(cur || this.firstChild, DOM.AXIS_FOLLOWING_SIBLING), false, "disabled");
              break;
            case event.KEY.UP:
              if (event.altKey) {
                if (this.popup.visible) this.hide(); else if (!this.isDisabled()) this.show();
                return;
              }
              next = basis.array.search(DOM.axis(cur || this.lastChild, DOM.AXIS_PRECEDING_SIBLING), false, "disabled");
              break;
          }
          if (next) {
            next.select();
            this.focus();
          }
          this.emit_fieldKeyup(event);
        },
        keydown: function(event) {
          switch (event.key) {
            case event.KEY.DOWN:
            case event.KEY.UP:
              event.die();
              break;
            case event.KEY.ENTER:
              if (this.popup.visible) this.hide();
              event.die();
              break;
          }
          this.emit_fieldKeydown(event);
        }
      },
      init: function() {
        if (this.property) this.value = this.property.value;
        ComplexField.prototype.init.call(this);
        this.setSatellite("captionItem", new this.childClass({
          delegate: this.selection.pick(),
          owner: this,
          getTitle: function() {
            return this.owner.getTitle();
          },
          getValue: function() {
            return this.owner.getValue();
          },
          handler: {
            delegateChanged: function() {
              this.updateBind("title");
            }
          }
        }));
        this.selection.addHandler(COMBOBOX_SELECTION_HANDLER, this.satellite.captionItem);
        this.popup = new this.popupClass(complete({
          handler: {
            context: this,
            callbacks: ComboboxPopupHandler
          }
        }, this.popup));
        if (this.property) this.property.link(this, this.setValue);
      },
      templateSync: function() {
        UINode.prototype.templateSync.call(this);
        if (this.childNodesElement && this.popup) DOM.insert(this.popup.tmpl.content || this.popup.element, this.childNodesElement);
        this.popup.ignoreClickFor = [ this.tmpl.field ];
      },
      show: function() {
        if (this.tmpl) {
          this.popup.show(this.tmpl.field);
          this.focus();
        }
      },
      hide: function() {
        this.popup.hide();
      },
      getTitle: function() {
        var selected = this.selection.pick();
        return selected && selected.getTitle();
      },
      getValue: function() {
        var selected = this.selection.pick();
        return selected && selected.getValue();
      },
      setValue: function(value) {
        if (this.getValue() !== value) {
          var item = basis.array.search(this.childNodes, value, getFieldValue);
          if (item && !item.isDisabled()) this.selection.set([ item ]); else this.selection.clear();
        }
      },
      destroy: function() {
        if (this.property) {
          this.property.unlink(this);
          this.property = null;
        }
        this.popup.destroy();
        this.popup = null;
        this.satellite.captionItem.setDelegate();
        this.selection.removeHandler(COMBOBOX_SELECTION_HANDLER, this.satellite.captionItem);
        this.setSatellite("captionItem", null);
        ComplexField.prototype.destroy.call(this);
      }
    });
    var MatchProperty = Property.subclass({
      className: namespace + ".MatchProperty",
      matchFunction: function(child, reset) {
        if (!reset) {
          var textNodes = child._original || this.textNodeGetter(child);
          if (!Array.isArray(textNodes)) textNodes = [ textNodes ];
          child._original = textNodes;
          var matchCount = 0;
          for (var i = textNodes.length; i-- > 0; ) {
            var textNode = textNodes[i];
            if (!textNode) continue;
            var p = textNode.nodeValue.split(this.rx);
            if (p.length > 1) {
              if (!child._replaced) child._replaced = {};
              DOM.replace(child._replaced[i] || textNode, child._replaced[i] = DOM.createElement("SPAN.matched", DOM.wrap(p, this.map)));
              matchCount++;
            } else if (child._replaced && child._replaced[i]) {
              DOM.replace(child._replaced[i], textNode);
              delete child._replaced[i];
            }
          }
          return matchCount > 0;
        }
        if (child._replaced) {
          for (var key in child._replaced) DOM.replace(child._replaced[key], child._original[key]);
          delete child._replaced;
          delete child._original;
        }
        return false;
      },
      emit_change: function(oldValue) {
        this.rx = this.regexpGetter(this.value);
        Property.prototype.emit_change.call(this, oldValue);
      },
      extendConstructor_: true,
      init: function() {
        var startPoints = this.startPoints || "";
        this.textNodeGetter = getter(this.textNodeGetter || "tmpl.titleText");
        if (typeof this.regexpGetter != "function") this.regexpGetter = function(value) {
          return new RegExp("(" + startPoints + ")(" + basis.string.forRegExp(value) + ")", "i");
        };
        this.map = {};
        this.map[this.wrapElement || "SPAN.match"] = function(v, i) {
          return i % 3 == 2;
        };
        Property.prototype.init.call(this, "", this.handlers, String.trim);
      }
    });
    var NodeMatchHandler = {
      childNodesModified: function(object, delta) {
        delta.inserted && delta.inserted.forEach(function(child) {
          this.matchFunction(child, this.value == "");
        }, this);
      }
    };
    var Matcher = MatchProperty.subclass({
      className: namespace + ".Matcher",
      emit_change: function(oldValue) {
        MatchProperty.prototype.emit_change.call(this, oldValue);
        this.applyMatch();
      },
      init: function() {
        MatchProperty.prototype.init.call(this);
        this.node.addHandler(NodeMatchHandler, this);
      },
      applyMatch: function() {
        this.node.childNodes.forEach(function(child) {
          this.matchFunction(child, this.value == "");
        }, this);
      }
    });
    var MatchFilter = MatchProperty.subclass({
      className: namespace + ".MatchFilter",
      emit_change: function(oldValue) {
        MatchProperty.prototype.emit_change.call(this, oldValue);
        this.node.setMatchFunction(this.value ? this.matchFunction.bind(this) : null);
      }
    });
    var MatchInput = Text.subclass({
      className: namespace + ".MatchInput",
      template: templates.MatchInput,
      matchFilterClass: MatchFilter,
      emit_fieldKeyup: function(event) {
        Text.prototype.emit_fieldKeyup.call(this, event);
        this.matchFilter.set(this.getValue());
      },
      emit_change: function(event) {
        Text.prototype.emit_change.call(this, event);
        this.matchFilter.set(this.getValue());
      },
      init: function() {
        Text.prototype.init.call(this);
        this.matchFilter = new this.matchFilterClass(this.matchFilter);
      }
    });
    var REGEXP_EMAIL = /^([a-z0-9а-яА-ЯёЁ\.\-\_]+|[a-z0-9а-яА-ЯёЁ\.\-\_]+\+[a-z0-9а-яА-ЯёЁ\.\-\_]+)\@(([a-z0-9а-яА-ЯёЁ][a-z0-9а-яА-ЯёЁ\-]*\.)+[a-zа-яА-ЯёЁ]{2,6}|(\d{1,3}\.){3}\d{1,3})$/i;
    var REGEXP_URL = /^(https?\:\/\/)?((\d{1,3}\.){3}\d{1,3}|([a-zA-Zа-яА-ЯёЁ0-9][a-zA-Zа-яА-ЯёЁ\d\-\._]+\.)+[a-zA-Zа-яА-ЯёЁ]{2,7})(:\d+)?(\/[^\?]*(\?\S+(\=\S*))*(\#\S*)?)?$/i;
    var ValidatorError = Class(null, {
      className: namespace + ".ValidatorError",
      init: function(field, message) {
        this.field = field;
        this.message = String(message);
      }
    });
    var Validator = {
      RegExp: function(regexp) {
        if (regexp.constructor != RegExp) regexp = new RegExp(regexp);
        return function(field) {
          var value = String(field.getValue());
          if (value != "" && !value.match(regexp)) return new ValidatorError(field, dict.token("validator.regExpWrongFormat"));
        };
      },
      Required: function(field) {
        var value = field.getValue();
        if (basis.fn.$isNull(value) || String(value).trim() == "") return new ValidatorError(field, dict.token("validator.required"));
      },
      Number: function(field) {
        var value = field.getValue();
        if (isNaN(value)) return new ValidatorError(field, dict.token("validator.numberWrongFormat"));
      },
      Currency: function(field) {
        var value = field.getValue();
        if (isNaN(value)) return new ValidatorError(field, dict.token("validator.currencyWrongFormat"));
        if (value <= 0) return new ValidatorError(field, dict.token("validator.currencyMustBeGreaterZero"));
      },
      Email: function(field) {
        var value = String(field.getValue()).trim();
        if (value != "" && !value.match(REGEXP_EMAIL)) return new ValidatorError(field, dict.token("validator.emailWrongFormat"));
      },
      Url: function(field) {
        var value = String(field.getValue()).trim();
        if (value != "" && !value.match(REGEXP_URL)) return new ValidatorError(field, dict.token("validator.urlWrongFormat"));
      },
      MinLength: function(field) {
        var value = field.getValue();
        var length = basis.fn.$isNotNull(value.length) ? value.length : String(value).length;
        if (value && length < field.minLength) return new ValidatorError(field, basis.string.format(String(dict.token("validator.minLengthError")), field.minLength));
      },
      MaxLength: function(field) {
        var value = field.getValue();
        var length = basis.fn.$isNotNull(value.length) ? value.length : String(value).length;
        if (length > field.maxLength) return new ValidatorError(field, basis.string.format(String(dict.token("validator.maxLengthError")), field.maxLength));
      }
    };
    var fieldType2Class = {
      hidden: Hidden,
      file: File,
      text: Text,
      password: Password,
      textarea: Textarea,
      checkbox: Checkbox,
      label: Label,
      select: Select,
      combobox: Combobox,
      radiogroup: RadioGroup,
      checkgroup: CheckGroup
    };
    function createField(config) {
      var fieldType = config && config.type || "text";
      if (fieldType2Class.hasOwnProperty(fieldType)) return new fieldType2Class[fieldType](config); else throw "Unknown field type `" + fieldType + "`";
    }
    module.exports = {
      validator: Validator,
      ValidatorError: ValidatorError,
      create: createField,
      addFieldType: function(type, fieldClass) {
        if (!fieldClass.isSubclassOf(Field)) throw "basis.ui.field.addFieldType: fieldClass is not a subclass of Field (ignored)";
        fieldType2Class[type] = fieldClass;
      },
      Field: Field,
      Hidden: Hidden,
      File: File,
      TextField: TextField,
      Text: Text,
      Password: Password,
      Textarea: Textarea,
      Checkbox: Checkbox,
      Label: Label,
      ComplexFieldItem: ComplexFieldItem,
      ComplexField: ComplexField,
      Select: Select,
      RadioGroup: RadioGroup,
      CheckGroup: CheckGroup,
      Combobox: Combobox,
      Matcher: Matcher,
      MatchProperty: MatchProperty,
      MatchFilter: MatchFilter,
      MatchInput: MatchInput
    };
  },
  "n.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./4.js");
    var namespace = this.path;
    var getter = basis.getter;
    var cleaner = basis.cleaner;
    var Emitter = basis.event.Emitter;
    var AbstractData = basis.data.AbstractData;
    var Value = basis.data.Value;
    var STATE = basis.data.STATE;
    var Property = Value.subclass({
      className: namespace + ".Property",
      extendConstructor_: false,
      init: function(initValue, handler, proxy) {
        this.value = initValue;
        this.handler = handler;
        this.proxy = proxy;
        Value.prototype.init.call(this);
      }
    });
    var OBJECTSET_STATE_PRIORITY = STATE.priority;
    var OBJECTSET_HANDLER = {
      stateChanged: function() {
        this.fire(false, true);
      },
      update: function() {
        this.fire(true);
      },
      change: function() {
        this.fire(true);
      },
      destroy: function(object) {
        this.remove(object);
      }
    };
    var ObjectSet = Value.subclass({
      className: namespace + ".ObjectSet",
      objects: null,
      value: 0,
      valueChanged_: false,
      calculateValue: function() {
        return this.value + 1;
      },
      calculateOnInit: false,
      statePriority: OBJECTSET_STATE_PRIORITY,
      stateChanged_: true,
      timer_: false,
      init: function() {
        Value.prototype.init.call(this);
        var objects = this.objects;
        this.objects = [];
        if (objects && Array.isArray(objects)) {
          this.lock();
          this.add.apply(this, objects);
          this.unlock();
        }
        this.valueChanged_ = this.stateChanged_ = !!this.calculateOnInit;
        this.update();
      },
      add: function() {
        for (var i = 0, len = arguments.length; i < len; i++) {
          var object = arguments[i];
          if (object instanceof AbstractData) {
            if (basis.array.add(this.objects, object)) object.addHandler(OBJECTSET_HANDLER, this);
          } else throw this.constructor.className + "#add: Instance of AbstractData required";
        }
        this.fire(true, true);
      },
      remove: function(object) {
        if (basis.array.remove(this.objects, object)) object.removeHandler(OBJECTSET_HANDLER, this);
        this.fire(true, true);
      },
      clear: function() {
        for (var i = 0, object; object = this.objects[i]; i++) object.removeHandler(OBJECTSET_HANDLER, this);
        this.objects.length = 0;
        this.fire(true, true);
      },
      fire: function(valueChanged, stateChanged) {
        if (!this.locked) {
          this.valueChanged_ = this.valueChanged_ || !!valueChanged;
          this.stateChanged_ = this.stateChanged_ || !!stateChanged;
          if (!this.timer_ && (this.valueChanged_ || this.stateChanged_)) this.timer_ = basis.setImmediate(this.update.bind(this));
        }
      },
      lock: function() {
        this.locked = true;
      },
      unlock: function() {
        this.locked = false;
      },
      update: function() {
        var valueChanged = this.valueChanged_;
        var stateChanged = this.stateChanged_;
        this.valueChanged_ = false;
        this.stateChanged_ = false;
        this.timer_ = basis.clearImmediate(this.timer_);
        if (!cleaner.globalDestroy) {
          if (valueChanged) this.set(this.calculateValue());
          if (stateChanged) {
            var len = this.objects.length;
            if (!len) this.setState(STATE.UNDEFINED); else {
              var maxWeight = -2;
              var curObject;
              for (var i = 0; i < len; i++) {
                var object = this.objects[i];
                var weight = this.statePriority.indexOf(String(object.state));
                if (weight > maxWeight) {
                  curObject = object;
                  maxWeight = weight;
                }
              }
              if (curObject) this.setState(curObject.state, curObject.state.data);
            }
          }
        }
      },
      destroy: function() {
        this.lock();
        this.clear();
        if (this.timer_) basis.clearImmediate(this.timer_);
        Value.prototype.destroy.call(this);
      }
    });
    var Expression = Property.subclass({
      className: namespace + ".Expression",
      init: function(args, calc) {
        Value.prototype.init.call(this);
        var args = basis.array(arguments);
        var calc = args.pop();
        if (typeof calc != "function") {
          basis.dev.warn(this.constructor.className + ": last argument of constructor must be a function");
          calc = basis.fn.$undef;
        }
        if (args.length == 1) {
          args[0].link(this, function(value) {
            this.set(calc.call(this, value));
          });
        }
        if (args.length > 1) {
          var changeWatcher = new ObjectSet({
            objects: args,
            calculateOnInit: true,
            calculateValue: function() {
              return calc.apply(this, args.map(function(item) {
                return item.value;
              }));
            }
          });
          changeWatcher.link(this, this.set);
          this.addHandler({
            destroy: function() {
              if (!cleaner.globalDestroy) changeWatcher.destroy();
            }
          });
        }
      }
    });
    module.exports = {
      Property: Property,
      ObjectSet: ObjectSet,
      Expression: Expression
    };
  },
  "o.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./3.js");
    basis.require("./j.js");
    basis.require("./8.js");
    basis.require("./p.js");
    basis.require("./q.js");
    basis.require("./2.js");
    basis.require("./1.js");
    var namespace = this.path;
    var document = global.document;
    var documentElement = document && document.documentElement;
    var Class = basis.Class;
    var DOM = basis.dom;
    var Event = basis.dom.event;
    var cssom = basis.cssom;
    var layout = basis.layout;
    var getter = basis.getter;
    var arrayFrom = basis.array.from;
    var createEvent = basis.event.create;
    var getOffsetParent = basis.layout.getOffsetParent;
    var getBoundingRect = basis.layout.getBoundingRect;
    var getViewportRect = basis.layout.getViewportRect;
    var UINode = basis.ui.Node;
    var templates = basis.template.define(namespace, {
      Popup: basis.resource("./h.tmpl"),
      Balloon: basis.resource("./i.tmpl"),
      popupManager: basis.resource("./j.tmpl")
    });
    var LEFT = "LEFT";
    var RIGHT = "RIGHT";
    var TOP = "TOP";
    var BOTTOM = "BOTTOM";
    var CENTER = "CENTER";
    var ORIENTATION = {
      VERTICAL: "V",
      HORIZONTAL: "H"
    };
    var ROTATE_MATRIX = String("LTRTRBLBLCCTRCCBCCCCCCCC");
    var LETTER_TO_SIDE = {
      L: LEFT,
      R: RIGHT,
      T: TOP,
      B: BOTTOM,
      C: CENTER
    };
    var FLIP = {
      LEFT: RIGHT,
      RIGHT: LEFT,
      TOP: BOTTOM,
      BOTTOM: TOP,
      CENTER: CENTER
    };
    var DEFAULT_DIR = [ RIGHT, BOTTOM, RIGHT, TOP ].join(" ");
    var DIR_MAP = function() {
      var h = [ LEFT, CENTER, RIGHT ];
      var v = [ TOP, CENTER, BOTTOM ];
      var result = {};
      var perm = {};
      for (var i = 0; i < 3; i++) for (var j = 0; j < 3; j++) {
        perm[h[i] + " " + v[j]] = h[i] + " " + v[j];
        perm[v[j] + " " + h[i]] = h[i] + " " + v[j];
      }
      for (var p1 in perm) for (var p2 in perm) result[p1 + " " + p2] = perm[p1] + " " + perm[p2];
      return result;
    }();
    function normalizeDir(value, valueOnFailure) {
      return DIR_MAP[typeof value == "string" && value.toUpperCase()] || valueOnFailure;
    }
    function resolveRelBox(relPoint, offsetParent) {
      if (Array.isArray(relPoint)) return {
        left: relPoint[0],
        right: relPoint[0],
        width: 0,
        top: relPoint[1],
        bottom: relPoint[1],
        height: 0
      };
      return getBoundingRect(relPoint, offsetParent);
    }
    var Popup = Class(UINode, {
      className: namespace + ".Popup",
      template: templates.Popup,
      binding: {
        visible: {
          events: "show hide",
          getter: function(node) {
            return node.visible ? "visible" : "hidden";
          }
        },
        orientation: {
          events: "layoutChanged",
          getter: function(node) {
            return (node.orientation + "-" + node.dir.split(" ").slice(2, 4).join("-")).toLowerCase();
          }
        }
      },
      action: {
        hide: function() {
          this.hide();
        }
      },
      emit_beforeShow: createEvent("beforeShow"),
      emit_show: createEvent("show"),
      emit_hide: createEvent("hide"),
      emit_realign: createEvent("realign"),
      emit_layoutChanged: createEvent("layoutChanged", "oldOrientation", "oldDir"),
      visible: false,
      autorotate: false,
      autoRealign: true,
      zIndex: 0,
      dir: "",
      defaultDir: DEFAULT_DIR,
      orientation: ORIENTATION.VERTICAL,
      hideOnAnyClick: true,
      hideOnKey: false,
      hideOnScroll: true,
      ignoreClickFor: null,
      init: function() {
        UINode.prototype.init.call(this);
        this.ignoreClickFor = arrayFrom(this.ignoreClickFor);
        if (this.dir) {
          this.dir = normalizeDir(this.dir, DEFAULT_DIR);
          this.defaultDir = this.dir;
        } else {
          this.defaultDir = normalizeDir(this.defaultDir, DEFAULT_DIR);
          this.dir = this.defaultDir;
        }
        this.setLayout(this.defaultDir, this.orientation);
      },
      templateSync: function() {
        UINode.prototype.templateSync.call(this);
        this.realign();
      },
      setLayout: function(dir, orientation, noRealign) {
        var oldDir = this.dir;
        var oldOrientation = this.orientation;
        this.dir = normalizeDir(dir, this.dir);
        if (typeof orientation == "string") this.orientation = orientation;
        if (oldDir != this.dir || oldOrientation != this.orientation) {
          this.emit_layoutChanged(oldOrientation, oldDir);
          if (!noRealign) this.realign();
        }
      },
      flip: function(orientation) {
        var dir = this.dir.split(" ");
        var v = orientation == ORIENTATION.VERTICAL;
        dir[0 + v] = FLIP[dir[0 + v]];
        dir[2 + v] = FLIP[dir[2 + v]];
        this.setLayout(dir.join(" "));
      },
      rotate: function(offset) {
        var dir = this.dir.split(" ");
        var result = [];
        offset = (offset % 4 + 4) % 4;
        if (!offset) return dir;
        var a = dir[0].charAt(0);
        var b = dir[1].charAt(0);
        var idx = ROTATE_MATRIX.indexOf(a + b) >> 1;
        var index = (idx & 252) + ((idx & 3) + offset & 3) << 1;
        result.push(LETTER_TO_SIDE[ROTATE_MATRIX.charAt(index)], LETTER_TO_SIDE[ROTATE_MATRIX.charAt(index + 1)]);
        var a = dir[2].charAt(0);
        var b = dir[3].charAt(0);
        var idx = ROTATE_MATRIX.indexOf(a + b) >> 1;
        offset = a != "C" && b != "C" && dir[0] == dir[2] != (dir[1] == dir[3]) ? -offset + 4 : offset;
        var index = (idx & 252) + ((idx & 3) + offset & 3) << 1;
        result.push(LETTER_TO_SIDE[ROTATE_MATRIX.charAt(index)], LETTER_TO_SIDE[ROTATE_MATRIX.charAt(index + 1)]);
        return result;
      },
      isFitToViewport: function(dir) {
        if (this.visible && this.relElement) {
          var offsetParent = getOffsetParent(this.element);
          var box = resolveRelBox(this.relElement, offsetParent);
          var viewport = getViewportRect(offsetParent);
          var width = this.element.offsetWidth;
          var height = this.element.offsetHeight;
          dir = normalizeDir(dir, this.dir).split(" ");
          var pointX = dir[0] == CENTER ? box.left + (box.width >> 1) : box[dir[0].toLowerCase()];
          var pointY = dir[1] == CENTER ? box.top + (box.height >> 1) : box[dir[1].toLowerCase()];
          if (dir[2] != LEFT && pointX < width >> (dir[2] == CENTER) || dir[2] != RIGHT && viewport.width - pointX + viewport.left < width >> (dir[2] == CENTER) || dir[3] != TOP && pointY < height >> (dir[3] == CENTER) || dir[3] != BOTTOM && viewport.height - pointY + viewport.top < height >> (dir[3] == CENTER)) return false;
          return {
            x: pointX,
            y: pointY
          };
        }
      },
      setZIndex: function(zIndex) {
        this.zIndex = isNaN(zIndex) ? "auto" : zIndex;
        cssom.setStyle(this.element, {
          "z-index": zIndex
        });
      },
      realign: function() {
        this.setZIndex(this.zIndex);
        if (this.visible && this.relElement) {
          var dir = this.dir.split(" ");
          var point;
          var rotateOffset = 0;
          var curDir = dir;
          var dirH = dir[2];
          var dirV = dir[3];
          var maxRotate = typeof this.autorotate == "number" || !this.autorotate.length ? 3 : this.autorotate.length;
          var offsetParent = getOffsetParent(this.element);
          while (this.autorotate && rotateOffset <= maxRotate) {
            if (point = this.isFitToViewport(curDir.join(" "))) {
              dirH = curDir[2];
              dirV = curDir[3];
              this.setLayout(curDir.join(" "), null, true);
              break;
            }
            if (rotateOffset == maxRotate) break;
            if (Array.isArray(this.autorotate)) {
              var rotate = this.autorotate[rotateOffset++];
              if (typeof rotate == "string") curDir = normalizeDir(rotate, curDir.join(" ")).split(" "); else curDir = this.rotate(rotate);
            } else curDir = this.rotate(++rotateOffset * this.autorotate);
          }
          if (!point) {
            var box = resolveRelBox(this.relElement, offsetParent);
            point = {
              x: dir[0] == CENTER ? box.left + (box.width >> 1) : box[dir[0].toLowerCase()],
              y: dir[1] == CENTER ? box.top + (box.height >> 1) : box[dir[1].toLowerCase()]
            };
          }
          var style = {
            left: "auto",
            right: "auto",
            top: "auto",
            bottom: "auto"
          };
          switch (dirH) {
            case LEFT:
              style.left = point.x + "px";
              break;
            case CENTER:
              style.left = Math.round(point.x - this.element.offsetWidth / 2) + "px";
              break;
            case RIGHT:
              style.right = offsetParent.clientWidth - point.x + "px";
              break;
          }
          switch (dirV) {
            case TOP:
              style.top = point.y + "px";
              break;
            case CENTER:
              style.top = Math.round(point.y - this.element.offsetHeight / 2) + "px";
              break;
            case BOTTOM:
              style.bottom = offsetParent.clientHeight - point.y + "px";
              break;
          }
          cssom.setStyle(this.element, style);
          this.emit_realign();
        }
      },
      show: function(relElement, dir, orientation) {
        this.relElement = Array.isArray(relElement) ? relElement : DOM.get(relElement) || this.relElement;
        this.setLayout(normalizeDir(dir, this.defaultDir), orientation);
        if (!this.visible) {
          if (!this.relElement) {
            basis.dev.warn("Popup#show(): relElement missed");
            return;
          }
          cssom.visibility(this.element, false);
          popupManager.appendChild(this);
          this.emit_beforeShow();
          this.visible = true;
          this.realign();
          cssom.visibility(this.element, true);
          this.emit_show();
        } else this.realign();
      },
      hide: function() {
        if (this.visible) {
          this.visible = false;
          if (this.parentNode) popupManager.removeChild(this);
          this.emit_hide();
        }
      },
      hideAll: function() {
        popupManager.clear();
      },
      destroy: function() {
        this.hide();
        UINode.prototype.destroy.call(this);
      }
    });
    var Balloon = Class(Popup, {
      className: namespace + ".Balloon",
      template: templates.Balloon
    });
    var popupManager = new UINode({
      template: templates.popupManager,
      selection: true,
      emit_childNodesModified: function(delta) {
        if (delta.deleted) for (var i = delta.deleted.length - 1, item; item = delta.deleted[i]; i--) item.hide();
        if (delta.inserted && !delta.deleted && this.childNodes.length == delta.inserted.length) {
          Event.addGlobalHandler("click", this.hideByClick, this);
          Event.addGlobalHandler("keydown", this.hideByKey, this);
          Event.addGlobalHandler("scroll", this.hideByScroll, this);
          Event.addHandler(window, "resize", this.realignAll, this);
        }
        if (this.lastChild) this.lastChild.select(); else {
          Event.removeGlobalHandler("click", this.hideByClick, this);
          Event.removeGlobalHandler("keydown", this.hideByKey, this);
          Event.removeGlobalHandler("scroll", this.hideByScroll, this);
          Event.removeHandler(window, "resize", this.realignAll, this);
        }
        UINode.prototype.emit_childNodesModified.call(this, delta);
      },
      insertBefore: function(newChild, refChild) {
        if (UINode.prototype.insertBefore.call(this, newChild, refChild)) newChild.setZIndex(basis.ui.window ? basis.ui.window.getWindowTopZIndex() : 2001);
      },
      removeChild: function(popup) {
        if (popup) {
          if (popup.hideOnAnyClick && popup.nextSibling) this.removeChild(popup.nextSibling);
          UINode.prototype.removeChild.call(this, popup);
        }
      },
      realignAll: function() {
        for (var popup = this.firstChild; popup; popup = popup.nextSibling) if (popup.autoRealign) popup.realign();
      },
      clear: function() {
        if (this.firstChild) this.removeChild(this.firstChild);
      },
      hideByClick: function(event) {
        if (!this.firstChild) return;
        var ancestorAxis = DOM.axis(event.sender, DOM.AXIS_ANCESTOR_OR_SELF);
        for (var popup = this.lastChild; popup; popup = popup.previousSibling) {
          if (ancestorAxis.indexOf(popup.element) != -1 || ancestorAxis.some(function(element) {
            return popup.ignoreClickFor.indexOf(element) != -1;
          })) {
            while (popup = popup.nextSibling) {
              if (popup.hideOnAnyClick) {
                this.removeChild(popup);
                break;
              }
            }
            return;
          }
        }
        this.removeChild(this.getChild(true, "hideOnAnyClick"));
      },
      hideByKey: function(event) {
        var popup = this.lastChild;
        if (popup && popup.hideOnKey) {
          var result = false;
          if (typeof popup.hideOnKey == "function") result = popup.hideOnKey(event.key); else if (Array.isArray(popup.hideOnKey)) result = popup.hideOnKey.indexOf(event.key) != -1;
          if (result) popup.hide();
        }
      },
      hideByScroll: function(event) {
        var sender = event.sender;
        if (DOM.parentOf(sender, this.element)) return;
        var popup = this.lastChild;
        while (popup) {
          var next = popup.previousSibling;
          if (popup.hideOnScroll && popup.relElement && !Array.isArray(popup.relElement) && popup.offsetParent !== sender && DOM.parentOf(sender, popup.relElement)) popup.hide();
          popup = next;
        }
      }
    });
    basis.doc.body.ready(function(body) {
      DOM.insert(body, popupManager.element, DOM.INSERT_BEGIN);
      popupManager.realignAll();
    });
    module.exports = {
      ORIENTATION: ORIENTATION,
      DIR: {
        LEFT: LEFT,
        RIGHT: RIGHT,
        TOP: TOP,
        BOTTOM: BOTTOM,
        CENTER: CENTER
      },
      Popup: Popup,
      Balloon: Balloon
    };
  },
  "1.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./2.js");
    basis.require("./4.js");
    basis.require("./5.js");
    basis.require("./6.js");
    basis.require("./7.js");
    var namespace = this.path;
    var document = global.document;
    var Class = basis.Class;
    var createEvent = basis.event.create;
    var HtmlTemplate = basis.template.html.Template;
    var htmlTemplateIdMarker = basis.template.html.marker;
    var TemplateSwitcher = basis.template.TemplateSwitcher;
    var DWNode = basis.dom.wrapper.Node;
    var DWPartitionNode = basis.dom.wrapper.PartitionNode;
    var DWGroupingNode = basis.dom.wrapper.GroupingNode;
    var instances = {};
    var notifier = new basis.Token;
    var bindingSeed = 1;
    var unknownEventBindingCheck = {};
    function extendBinding(binding, extension) {
      binding.bindingId = bindingSeed++;
      for (var key in extension) {
        var def = null;
        var value = extension[key];
        if (Node && value instanceof Node || basis.resource.isResource(value)) {
          def = {
            events: "satelliteChanged",
            getter: function(key, satellite) {
              var resource = typeof satellite == "function" ? satellite : null;
              var init = function(node) {
                init = false;
                if (resource) {
                  satellite = resource();
                  if (satellite instanceof Node == false) return;
                  resource = null;
                }
                node.setSatellite(key, satellite);
                if (node.satellite[key] !== satellite) basis.dev.warn("basis.ui.binding: implicit satellite `" + key + "` attach to owner failed");
              };
              return function(node) {
                if (init) init(node);
                return resource || (node.satellite[key] ? node.satellite[key].element : null);
              };
            }(key, value)
          };
        } else {
          if (value) {
            if (typeof value == "string") value = BINDING_PRESET.process(key, value); else if (value.bindingBridge) value = basis.fn.$const(value);
            if (typeof value != "object") {
              def = {
                getter: typeof value == "function" ? value : basis.getter(value)
              };
            } else if (Array.isArray(value)) {
              def = {
                events: value[0],
                getter: basis.getter(value[1])
              };
            } else {
              def = {
                events: value.events,
                getter: basis.getter(value.getter)
              };
            }
          }
        }
        binding[key] = def;
      }
    }
    var BINDING_PRESET = function() {
      var presets = {};
      var prefixRegExp = /^([a-z_][a-z0-9_]*):(.*)/i;
      return {
        add: function(prefix, func) {
          if (!presets[prefix]) {
            presets[prefix] = func;
          } else {
            basis.dev.warn("Preset `" + prefix + "` already exists, new definition ignored");
          }
        },
        process: function(key, value) {
          var preset;
          var m = value.match(prefixRegExp);
          if (m) {
            preset = presets[m[1]];
            value = m[2] || key;
          }
          return preset ? preset(value) : value;
        }
      };
    }();
    BINDING_PRESET.add("data", function(path) {
      return {
        events: "update",
        getter: "data." + path
      };
    });
    BINDING_PRESET.add("satellite", function(satelliteName) {
      return {
        events: "satelliteChanged",
        getter: function(node) {
          return node.satellite[satelliteName] ? node.satellite[satelliteName].element : null;
        }
      };
    });
    var TEMPLATE_BINDING = Class.customExtendProperty({
      state: {
        events: "stateChanged",
        getter: function(node) {
          return String(node.state);
        }
      },
      childNodesState: {
        events: "childNodesStateChanged",
        getter: function(node) {
          return String(node.childNodesState);
        }
      },
      childCount: {
        events: "childNodesModified",
        getter: function(node) {
          return node.childNodes ? node.childNodes.length : 0;
        }
      },
      hasChildren: {
        events: "childNodesModified",
        getter: function(node) {
          return !!node.firstChild;
        }
      },
      empty: {
        events: "childNodesModified",
        getter: function(node) {
          return !node.firstChild;
        }
      }
    }, extendBinding);
    var BINDING_TEMPLATE_INTERFACE = {
      attach: function(object, handler, context) {
        object.addHandler(handler, context);
      },
      detach: function(object, handler, context) {
        object.removeHandler(handler, context);
      }
    };
    var TEMPLATE_ACTION = Class.extensibleProperty({
      select: function(event) {
        if (this.isDisabled()) return;
        if (this.contextSelection && this.contextSelection.multiple) this.select(event.ctrlKey || event.metaKey); else this.select();
      }
    });
    var TEMPLATE_SWITCHER_HANDLER = {
      "*": function(event) {
        var switcher = this.templateSwitcher_;
        if (switcher && switcher.ruleEvents && switcher.ruleEvents[event.type]) this.setTemplate(switcher.resolve(this));
      }
    };
    var TEMPLATE = new HtmlTemplate("<div/>");
    var fragments = [];
    function getDocumentFragment() {
      return fragments.pop() || document.createDocumentFragment();
    }
    function reinsertPartitionNodes(partition) {
      var nodes = partition.nodes;
      if (nodes) for (var i = nodes.length - 1, child; child = nodes[i]; i--) child.parentNode.insertBefore(child, child.nextSibling);
    }
    var focusTimer;
    var TemplateMixin = function(super_) {
      return {
        template: TEMPLATE,
        emit_templateChanged: createEvent("templateChanged"),
        templateSwitcher_: null,
        binding: TEMPLATE_BINDING,
        action: TEMPLATE_ACTION,
        tmpl: null,
        element: null,
        childNodesElement: null,
        init: function() {
          this.element = this.childNodesElement = getDocumentFragment();
          super_.init.call(this);
        },
        postInit: function() {
          super_.postInit.call(this);
          var template = this.template;
          if (template) {
            var nodeDocumentFragment = this.element;
            var bindingId = this.constructor.basisClassId_ + "_" + this.binding.bindingId;
            if (bindingId in unknownEventBindingCheck == false) {
              unknownEventBindingCheck[bindingId] = true;
              for (var bindName in this.binding) {
                var events = this.binding[bindName] && this.binding[bindName].events;
                if (events) {
                  events = String(events).trim().split(/\s+|\s*,\s*/);
                  for (var i = 0, eventName; eventName = events[i]; i++) if ("emit_" + eventName in this == false) basis.dev.warn("basis.ui: binding `" + bindName + "` has unknown event `" + eventName + "` for " + this.constructor.className);
                }
              }
            }
            this.template = null;
            this.setTemplate(template);
            fragments.push(nodeDocumentFragment);
            if (this.container) {
              this.container.appendChild(this.element);
              this.container = null;
            }
          }
          instances[this.basisObjectId] = this;
          notifier.set({
            action: "create",
            instance: this
          });
        },
        templateSync: function() {
          var oldElement = this.element;
          var oldTmpl = this.tmpl;
          var tmpl = this.template.createInstance(this, this.templateAction, this.templateSync, this.binding, BINDING_TEMPLATE_INTERFACE);
          var noChildNodesElement;
          if (tmpl.childNodesHere) {
            tmpl.childNodesElement = tmpl.childNodesHere.parentNode;
            tmpl.childNodesElement.insertPoint = tmpl.childNodesHere;
          }
          this.tmpl = tmpl;
          this.element = tmpl.element;
          this.childNodesElement = tmpl.childNodesElement || tmpl.element;
          noChildNodesElement = this.childNodesElement.nodeType != 1;
          if (noChildNodesElement) this.childNodesElement = document.createDocumentFragment();
          if (noChildNodesElement) this.noChildNodesElement_ = true; else delete this.noChildNodesElement_;
          if (this.grouping) {
            this.grouping.syncDomRefs();
            var cursor = this;
            while (cursor.grouping) cursor = cursor.grouping;
            var topGrouping = cursor;
            for (var groupNode = topGrouping.lastChild; groupNode; groupNode = groupNode.previousSibling) {
              if (groupNode instanceof PartitionNode) topGrouping.insertBefore(groupNode, groupNode.nextSibling); else reinsertPartitionNodes(groupNode);
            }
            reinsertPartitionNodes(topGrouping.nullGroup);
          } else {
            for (var child = this.lastChild; child; child = child.previousSibling) this.insertBefore(child, child.nextSibling);
          }
          if (this instanceof PartitionNode) reinsertPartitionNodes(this);
          if (oldElement && oldElement !== this.element && oldElement.nodeType != 11) {
            var parentNode = oldElement && oldElement.parentNode;
            if (parentNode) {
              if (this.owner && this.owner.tmpl) this.owner.tmpl.set(oldElement, this.element);
              if (this.element.parentNode !== parentNode) parentNode.replaceChild(this.element, oldElement);
            }
          }
          if (oldTmpl) this.emit_templateChanged();
        },
        setTemplate: function(template) {
          var curSwitcher = this.templateSwitcher_;
          var switcher;
          if (template instanceof TemplateSwitcher) {
            switcher = template;
            template = switcher.resolve(this);
          }
          if (template instanceof HtmlTemplate == false) template = null;
          if (!template) {
            basis.dev.warn("basis.ui.Node#setTemplate: set null to template possible only on node destroy");
            return;
          }
          if (switcher) {
            this.templateSwitcher_ = switcher;
            if (!curSwitcher) this.addHandler(TEMPLATE_SWITCHER_HANDLER, this);
          }
          if (curSwitcher && curSwitcher.resolve(this) !== template) {
            this.templateSwitcher_ = null;
            this.removeHandler(TEMPLATE_SWITCHER_HANDLER, this);
          }
          var oldTmpl = this.tmpl;
          var oldTemplate = this.template;
          if (oldTemplate !== template) {
            this.template = template;
            this.templateSync();
            if (oldTemplate) oldTemplate.clearInstance(oldTmpl);
          }
        },
        updateBind: function(bindName) {
          var binding = this.binding[bindName];
          var getter = binding && binding.getter;
          if (getter && this.tmpl) this.tmpl.set(bindName, getter(this));
        },
        templateAction: function(actionName, event) {
          var action = this.action[actionName];
          if (action) action.call(this, event);
          if (!action) basis.dev.warn("template call `" + actionName + "` action, but it isn't defined in action list");
        },
        focus: function(select) {
          var focusElement = this.tmpl ? this.tmpl.focus || this.element : null;
          if (focusElement) {
            if (focusTimer) focusTimer = basis.clearImmediate(focusTimer);
            focusTimer = basis.setImmediate(function() {
              try {
                focusElement.focus();
                if (select) focusElement.select();
              } catch (e) {}
            });
          }
        },
        blur: function() {
          var focusElement = this.tmpl ? this.tmpl.focus || this.element : null;
          if (focusElement) try {
            focusElement.blur();
          } catch (e) {}
        },
        destroy: function() {
          delete instances[this.basisObjectId];
          notifier.set({
            action: "destroy",
            instance: this
          });
          var template = this.template;
          var element = this.element;
          if (this.templateSwitcher_) {
            this.templateSwitcher_ = null;
            this.removeHandler(TEMPLATE_SWITCHER_HANDLER, this);
          }
          template.clearInstance(this.tmpl);
          super_.destroy.call(this);
          this.tmpl = null;
          this.element = null;
          this.childNodesElement = null;
          var parentNode = element && element.parentNode;
          if (parentNode && parentNode.nodeType == 1) parentNode.removeChild(element);
        }
      };
    };
    var ContainerTemplateMixin = function(super_) {
      return {
        insertBefore: function(newChild, refChild) {
          if (this.noChildNodesElement_) {
            delete this.noChildNodesElement_;
            basis.dev.warn("basis.ui: Template has no childNodesElement container, but insertBefore method called; probably it's a bug");
          }
          newChild = super_.insertBefore.call(this, newChild, refChild);
          var target = newChild.groupNode || this;
          var container = target.childNodesElement || this.childNodesElement;
          var nextSibling = newChild.nextSibling;
          var insertPoint = nextSibling && nextSibling.element.parentNode == container ? nextSibling.element : null;
          var childElement = newChild.element;
          var refNode = insertPoint || container.insertPoint || null;
          if (childElement.parentNode !== container || childElement.nextSibling !== refNode) container.insertBefore(childElement, refNode);
          return newChild;
        },
        removeChild: function(oldChild) {
          super_.removeChild.call(this, oldChild);
          var element = oldChild.element;
          var parent = element.parentNode;
          if (parent) parent.removeChild(element);
          return oldChild;
        },
        clear: function(alive) {
          if (alive) {
            var node = this.firstChild;
            while (node) {
              var element = node.element;
              var parent = element.parentNode;
              if (parent) parent.removeChild(element);
              node = node.nextSibling;
            }
          }
          super_.clear.call(this, alive);
        },
        setChildNodes: function(childNodes, keepAlive) {
          if (this.noChildNodesElement_) {
            delete this.noChildNodesElement_;
            basis.dev.warn("basis.ui: Template has no childNodesElement container, but setChildNodes method called; probably it's a bug");
          }
          var domFragment = document.createDocumentFragment();
          var target = this.grouping || this;
          var container = target.childNodesElement;
          target.childNodesElement = domFragment;
          super_.setChildNodes.call(this, childNodes, keepAlive);
          container.insertBefore(domFragment, container.insertPoint || null);
          target.childNodesElement = container;
        }
      };
    };
    var PartitionNode = Class(DWPartitionNode, TemplateMixin, {
      className: namespace + ".PartitionNode",
      binding: {
        title: "data:"
      }
    });
    var GroupingNode = Class(DWGroupingNode, ContainerTemplateMixin, {
      className: namespace + ".GroupingNode",
      childClass: PartitionNode,
      groupingClass: Class.SELF,
      element: null,
      childNodesElement: null,
      emit_ownerChanged: function(oldOwner) {
        this.syncDomRefs();
        DWGroupingNode.prototype.emit_ownerChanged.call(this, oldOwner);
      },
      init: function() {
        this.element = this.childNodesElement = document.createDocumentFragment();
        DWGroupingNode.prototype.init.call(this);
        instances[this.basisObjectId] = this;
        notifier.set({
          action: "create",
          instance: this
        });
      },
      syncDomRefs: function() {
        var cursor = this;
        var owner = this.owner;
        var element = null;
        if (owner) element = owner.tmpl && owner.tmpl.groupsElement || owner.childNodesElement;
        do {
          cursor.element = cursor.childNodesElement = element;
        } while (cursor = cursor.grouping);
      },
      destroy: function() {
        delete instances[this.basisObjectId];
        notifier.set({
          action: "destroy",
          instance: this
        });
        DWGroupingNode.prototype.destroy.call(this);
        this.element = null;
        this.childNodesElement = null;
      }
    });
    var Node = Class(DWNode, TemplateMixin, ContainerTemplateMixin, {
      className: namespace + ".Node",
      binding: {
        selected: {
          events: "select unselect",
          getter: function(node) {
            return node.selected;
          }
        },
        unselected: {
          events: "select unselect",
          getter: function(node) {
            return !node.selected;
          }
        },
        disabled: {
          events: "disable enable",
          getter: function(node) {
            return node.isDisabled();
          }
        },
        enabled: {
          events: "disable enable",
          getter: function(node) {
            return !node.isDisabled();
          }
        }
      },
      childClass: Class.SELF,
      childFactory: function(config) {
        return new this.childClass(config);
      },
      groupingClass: GroupingNode
    });
    var ShadowNodeList = Node.subclass({
      className: namespace + ".ShadowNodeList",
      emit_ownerChanged: function(oldOwner) {
        Node.prototype.emit_ownerChanged.call(this, oldOwner);
        this.setDataSource(this.owner && this.owner.getChildNodesDataset());
      },
      getChildNodesElement: function(owner) {
        return owner.childNodesElement;
      },
      listen: {
        owner: {
          templateChanged: function() {
            this.childNodes.forEach(function(child) {
              this.appendChild(child.element);
            }, this.getChildNodesElement(this.owner) || this.owner.element);
          }
        }
      },
      childClass: {
        className: namespace + ".ShadowNode",
        getElement: function(node) {
          return node.element;
        },
        templateSync: function() {
          Node.prototype.templateSync.call(this);
          var newElement = this.getElement(this.delegate);
          if (newElement) {
            newElement[htmlTemplateIdMarker] = this.delegate.element[htmlTemplateIdMarker];
            this.element = newElement;
          }
        },
        listen: {
          delegate: {
            templateChanged: function() {
              var oldElement = this.element;
              var oldElementParent = oldElement.parentNode;
              var newElement = this.getElement(this.delegate);
              if (newElement) newElement[htmlTemplateIdMarker] = this.delegate.element[htmlTemplateIdMarker];
              this.element = newElement || this.tmpl.element;
              if (oldElementParent) oldElementParent.replaceChild(this.element, oldElement);
            }
          }
        }
      }
    });
    module.exports = {
      debug_notifier: notifier,
      debug_getInstances: function() {
        return basis.object.values(instances);
      },
      BINDING_PRESET: BINDING_PRESET,
      Node: Node,
      PartitionNode: PartitionNode,
      GroupingNode: GroupingNode,
      ShadowNodeList: ShadowNodeList,
      ShadowNode: ShadowNodeList.prototype.childClass
    };
  },
  "10.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./j.js");
    basis.require("./1.js");
    var Month = basis.require("./11.js");
    var Employee = basis.require("./13.js");
    module.exports = new basis.ui.Node.subclass({
      name: "Team",
      template: basis.template.get("#a"),
      binding: {
        name: "name",
        code: "data:team"
      },
      childFactory: function(config) {
        if (config.hasOwnProperty("entity")) {
          return new Employee({
            data: config
          });
        }
        return new Month({
          data: config
        });
      },
      handler: {
        update: function() {
          var arr = [ {
            month: this.data.month,
            year: this.data.year
          } ];
          if (this.data.teams.hasOwnProperty(this.data.team)) {
            var team = this.data.teams[this.data.team];
            for (var i in team.employees) {
              if (team.employees.hasOwnProperty(i)) {
                arr.push({
                  entity: team.employees[i],
                  month: this.data.month,
                  year: this.data.year
                });
              }
            }
          }
          this.setChildNodes(arr);
        }
      }
    });
  },
  "11.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    var moment = basis.require("./v.js");
    var Day = basis.require("./12.js");
    module.exports = basis.ui.Node.subclass({
      template: basis.template.get("#8"),
      className: "Month",
      binding: {
        name: "data:name",
        year: "data:year",
        isActive: "data:isActive",
        workingDays: "data:workingDays"
      },
      init: function() {
        basis.ui.Node.prototype.init.call(this);
        var childNodes = [];
        var month = moment(this.data.year + ":" + this.data.month, "YYYY:MMMM");
        this.data.workingDays = 0;
        this.data.name = month.format("MMMM");
        for (var i = 0; i < month.daysInMonth(); i++) {
          var date = month.date(i + 1);
          var isWeekend = [ 6, 7 ].indexOf(date.isoWeekday()) != -1;
          if (!isWeekend) {
            this.data.workingDays++;
          }
          var name = i + 1;
          var hasType = typeof this.data.entity !== "undefined" && this.data.entity.days.hasOwnProperty(date.format("DD.MM.YYYY"));
          if (typeof this.data.entity !== "undefined" && typeof this.data.entity.work_start !== "undefined" && moment(this.data.entity.work_start, "DD.MM.YYYY") < date && (typeof this.data.entity.work_end !== "undefined" || typeof this.data.entity.work_end !== "undefined" && moment(this.data.entity.work_end) > date)) {
            if (isWeekend || hasType) {
              name = "";
            } else {
              name = "1";
            }
          }
          childNodes.push(new Day({
            data: {
              day: i + 1,
              title: name,
              weekend: isWeekend,
              type: hasType ? this.data.entity.days[date.format("DD.MM.YYYY")].day_type_id : ""
            }
          }));
        }
        this.setChildNodes(childNodes);
      }
    });
  },
  "12.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    module.exports = basis.ui.Node.subclass({
      data: {
        day: null,
        title: "",
        weekend: false,
        type: "",
        checked: false
      },
      template: basis.template.get("#7"),
      binding: {
        day: "data:day",
        title: "data:title",
        weekend: "data:weekend",
        type: "data:type",
        checked: function(node) {
          return node.data.checked ? "checked_day" : "";
        }
      },
      action: {
        dayClick: function() {
          this.data.checked = !this.data.checked;
          this.updateBind("checked");
        }
      }
    });
  },
  "q.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./r.js");
    var namespace = this.path;
    var document = global.document;
    var documentElement = document.documentElement;
    var computedStyle = basis.dom.computedStyle.get;
    function getOffsetParent(node) {
      var offsetParent = node.offsetParent || documentElement;
      while (offsetParent && offsetParent !== documentElement && computedStyle(offsetParent, "position") == "static") offsetParent = offsetParent.offsetParent;
      return offsetParent || documentElement;
    }
    function getOffset(element) {
      var top = 0;
      var left = 0;
      if (element && element.getBoundingClientRect) {
        var relRect = element.getBoundingClientRect();
        left = -relRect.left;
        top = -relRect.top;
      } else {
        if (document.compatMode == "CSS1Compat") {
          top = global.pageYOffset || documentElement.scrollTop;
          left = global.pageXOffset || documentElement.scrollLeft;
        } else {
          var body = document.body;
          if (element !== body) {
            top = body.scrollTop - body.clientTop;
            left = body.scrollLeft - body.clientLeft;
          }
        }
      }
      return {
        x: left,
        y: top
      };
    }
    function getTopLeftPoint(element, relElement) {
      var left = 0;
      var top = 0;
      if (element && element.getBoundingClientRect) {
        var box = element.getBoundingClientRect();
        var offset = getOffset(relElement);
        top = box.top + offset.y;
        left = box.left + offset.x;
      }
      return {
        top: top,
        left: left
      };
    }
    function getBoundingRect(element, relElement) {
      var top = 0;
      var left = 0;
      var right = 0;
      var bottom = 0;
      if (element && element.getBoundingClientRect) {
        var rect = element.getBoundingClientRect();
        var offset = getOffset(relElement);
        top = rect.top + offset.y;
        left = rect.left + offset.x;
        right = rect.right + offset.x;
        bottom = rect.bottom + offset.y;
      }
      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };
    }
    function getViewportRect(element, relElement) {
      var point = getTopLeftPoint(element, relElement);
      var top = point.top + element.clientTop;
      var left = point.left + element.clientLeft;
      var width = element.clientWidth;
      var height = element.clientHeight;
      return {
        top: top,
        left: left,
        bottom: top + height,
        right: left + width,
        width: width,
        height: height
      };
    }
    module.exports = {
      getOffsetParent: getOffsetParent,
      getTopLeftPoint: getTopLeftPoint,
      getBoundingRect: getBoundingRect,
      getViewportRect: getViewportRect
    };
  },
  "r.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    var document = global.document;
    var computedStyle;
    if ("getComputedStyle" in global) {
      var GETCOMPUTEDSTYLE_BUGGY = {
        top: true,
        bottom: true,
        left: true,
        right: true,
        height: true,
        width: true
      };
      var testForBuggyProperties = basis.fn.runOnce(function() {
        var testElement = document.createElement("div");
        testElement.setAttribute("style", "position:absolute;top:auto!important");
        basis.doc.body.add(testElement);
        if (global.getComputedStyle(testElement).top == "auto") GETCOMPUTEDSTYLE_BUGGY = {};
        basis.doc.remove(testElement);
      });
      computedStyle = function(element, styleProp) {
        var style = global.getComputedStyle(element);
        var res;
        if (style) {
          if (styleProp in GETCOMPUTEDSTYLE_BUGGY) testForBuggyProperties();
          if (GETCOMPUTEDSTYLE_BUGGY[styleProp] && style.position != "static") {
            var display = element.style.display;
            element.style.display = "none";
            res = style.getPropertyValue(styleProp);
            element.style.display = display;
          } else {
            res = style.getPropertyValue(styleProp);
          }
          return res;
        }
      };
    } else {
      var VALUE_UNIT = /^-?(\d*\.)?\d+([a-z]+|%)?$/i;
      var IS_PIXEL = /\dpx$/i;
      var getPixelValue = function(element, value) {
        if (IS_PIXEL.test(value)) return parseInt(value, 10) + "px";
        var style = element.style;
        var runtimeStyle = element.runtimeStyle;
        var left = style.left;
        var runtimeLeft = runtimeStyle.left;
        runtimeStyle.left = element.currentStyle.left;
        style.left = value || 0;
        value = style.pixelLeft;
        style.left = left;
        runtimeStyle.left = runtimeLeft;
        return value + "px";
      };
      computedStyle = function(element, styleProp) {
        var style = element.currentStyle;
        if (style) {
          var value = style[styleProp == "float" ? "styleFloat" : basis.string.camelize(styleProp)];
          var unit = (value || "").match(VALUE_UNIT);
          if (unit && unit[2] && unit[2] != "px") value = getPixelValue(element, value);
          return value;
        }
      };
    }
    module.exports = {
      get: computedStyle
    };
  },
  "13.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    var Month = basis.require("./11.js");
    var Day = basis.require("./12.js");
    module.exports = basis.ui.Node.subclass({
      data: {
        entity: null
      },
      className: "Employee",
      template: basis.template.get("#9"),
      binding: {
        name: "data.entity.name"
      },
      init: function() {
        basis.ui.Node.prototype.init.call(this);
        this.setChildNodes([ new Month({
          data: {
            month: this.data.month,
            year: this.data.year,
            entity: this.data.entity
          }
        }) ]);
      }
    });
  },
  "d.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./8.js");
    var namespace = this.path;
    var ns = basis.namespace(String(namespace));
    var location = global.location;
    var document = global.document;
    var docMode = document.documentMode;
    var eventSupport = "onhashchange" in global && (docMode === undefined || docMode > 7);
    var CHECK_INTERVAL = 50;
    var arrayFrom = basis.array.from;
    var routes = {};
    var matched = {};
    var started = false;
    var currentPath;
    var timer;
    function pathToRegExp(route) {
      var value = String(route || "");
      function findWord(offset) {
        return value.substr(offset).match(/^\w+/);
      }
      function parse(offset, stopChar) {
        var result = "";
        var res;
        for (var i = offset; i < value.length; i++) {
          var c = value.charAt(i);
          switch (c) {
            case stopChar:
              return {
                result: result,
                offset: i
              };
            case "\\":
              result += "\\" + value.charAt(++i);
              break;
            case "|":
              result += stopChar != ")" ? "\\|" : "|";
              break;
            case "(":
              if (res = parse(i + 1, ")")) {
                i = res.offset;
                result += "(?:" + res.result + ")?";
              } else {
                result += "\\(";
              }
              break;
            case ":":
              if (res = findWord(i + 1)) {
                i += res[0].length;
                result += "([^/]+)";
              } else {
                result += ":";
              }
              break;
            case "*":
              if (res = findWord(i + 1)) {
                i += res[0].length;
                result += "(.*?)";
              } else {
                result += "\\*";
              }
              break;
            default:
              result += basis.string.forRegExp(c);
          }
        }
        return stopChar ? null : result;
      }
      return new RegExp("^" + parse(0) + "$", "i");
    }
    function startWatch() {
      if (eventSupport) basis.dom.event.addHandler(global, "hashchange", checkUrl); else timer = setInterval(checkUrl, CHECK_INTERVAL);
    }
    function stopWatch() {
      if (eventSupport) basis.dom.event.removeHandler(global, "hashchange", checkUrl); else clearInterval(timer);
    }
    function start() {
      if (!started) {
        startWatch();
        started = true;
        if (ns.debug) basis.dev.log(namespace + " started");
        checkUrl();
      }
    }
    function stop() {
      if (started) {
        stopWatch();
        started = false;
        if (ns.debug) basis.dev.log(namespace + " stopped");
      }
    }
    function checkUrl() {
      var newPath = location.hash.substr(1) || "";
      if (newPath != currentPath) {
        var inserted = [];
        var deleted = [];
        var log = [];
        currentPath = newPath;
        for (var path in routes) {
          var route = routes[path];
          var match = newPath.match(route.regexp);
          if (match) {
            if (!matched[path]) inserted.push(route);
            matched[path] = match;
          } else {
            if (matched[path]) {
              deleted.push(route);
              delete matched[path];
            }
          }
        }
        for (var i = 0, route; route = deleted[i]; i++) {
          var callbacks = arrayFrom(route.callbacks);
          for (var j = 0, item; item = callbacks[j]; j++) if (item.callback.leave) {
            item.callback.leave.call(item.context);
            log.push("\n", {
              type: "leave",
              path: route.source,
              cb: item,
              route: route
            });
          }
        }
        for (var i = 0, route; route = inserted[i]; i++) {
          var callbacks = arrayFrom(route.callbacks);
          for (var j = 0, item; item = callbacks[j]; j++) if (item.callback.enter) {
            item.callback.enter.call(item.context);
            log.push("\n", {
              type: "enter",
              path: route.source,
              cb: item,
              route: route
            });
          }
        }
        for (var path in matched) {
          var route = routes[path];
          var args = arrayFrom(matched[path], 1);
          var callbacks = arrayFrom(route.callbacks);
          for (var i = 0, item; item = callbacks[i]; i++) if (item.callback.match) {
            item.callback.match.apply(item.context, args);
            log.push("\n", {
              type: "match",
              path: route.source,
              cb: item,
              route: route,
              args: args
            });
          }
        }
        if (ns.debug) basis.dev.info.apply(basis.dev, [ namespace + ': hash changed to "' + newPath + '"' ].concat(log.length ? log : "<no matches>"));
      }
    }
    function add(path, callback, context) {
      var route = routes[path];
      var config;
      if (!route) {
        route = routes[path] = {
          source: path,
          callbacks: [],
          regexp: Object.prototype.toString.call(path) != "[object RegExp]" ? pathToRegExp(path) : path
        };
        if (typeof currentPath == "string") {
          var match = currentPath.match(route.regexp);
          if (match) matched[path] = match;
        }
      }
      config = {
        cb_: callback,
        context: context,
        callback: typeof callback != "function" ? callback || {} : {
          match: callback
        }
      };
      route.callbacks.push(config);
      if (path in matched) {
        if (config.callback.enter) config.callback.enter.call(context);
        if (config.callback.match) config.callback.match.apply(context, arrayFrom(matched[path], 1));
      }
    }
    function remove(path, callback, context) {
      var route = routes[path];
      if (route) {
        var idx = -1;
        for (var i = 0, cb; cb = route.callbacks[i]; i++) if (cb.cb_ === callback && cb.context === context) {
          route.callbacks.splice(i, 1);
          if (!route.callbacks.length) {
            delete routes[path];
            delete matched[path];
          }
          break;
        }
      }
    }
    function navigate(path, replace) {
      if (replace) location.replace(location.pathname + "#" + path); else location.hash = path;
      if (started) checkUrl();
    }
    module.exports = {
      debug: false,
      add: add,
      remove: remove,
      stop: stop,
      start: start,
      checkUrl: checkUrl,
      navigate: navigate
    };
  },
  "t.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    module.exports = basis.ui.Node.subclass({
      name: "Agenda",
      template: basis.template.get("#1"),
      childClass: {
        template: basis.template.get("#2"),
        binding: {
          id: "data:",
          name: "data:"
        },
        action: {
          applyType: function() {
            this.parentNode.parentNode.emit_applyDayType(this.data.id);
          }
        }
      },
      init: function() {
        var self = this;
        basis.ui.Node.prototype.init.call(this);
        var arr = Object.keys(self.dayTypes).map(function(key) {
          return {
            data: self.dayTypes[key]
          };
        });
        self.setChildNodes(arr);
      }
    });
  },
  "14.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    module.exports = basis.ui.Node.subclass({
      container: document.getElementById("page"),
      template: "<div>Page</div>",
      selection: true,
      childClass: {
        template: '<div class="page page-{unselected}">' + "{name}" + "</div>",
        binding: {
          name: "name"
        }
      }
    });
  },
  "0.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./1.js");
    var moment = basis.require("./s.js");
    var ajax = basis.require("./a.js");
    var router = basis.require("./d.js");
    var Agenda = basis.require("./t.js");
    var PublicHolidays = basis.require("./u.js");
    var Toolbox = basis.require("./w.js");
    var UserConstructor = basis.require("./z.js");
    var Team = basis.require("./10.js");
    var Pages = basis.require("./14.js");
    var pages;
    var modelUrl = "http://localhost:8888/model";
    var model = new basis.data.Object({
      data: {
        month: "March",
        year: 2015,
        team: "",
        teams: {},
        publicHolidays: {},
        dayTypes: {}
      }
    });
    updateModel(function(transport, request, response) {
      model.update(response);
      new Toolbox({
        delegate: model
      });
      new UserConstructor;
      initPages();
      initRoutes();
    });
    function initPages() {
      pages = new Pages;
      var page1 = {
        name: "publicHolidaysPage",
        childNodes: [ new PublicHolidays ]
      };
      var page2 = {
        name: "teamPage",
        childNodes: [ new Team({
          delegate: model
        }), new Agenda({
          dayTypes: model.data.dayTypes
        }) ],
        emit_applyDayType: basis.event.create("applyDayType", "typeId"),
        handler: {
          applyDayType: function(sender, typeId) {
            applyTypeForSelectedDays(this.getChildByName("Team"), typeId);
          }
        }
      };
      pages.setChildNodes([ page1, page2 ]);
    }
    function initRoutes() {
      router.start();
      router.add("team/:team/:month/:year", {
        match: function(teamCode, month, year) {
          model.update({
            team: teamCode,
            month: month,
            year: year + " "
          });
          var page = pages.getChildByName("teamPage");
          page.select();
        }
      });
      router.add("public-holidays/:month/:year", {
        match: function(month, year) {
          model.update({
            month: month,
            year: year
          });
          var page = pages.getChildByName("publicHolidaysPage");
          page.select();
          page.getChildByName("PublicHolidaysYear").update({
            year: model.data.year,
            publicHolidays: model.data.publicHolidays
          });
        }
      });
    }
    function updateModel(done) {
      ajax.request({
        url: modelUrl,
        method: "GET",
        handler: {
          success: done
        }
      });
    }
    function applyTypeForSelectedDays(currentTeam, typeId) {
      var postModel = [];
      var childNodes = currentTeam.childNodes;
      var checkedDays = [];
      for (var i = 0; i < childNodes.length; i++) {
        var employee = childNodes[i];
        if (employee.constructor.className == "Employee") {
          for (var j = 0; j < employee.childNodes.length; j++) {
            var month = employee.childNodes[j];
            if (month.constructor.className == "Month") {
              var days = month.childNodes;
              for (var k = 0; k < days.length; k++) {
                if (days[k].data.checked) {
                  checkedDays.push(days[k]);
                  postModel.push({
                    id: employee.data.entity.id,
                    date: moment().month(month.data.name).year(month.data.year).date(days[k].data.day).format("DD.MM.YYYY"),
                    type: typeId
                  });
                }
              }
            }
          }
        }
      }
      if (postModel.length) {
        ajax.request({
          url: "http://localhost:8888/set-type",
          method: "POST",
          contentType: "application/json",
          postBody: JSON.stringify(postModel),
          handler: {
            success: function() {
              for (var i = 0; i < checkedDays.length; i++) {
                checkedDays[i].data.checked = false;
                checkedDays[i].updateBind("checked");
              }
              updateModel(function(transport, request, response) {
                model.update(response);
              });
            }
          }
        });
      }
    }
  },
  "p.js": function(exports, module, basis, global, __filename, __dirname, require, resource, asset) {
    basis.require("./j.js");
    var namespace = this.path;
    var document = global.document;
    var location = global.location;
    var path = basis.path;
    var arrayFrom = basis.array.from;
    var camelize = basis.string.camelize;
    var Class = basis.Class;
    var dom = basis.dom;
    var DOMTokenList = global.DOMTokenList;
    var CLASSLIST_SUPPORTED = DOMTokenList && document && document.documentElement.classList instanceof DOMTokenList;
    var IMPORTANT_REGEXP = /\s*!important/i;
    var IMPORTANT = "important";
    var GENERIC_RULE_SEED = 1;
    var cssStyleSheets = {};
    var SET_STYLE_EXCEPTION_BUG = function() {
      var element = dom.createElement();
      try {
        element.style.width = "badvalue";
      } catch (e) {
        return true;
      }
      return false;
    }();
    function createRule(selector, styleSheet) {
      return getStyleSheet(styleSheet, true).createRule(selector);
    }
    function isPropertyImportant(style, property) {
      if (style.getPropertyPriority) return style.getPropertyPriority(property) == IMPORTANT; else return false;
    }
    function uniqueRule(element) {
      var token = "genericRule-" + GENERIC_RULE_SEED++;
      if (element) classList(element).add(token);
      var result = createRule("." + token);
      result.token = token;
      return result;
    }
    function compatibleStyleSheetInsertRule(rule, index) {
      var m = rule.match(/^([^{]+)\{(.*)\}\s*$/);
      if (m) {
        var selectors = m[1].trim().split(/\s*,\s*/);
        for (var i = 0; i < selectors.length; i++) this.addRule(selectors[i], m[2] || null, index++);
        return index - 1;
      }
      throw new Error("Syntax error in CSS rule to be added");
    }
    function makeStyleSheetCompatible(style) {
      try {
        if (!style.cssRules) style.cssRules = style.rules;
      } catch (e) {}
      if (!style.insertRule) style.insertRule = compatibleStyleSheetInsertRule;
      if (!style.deleteRule) style.deleteRule = style.removeRule;
      return style;
    }
    function addStyleSheet(url, title) {
      var element = dom.createElement(!url ? 'style[type="text/css"]' : basis.string.format('link[type="text/css"][rel="{alt}stylesheet"][href="{url}"]', {
        alt: title ? "alternate " : "",
        url: url.replace(/\"/g, '\\"')
      }));
      basis.doc.head.add(element);
      return makeStyleSheetCompatible(element.sheet || element.styleSheet);
    }
    function getStyleSheet(id, createIfNotExists) {
      if (!id) id = "DefaultGenericStyleSheet";
      if (!cssStyleSheets[id]) if (createIfNotExists) cssStyleSheets[id] = new StyleSheet(addStyleSheet());
      return cssStyleSheets[id];
    }
    var testElement = dom.createElement("");
    var styleMapping = {};
    var features = {};
    function createStyleMapping(property, names, regSupport, getters) {
      getters = getters || {};
      names = names.split(" ");
      for (var i = 0, name; name = names[i]; i++) {
        if (typeof testElement.style[name] != "undefined") {
          if (regSupport) features["css-" + property] = name;
          styleMapping[property] = {
            key: name,
            getter: getters[name]
          };
          return;
        }
      }
    }
    createStyleMapping("opacity", "opacity filter", true, {
      filter: function(value) {
        return "alpha(opacity:" + parseInt(value * 100, 10) + ")";
      }
    });
    createStyleMapping("float", "cssFloat styleFloat");
    function getStylePropertyMapping(key, value) {
      var mapping = styleMapping[key];
      if (key = mapping ? mapping.key : camelize(key.replace(/^-ms-/, "ms-"))) return {
        key: key,
        value: mapping && mapping.getter ? mapping.getter(value) : value
      };
      return null;
    }
    function setStyleProperty(node, property, value) {
      var mapping = getStylePropertyMapping(property, value);
      if (!mapping) return;
      var key = mapping.key;
      var imp = !!IMPORTANT_REGEXP.test(value);
      var style = node.style;
      if (imp || isPropertyImportant(style, property)) {
        mapping.value = mapping.value.replace(IMPORTANT_REGEXP, "");
        if (style.setProperty) {
          if (!imp) style.removeProperty(key);
          style.setProperty(key, mapping.value, imp ? IMPORTANT : "");
        } else {
          var newValue = key + ": " + mapping.value + (imp ? " !" + IMPORTANT : "") + ";";
          var rxText = style[key] ? key + "\\s*:\\s*" + style[key] + "(\\s*!" + IMPORTANT + ")?\\s*;?" : "^";
          try {
            style.cssText = style.cssText.replace(new RegExp(rxText, "i"), newValue);
          } catch (e) {
            basis.dev.warn("basis.cssom.setStyleProperty: Can't set wrong value `" + mapping.value + "` for " + mapping.key + " property");
          }
        }
      } else {
        if (SET_STYLE_EXCEPTION_BUG) {
          try {
            node.style[mapping.key] = mapping.value;
          } catch (e) {
            basis.dev.warn("basis.cssom.setStyleProperty: Can't set wrong value `" + mapping.value + "` for " + mapping.key + " property");
          }
        } else node.style[mapping.key] = mapping.value;
        return node.style[mapping.key];
      }
    }
    function setStyle(node, style) {
      for (var key in style) setStyleProperty(node, key, style[key]);
      return node;
    }
    function display(node, display) {
      return setStyleProperty(node, "display", typeof display == "string" ? display : display ? "" : "none");
    }
    function visibility(node, visible) {
      return setStyleProperty(node, "visibility", visible ? "" : "hidden");
    }
    var StyleSheet = Class(null, {
      className: namespace + ".StyleSheet",
      styleSheet: null,
      rules: null,
      init: function(styleSheet) {
        this.styleSheet = styleSheet;
        this.rules = [];
      },
      createRule: function(selector) {
        var styleSheet = this.styleSheet;
        var index = this.rules.length;
        styleSheet.insertRule(selector + "{}", index);
        var cssRules = arrayFrom(styleSheet.cssRules, index);
        var ruleWrapper = cssRules[1] ? new RuleSet(cssRules, this) : new Rule(cssRules[0], this);
        this.rules.push.apply(this.rules, ruleWrapper.rules || [ ruleWrapper ]);
        return ruleWrapper;
      },
      deleteRule: function(rule) {
        if (rule instanceof RuleSet) rule.rules.forEach(this.deleteRule, this); else {
          var ruleIndex = this.rules.indexOf(rule);
          if (ruleIndex != -1) {
            this.rules.splice(ruleIndex, 1);
            this.styleSheet.deleteRule(ruleIndex);
          }
        }
        rule.owner = null;
        rule.destroy();
      },
      destroy: function() {
        this.rules.forEach(function(item) {
          item.destroy();
        });
        this.styleSheet = null;
        this.rules = null;
      }
    });
    var Rule = Class(null, {
      className: namespace + ".Rule",
      rule: null,
      selector: "",
      init: function(rule, owner) {
        this.owner = owner;
        this.rule = rule;
        this.selector = rule.selectorText;
      },
      setProperty: function(property, value) {
        setStyleProperty(this.rule, property, value);
      },
      setStyle: function(style) {
        basis.object.iterate(style, this.setProperty, this);
      },
      clear: function() {
        this.rule.style.cssText = "";
      },
      destroy: function() {
        if (this.owner) this.owner.deleteRule(this);
        this.owner = null;
        this.rule = null;
      }
    });
    function createRuleSetMethod(methodName) {
      return function() {
        for (var i = 0, rule; rule = this.rules[i]; i++) rule[methodName].apply(rule, arguments);
      };
    }
    var RuleSet = Class(null, {
      className: namespace + ".RuleSet",
      rules: null,
      init: function(rules, owner) {
        this.owner = owner;
        this.rules = rules.map(function(rule) {
          return new Rule(rule, this);
        }, this);
      },
      createRule: function(selector) {
        var rule = this.owner.createRule(selector);
        this.rules.push(rule);
        rule.owner = this;
        return rule;
      },
      deleteRule: function(rule) {
        var ruleIndex = this.rules.indexOf(rule);
        if (ruleIndex != -1) {
          this.rules.splice(ruleIndex, 1);
          this.owner.deleteRule(rule);
        }
      },
      setProperty: createRuleSetMethod("setProperty"),
      setStyle: createRuleSetMethod("setStyle"),
      clear: createRuleSetMethod("clear"),
      destroy: function() {
        if (this.owner) this.owner.deleteRule(this);
        this.owner = null;
        this.rules = null;
      }
    });
    var classList;
    var tokenRxCache = {};
    function tokenRegExp(token) {
      return tokenRxCache[token] || (tokenRxCache[token] = new RegExp("\\s*\\b" + token + "\\b"));
    }
    var ClassList = Class(null, {
      className: namespace + ".ClassList",
      init: function(element) {
        if (!element) throw namespace + ".classList: Element " + element + " not found!";
        this.element = element;
      },
      set_: function(value) {
        var className = this.element.className;
        if (typeof className == "string") return this.element.className = value; else return className.baseVal = value;
      },
      toString: function() {
        var className = this.element.className;
        return typeof className == "string" ? className : className.baseVal;
      },
      set: function(tokenList) {
        this.clear();
        tokenList.trim().split(" ").forEach(this.add, this);
      },
      replace: function(searchFor, replaceFor, prefix) {
        prefix = prefix || "";
        if (typeof searchFor != "undefined") this.remove(prefix + searchFor);
        if (typeof replaceFor != "undefined") this.add(prefix + replaceFor);
      },
      bool: function(token, exists) {
        if (exists) this.add(token); else this.remove(token);
      },
      clear: function() {
        this.set_("");
      },
      contains: function(token) {
        return !!this.toString().match(tokenRegExp(token));
      },
      item: function(index) {
        return this.toString().trim().split(" ")[index];
      },
      add: function(token) {
        var className = this.toString();
        if (!className.match(tokenRegExp(token))) this.set_(className + " " + token);
      },
      remove: function(token) {
        var className = this.toString();
        var newClassName = className.replace(tokenRegExp(token), "");
        if (newClassName != className) this.set_(newClassName);
      },
      toggle: function(token) {
        var exists = this.contains(token);
        if (exists) this.remove(token); else this.add(token);
        return !exists;
      }
    });
    var prefixRxCache = {};
    function prefixRegExp(prefix, global) {
      var key = (global ? "g" : "s") + prefix;
      return prefixRxCache[key] || (prefixRxCache[key] = new RegExp((global ? "" : "\\s*") + "\\b" + prefix + "\\S*\\b"));
    }
    var ClassListNS = Class(null, {
      className: namespace + ".ClassListNS",
      delim: "-",
      init: function(ns, classList) {
        this.classList = classList;
        this.prefix = ns + this.delim;
      },
      add: function(value) {
        this.classList.add(this.prefix + value);
      },
      remove: function(value) {
        this.classList.remove(this.prefix + value);
      },
      items: function() {
        var className = this.classList.toString();
        return className ? className.match(prefixRegExp(this.prefix, true)) : null;
      },
      set: function(value) {
        var items = this.items();
        var token = typeof value != "undefined" ? this.prefix + value : "";
        var classList = this.classList;
        if (items) {
          if (items.length == 1) {
            if (items[0] === token) return;
            classList.remove(items[0]);
          } else this.clear();
        }
        if (token) classList.add(token);
      },
      clear: function() {
        this.items().forEach(this.classList.remove, this.classList);
      }
    });
    if (CLASSLIST_SUPPORTED) {
      var proto = ClassList.prototype;
      basis.object.extend(DOMTokenList.prototype, {
        set: proto.set,
        replace: proto.replace,
        bool: proto.bool,
        clear: function() {
          for (var i = this.length; i > 0; ) this.remove(this[--i]);
        },
        setPrefixToken: proto.setPrefixToken
      });
      classList = function(element) {
        return (typeof element == "string" ? dom.get(element) : element).classList;
      };
    } else {
      classList = function(element) {
        return new ClassList(typeof element == "string" ? dom.get(element) : element);
      };
    }
    var classListProxy = function(element, ns) {
      return ns ? new ClassListNS(ns, classList(element)) : classList(element);
    };
    function createUnitFormatter(unit) {
      return function(value) {
        return value == 0 || isNaN(value) ? "0" : value + unit;
      };
    }
    module.exports = {
      features: features,
      setStyleProperty: setStyleProperty,
      setStyle: setStyle,
      classList: classListProxy,
      uniqueRule: uniqueRule,
      createRule: createRule,
      getStyleSheet: getStyleSheet,
      addStyleSheet: addStyleSheet,
      StyleSheet: StyleSheet,
      Rule: Rule,
      RuleSet: RuleSet,
      display: display,
      visibility: visibility,
      em: createUnitFormatter("em"),
      ex: createUnitFormatter("ex"),
      px: createUnitFormatter("px"),
      percent: createUnitFormatter("%")
    };
  }
};

(function createBasisInstance(global, __basisFilename, __config) {
  "use strict";
  var VERSION = "1.3.4";
  var document = global.document;
  var toString = Object.prototype.toString;
  function genUID(len) {
    function base36(val) {
      return Math.round(val).toString(36);
    }
    var result = base36(10 + 25 * Math.random());
    if (!len) len = 16;
    while (result.length < len) result += base36(new Date * Math.random());
    return result.substr(0, len);
  }
  function extend(dest, source) {
    for (var key in source) dest[key] = source[key];
    return dest;
  }
  function complete(dest, source) {
    for (var key in source) if (key in dest == false) dest[key] = source[key];
    return dest;
  }
  function keys(object) {
    var result = [];
    for (var key in object) result.push(key);
    return result;
  }
  function values(object) {
    var result = [];
    for (var key in object) result.push(object[key]);
    return result;
  }
  function slice(source, keys) {
    var result = {};
    if (!keys) return extend(result, source);
    for (var i = 0, key; key = keys[i++]; ) if (key in source) result[key] = source[key];
    return result;
  }
  function splice(source, keys) {
    var result = {};
    if (!keys) return extend(result, source);
    for (var i = 0, key; key = keys[i++]; ) if (key in source) {
      result[key] = source[key];
      delete source[key];
    }
    return result;
  }
  function merge() {
    var result = {};
    for (var i = 0; i < arguments.length; i++) extend(result, arguments[i]);
    return result;
  }
  function iterate(object, callback, thisObject) {
    var result = [];
    for (var key in object) result.push(callback.call(thisObject, key, object[key]));
    return result;
  }
  function $undefined(value) {
    return value == undefined;
  }
  function $defined(value) {
    return value != undefined;
  }
  function $isNull(value) {
    return value == null || value == undefined;
  }
  function $isNotNull(value) {
    return value != null && value != undefined;
  }
  function $isSame(value) {
    return value === this;
  }
  function $isNotSame(value) {
    return value !== this;
  }
  function $self(value) {
    return value;
  }
  function $const(value) {
    return function() {
      return value;
    };
  }
  function $false() {
    return false;
  }
  function $true() {
    return true;
  }
  function $null() {
    return null;
  }
  function $undef() {}
  var getter = function() {
    var ID = "basisGetterId" + genUID() + "_";
    var modificatorSeed = 1;
    var simplePath = /^[a-z$_][a-z$_0-9]*(\.[a-z$_][a-z$_0-9]*)*$/i;
    var getterMap = [];
    var pathCache = {};
    var modCache = {};
    function buildFunction(path) {
      if (simplePath.test(path)) {
        var parts = path.split(".");
        var foo = parts[0];
        var bar = parts[1];
        var baz = parts[2];
        var fn;
        switch (parts.length) {
          case 1:
            fn = function(object) {
              return object != null ? object[foo] : object;
            };
            break;
          case 2:
            fn = function(object) {
              return object != null ? object[foo][bar] : object;
            };
            break;
          case 3:
            fn = function(object) {
              return object != null ? object[foo][bar][baz] : object;
            };
            break;
          default:
            fn = function(object) {
              if (object != null) {
                object = object[foo][bar][baz];
                for (var i = 3, key; key = parts[i]; i++) object = object[key];
              }
              return object;
            };
        }
        fn = Function("parts", "return " + fn.toString().replace(/(foo|bar|baz)/g, function(m, w) {
          return '"' + parts[w == "foo" ? 0 : w == "bar" ? 1 : 2] + '"';
        }).replace(/\[\"([^"]+)\"\]/g, ".$1"))(parts);
        return fn;
      }
      return new Function("object", "return object != null ? object." + path + " : object");
    }
    var getterFn = function(path, modificator) {
      var func;
      var result;
      var getterId;
      if (!path || path === nullGetter) return nullGetter;
      if (typeof path == "function") {
        getterId = path[ID];
        if (getterId) {
          func = getterMap[Math.abs(getterId) - 1];
        } else {
          func = function(object) {
            return path(object);
          };
          func.base = path;
          func.__extend__ = getter;
          getterId = getterMap.push(func);
          path[ID] = -getterId;
          func[ID] = getterId;
        }
      } else {
        func = pathCache[path];
        if (func) {
          getterId = func[ID];
        } else {
          func = buildFunction(path);
          func.base = path;
          func.__extend__ = getter;
          getterId = getterMap.push(func);
          func[ID] = getterId;
          pathCache[path] = func;
        }
      }
      var modType = modificator != null && typeof modificator;
      if (!modType) return func;
      var modList = modCache[getterId];
      var modId;
      if (modType == "string") modId = modType + modificator; else if (modType == "function") modId = modificator.basisModId_; else if (modType != "object") {
        consoleMethods.warn("basis.getter: wrong modificator type, modificator not used, path: ", path, ", modificator:", modificator);
        return func;
      }
      if (modId && modList && modList[modId]) return modList[modId];
      if (typeof func.base == "function") func = func.base;
      switch (modType) {
        case "string":
          result = function(object) {
            return stringFunctions.format(modificator, func(object));
          };
          break;
        case "function":
          if (!modId) {
            modId = modType + modificatorSeed++;
            modificator.basisModId_ = modId;
          }
          result = function(object) {
            return modificator(func(object));
          };
          break;
        default:
          result = function(object) {
            return modificator[func(object)];
          };
      }
      result.base = func.base || func;
      result.__extend__ = getter;
      if (modId) {
        if (!modList) {
          modList = {};
          modCache[getterId] = modList;
        }
        modList[modId] = result;
        result.mod = modificator;
        result[ID] = getterMap.push(result);
      } else {}
      return result;
    };
    getterFn.ID = ID;
    return getterFn;
  }();
  var nullGetter = extend(function() {}, {
    __extend__: getter
  });
  function wrapper(key) {
    return function(value) {
      var result = {};
      result[key] = value;
      return result;
    };
  }
  function lazyInit(init, thisObject) {
    var inited = 0;
    var self;
    var data;
    return self = function() {
      if (!(inited++)) {
        self.inited = true;
        self.data = data = init.apply(thisObject || this, arguments);
        if (typeof data == "undefined") consoleMethods.warn("lazyInit function returns nothing:\n" + init);
      }
      return data;
    };
  }
  function lazyInitAndRun(init, run, thisObject) {
    var inited = 0;
    var self;
    var data;
    return self = function() {
      if (!(inited++)) {
        self.inited = true;
        self.data = data = init.call(thisObject || this);
        if (typeof data == "undefined") consoleMethods.warn("lazyInitAndRun function returns nothing:\n" + init);
      }
      run.apply(data, arguments);
      return data;
    };
  }
  function runOnce(run, thisObject) {
    var fired = 0;
    return function() {
      if (!(fired++)) return run.apply(thisObject || this, arguments);
    };
  }
  var consoleMethods = function() {
    var methods = {
      log: $undef,
      info: $undef,
      warn: $undef,
      error: $undef
    };
    if (typeof console != "undefined") iterate(methods, function(methodName) {
      methods[methodName] = "bind" in Function.prototype && typeof console[methodName] == "function" ? Function.prototype.bind.call(console[methodName], console) : function() {
        Function.prototype.apply.call(console[methodName], console, arguments);
      };
    });
    return methods;
  }();
  var setImmediate = global.setImmediate || global.msSetImmediate;
  var clearImmediate = global.clearImmediate || global.msSetImmediate;
  if (setImmediate) setImmediate = setImmediate.bind(global);
  if (clearImmediate) clearImmediate = clearImmediate.bind(global);
  if (!setImmediate) (function() {
    var MESSAGE_NAME = "basisjs.setImmediate";
    var runTask = function() {
      var taskById = {};
      var taskId = 1;
      setImmediate = function(fn) {
        if (typeof fn != "function") {
          consoleMethods.warn("basis.setImmediate() and basis.nextTick() accept functions only (call ignored)");
          return;
        }
        taskById[++taskId] = {
          fn: fn,
          args: arrayFrom(arguments, 1)
        };
        addToQueue(taskId);
        return taskId;
      };
      clearImmediate = function(id) {
        delete taskById[id];
      };
      return function(id) {
        var task = taskById[id];
        if (task) {
          delete taskById[id];
          return task.fn.apply(undefined, task.args);
        }
      };
    }();
    var addToQueue = function(taskId) {
      setTimeout(function() {
        runTask(taskId);
      }, 0);
    };
    if (global.process && typeof process.nextTick == "function") {
      addToQueue = function(taskId) {
        process.nextTick(function() {
          runTask(taskId);
        });
      };
    } else {
      if (global.MessageChannel) {
        var channel = new global.MessageChannel;
        channel.port1.onmessage = function(event) {
          var taskId = event.data;
          runTask(taskId);
        };
        addToQueue = function(taskId) {
          channel.port2.postMessage(taskId);
        };
      } else {
        var postMessageSupported = global.postMessage && !global.importScripts;
        if (postMessageSupported) {
          var oldOnMessage = global.onmessage;
          global.onmessage = function() {
            postMessageSupported = false;
          };
          global.postMessage("", "*");
          global.onmessage = oldOnMessage;
        }
        if (postMessageSupported) {
          var setImmediateHandler = function(event) {
            if (event && event.source == global) {
              var taskId = String(event.data).split(MESSAGE_NAME)[1];
              if (taskId) runTask(taskId);
            }
          };
          if (global.addEventListener) global.addEventListener("message", setImmediateHandler, true); else global.attachEvent("onmessage", setImmediateHandler);
          addToQueue = function(taskId) {
            global.postMessage(MESSAGE_NAME + taskId, "*");
          };
        } else {
          var createScript = function() {
            return document.createElement("script");
          };
          if (document && "onreadystatechange" in createScript()) {
            var defaultAddToQueue = addToQueue;
            addToQueue = function beforeHeadReady(taskId) {
              if (typeof documentInterface != "undefined") {
                addToQueue = defaultAddToQueue;
                documentInterface.head.ready(function() {
                  addToQueue = function(taskId) {
                    var scriptEl = createScript();
                    scriptEl.onreadystatechange = function() {
                      scriptEl.onreadystatechange = null;
                      documentInterface.remove(scriptEl);
                      scriptEl = null;
                      runTask(taskId);
                    };
                    documentInterface.head.add(scriptEl);
                  };
                });
              }
              if (addToQueue === beforeHeadReady) defaultAddToQueue(taskId); else addToQueue(taskId);
            };
          }
        }
      }
    }
  })();
  var NODE_ENV = typeof process == "object" && toString.call(process) == "[object process]";
  var pathUtils = function() {
    var ABSOLUTE_RX = /^([^\/]+:|\/)/;
    var PROTOCOL_RX = /^[a-zA-Z0-9\-]+:\/?/;
    var ORIGIN_RX = /^(?:[a-zA-Z0-9\-]+:)?\/\/[^\/]+\/?/;
    var SEARCH_HASH_RX = /[\?#].*$/;
    var baseURI;
    var origin;
    var utils;
    if (NODE_ENV) {
      var path = (process.basisjsBaseURI || require("path").resolve(".")).replace(/\\/g, "/");
      baseURI = path.replace(/^[^\/]*/, "");
      origin = path.replace(/\/.*/, "");
    } else {
      baseURI = location.pathname.replace(/[^\/]+$/, "");
      origin = location.protocol + "//" + location.host;
    }
    utils = {
      baseURI: baseURI,
      origin: origin,
      normalize: function(path) {
        path = (path || "").replace(PROTOCOL_RX, "/").replace(ORIGIN_RX, "/").replace(SEARCH_HASH_RX, "");
        var result = [];
        var parts = path.split("/");
        for (var i = 0; i < parts.length; i++) {
          if (parts[i] == "..") {
            if (result.length > 1 || result[0]) result.pop();
          } else {
            if ((parts[i] || !i) && parts[i] != ".") result.push(parts[i]);
          }
        }
        return result.join("/") || (path[0] === "/" ? "/" : "");
      },
      dirname: function(path) {
        var result = utils.normalize(path);
        return result.replace(/\/([^\/]*)$|^[^\/]+$/, "") || (result[0] == "/" ? "/" : ".");
      },
      extname: function(path) {
        var ext = utils.normalize(path).match(/[^\/](\.[^\/\.]*)$/);
        return ext ? ext[1] : "";
      },
      basename: function(path, ext) {
        var filename = utils.normalize(path).match(/[^\\\/]*$/);
        filename = filename ? filename[0] : "";
        if (ext == utils.extname(filename)) filename = filename.substring(0, filename.length - ext.length);
        return filename;
      },
      resolve: function(from, to) {
        var args = arrayFrom(arguments).reverse();
        var path = [];
        var absoluteFound = false;
        for (var i = 0; !absoluteFound && i < args.length; i++) if (typeof args[i] == "string") {
          path.unshift(args[i]);
          absoluteFound = ABSOLUTE_RX.test(args[i]);
        }
        if (!absoluteFound) path.unshift(baseURI == "/" ? "" : baseURI);
        return utils.normalize(path.join("/"));
      },
      relative: function(from, to) {
        if (typeof to != "string") {
          to = from;
          from = baseURI;
        }
        from = utils.normalize(from);
        to = utils.normalize(to);
        if (from[0] == "/" && to[0] != "/") return from;
        if (to[0] == "/" && from[0] != "/") return to;
        var base = from.replace(/^\/$/, "").split(/\//);
        var path = to.replace(/^\/$/, "").split(/\//);
        var result = [];
        var i = 0;
        while (path[i] == base[i] && typeof base[i] == "string") i++;
        for (var j = base.length - i; j > 0; j--) result.push("..");
        return result.concat(path.slice(i).filter(Boolean)).join("/");
      }
    };
    return utils;
  }();
  var basisFilename = __basisFilename || "";
  var config = __config || {
    modules: {},
    autoload: [ "./0.js" ]
  };
  function fetchConfig() {
    var config = __config;
    if (!config) {
      if (NODE_ENV) {
        basisFilename = __filename.replace(/\\/g, "/");
      } else {
        var scripts = document.scripts;
        for (var i = 0, scriptEl; scriptEl = scripts[i]; i++) {
          var configAttrValue = scriptEl.hasAttribute("basis-config") ? scriptEl.getAttribute("basis-config") : scriptEl.getAttribute("data-basis-config");
          scriptEl.removeAttribute("basis-config");
          scriptEl.removeAttribute("data-basis-config");
          if (configAttrValue !== null) {
            basisFilename = pathUtils.normalize(scriptEl.src);
            try {
              config = Function("return{" + configAttrValue + "}")();
            } catch (e) {
              consoleMethods.error("basis-config: basis.js config parse fault: " + e);
            }
            break;
          }
        }
      }
    }
    return processConfig(config);
  }
  function processConfig(config, verbose) {
    config = slice(config);
    if ("extProto" in config) consoleMethods.warn("basis-config: `extProto` option in basis-config is not support anymore");
    if ("path" in config) consoleMethods.warn("basis-config: `path` option in basis-config is deprecated, use `modules` instead");
    var autoload = [];
    var modules = merge(config.path, config.modules, {
      basis: basisFilename
    });
    config.modules = {};
    if (config.autoload) {
      var m = String(config.autoload).match(/^((?:[^\/]*\/)*)([a-z$_][a-z0-9$_]*)((?:\.[a-z$_][a-z0-9$_]*)*)$/i);
      if (m) {
        modules[m[2]] = {
          autoload: true,
          filename: m[1] + m[2] + (m[3] || ".js")
        };
      } else {
        consoleMethods.warn("basis-config: wrong `autoload` value (setting ignored): " + config.autoload);
      }
      delete config.autoload;
    }
    for (var name in modules) {
      var module = modules[name];
      if (typeof module == "string") module = {
        filename: module.replace(/\/$/, "/" + name + ".js")
      };
      var filename = module.filename;
      var path = module.path;
      if (filename && !path) {
        filename = pathUtils.resolve(filename);
        path = filename.substr(0, filename.length - pathUtils.extname(filename).length);
        filename = "../" + pathUtils.basename(filename);
      }
      path = pathUtils.resolve(path);
      if (!filename && path) {
        filename = pathUtils.basename(path);
        path = pathUtils.dirname(path);
      }
      if (!pathUtils.extname(filename)) filename += ".js";
      filename = pathUtils.resolve(path, filename);
      config.modules[name] = {
        path: path,
        filename: filename
      };
      if (module.autoload) {
        config.autoload = autoload;
        autoload.push(name);
      }
    }
    return config;
  }
  var Class = function() {
    var instanceSeed = {
      id: 1
    };
    var classSeed = 1;
    var classes = [];
    var SELF = {};
    function isClass(object) {
      return typeof object == "function" && !!object.basisClassId_;
    }
    function isSubclassOf(superClass) {
      var cursor = this;
      while (cursor && cursor !== superClass) cursor = cursor.superClass_;
      return cursor === superClass;
    }
    function devVerboseName(name, args, fn) {
      return (new Function(keys(args), 'return {"' + name + '": ' + fn + '\n}["' + name + '"]')).apply(null, values(args));
    }
    var TOSTRING_BUG = function() {
      for (var key in {
        toString: 1
      }) return false;
      return true;
    }();
    function createClass(SuperClass, extensions) {
      var classId = classSeed++;
      if (typeof SuperClass != "function") SuperClass = BaseClass;
      var className = "";
      for (var i = 1, extension; extension = arguments[i]; i++) if (typeof extension != "function" && extension.className) className = extension.className;
      if (!className) className = SuperClass.className + "._Class" + classId;
      var NewClassProto = function() {};
      NewClassProto = devVerboseName(className, {}, NewClassProto);
      NewClassProto.prototype = SuperClass.prototype;
      var newProto = new NewClassProto;
      var newClassProps = {
        className: className,
        basisClassId_: classId,
        superClass_: SuperClass,
        extendConstructor_: !!SuperClass.extendConstructor_,
        isSubclassOf: isSubclassOf,
        subclass: function() {
          return createClass.apply(null, [ newClass ].concat(arrayFrom(arguments)));
        },
        extend: extendClass,
        __extend__: function(value) {
          if (value && value !== SELF && (typeof value == "object" || typeof value == "function" && !isClass(value))) return BaseClass.create.call(null, newClass, value); else return value;
        },
        prototype: newProto
      };
      for (var i = 1, extension; extension = arguments[i]; i++) newClassProps.extend(extension);
      if (newProto.init !== BaseClass.prototype.init && !/^function[^(]*\(\)/.test(newProto.init) && newClassProps.extendConstructor_) consoleMethods.warn("probably wrong extendConstructor_ value for " + newClassProps.className);
      var newClass = newClassProps.extendConstructor_ ? function(extend) {
        this.basisObjectId = instanceSeed.id++;
        var prop;
        for (var key in extend) {
          prop = this[key];
          this[key] = prop && prop.__extend__ ? prop.__extend__(extend[key]) : extend[key];
        }
        this.init();
        this.postInit();
      } : function() {
        this.basisObjectId = instanceSeed.id++;
        this.init.apply(this, arguments);
        this.postInit();
      };
      newClass = devVerboseName(className, {
        instanceSeed: instanceSeed
      }, newClass);
      newProto.constructor = newClass;
      for (var key in newProto) if (newProto[key] === SELF) newProto[key] = newClass;
      extend(newClass, newClassProps);
      classes.push(newClass);
      return newClass;
    }
    function extendClass(source) {
      var proto = this.prototype;
      if (typeof source == "function" && !isClass(source)) source = source(this.superClass_.prototype, slice(proto));
      if (source.prototype) source = source.prototype;
      for (var key in source) {
        var value = source[key];
        var protoValue = proto[key];
        if (key == "className" || key == "extendConstructor_") this[key] = value; else {
          if (protoValue && protoValue.__extend__) proto[key] = protoValue.__extend__(value); else {
            proto[key] = value;
          }
        }
      }
      if (TOSTRING_BUG && source[key = "toString"] !== toString) proto[key] = source[key];
      return this;
    }
    var BaseClass = extend(createClass, {
      className: "basis.Class",
      extendConstructor_: false,
      prototype: {
        basisObjectId: 0,
        constructor: null,
        init: function() {},
        postInit: function() {},
        toString: function() {
          return "[object " + (this.constructor || this).className + "]";
        },
        destroy: function() {
          for (var prop in this) if (hasOwnProperty.call(this, prop)) this[prop] = null;
          this.destroy = $undef;
        }
      }
    });
    var customExtendProperty = function(extension, fn, devName) {
      return {
        __extend__: function(extension) {
          if (!extension) return extension;
          if (extension && extension.__extend__) return extension;
          var Base = function() {};
          Base = devVerboseName(devName || "customExtendProperty", {}, Base);
          Base.prototype = this;
          var result = new Base;
          fn(result, extension);
          return result;
        }
      }.__extend__(extension || {});
    };
    var extensibleProperty = function(extension) {
      return customExtendProperty(extension, extend, "extensibleProperty");
    };
    var nestedExtendProperty = function(extension) {
      return customExtendProperty(extension, function(result, extension) {
        for (var key in extension) {
          var value = result[key];
          result[key] = value && value.__extend__ ? value.__extend__(extension[key]) : extensibleProperty(extension[key]);
        }
      }, "nestedExtendProperty");
    };
    var oneFunctionProperty = function(fn, keys) {
      var create = function(keys) {
        var result = {
          __extend__: create
        };
        if (keys) {
          if (keys.__extend__) return keys;
          var Cls = devVerboseName("oneFunctionProperty", {}, function() {});
          result = new Cls;
          result.__extend__ = create;
          for (var key in keys) if (keys[key]) result[key] = fn;
        }
        return result;
      };
      return create(keys || {});
    };
    return extend(BaseClass, {
      all_: classes,
      SELF: SELF,
      create: createClass,
      isClass: isClass,
      customExtendProperty: customExtendProperty,
      extensibleProperty: extensibleProperty,
      nestedExtendProperty: nestedExtendProperty,
      oneFunctionProperty: oneFunctionProperty
    });
  }();
  var Token = Class(null, {
    className: "basis.Token",
    value: null,
    handler: null,
    deferredToken: null,
    bindingBridge: {
      attach: function(host, fn, context) {
        host.attach(fn, context);
      },
      detach: function(host, fn, context) {
        host.detach(fn, context);
      },
      get: function(host) {
        return host.get();
      }
    },
    init: function(value) {
      this.value = value;
    },
    get: function() {
      return this.value;
    },
    set: function(value) {
      if (this.value !== value) {
        this.value = value;
        this.apply();
      }
    },
    attach: function(fn, context) {
      var cursor = this;
      while (cursor = cursor.handler) if (cursor.fn === fn && cursor.context === context) consoleMethods.warn("basis.Token#attach: duplicate fn & context pair");
      this.handler = {
        fn: fn,
        context: context,
        handler: this.handler
      };
    },
    detach: function(fn, context) {
      var cursor = this;
      var prev;
      while (prev = cursor, cursor = cursor.handler) if (cursor.fn === fn && cursor.context === context) {
        cursor.fn = $undef;
        prev.handler = cursor.handler;
        return;
      }
      consoleMethods.warn("basis.Token#detach: fn & context pair not found, nothing was removed");
    },
    apply: function() {
      var value = this.get();
      var cursor = this;
      while (cursor = cursor.handler) cursor.fn.call(cursor.context, value);
    },
    deferred: function() {
      var token = this.deferredToken;
      if (!token) {
        token = this.deferredToken = new DeferredToken(this.value);
        this.attach(token.set, token);
      }
      return token;
    },
    destroy: function() {
      if (this.deferredToken) {
        this.deferredToken.destroy();
        this.deferredToken = null;
      }
      this.handler = null;
      this.value = null;
      this.attach = $undef;
      this.detach = $undef;
    }
  });
  var awaitToApply = function() {
    var tokens = {};
    var timer;
    function applyTokens() {
      var list = tokens;
      tokens = {};
      timer = null;
      for (var key in list) list[key].apply();
    }
    return function(token) {
      if (token.basisObjectId in tokens) return;
      tokens[token.basisObjectId] = token;
      if (!timer) setImmediate(applyTokens);
    };
  }();
  var DeferredToken = Token.subclass({
    className: "basis.DeferredToken",
    set: function(value) {
      if (this.value !== value) {
        this.value = value;
        awaitToApply(this);
      }
    },
    deferred: function() {
      return this;
    }
  });
  var resources = {};
  var resourceContentCache = {};
  var resourcePatch = {};
  var virtualResourceSeed = 1;
  var resourceResolvingStack = [];
  var requires;
  (function() {
    var map = typeof __resources__ != "undefined" ? __resources__ : null;
    if (map) {
      for (var key in map) resourceContentCache[pathUtils.resolve(key)] = map[key];
    }
  })();
  function applyResourcePatches(resource) {
    var patches = resourcePatch[resource.url];
    if (patches) for (var i = 0; i < patches.length; i++) {
      consoleMethods.info("Apply patch for " + resource.url);
      patches[i](resource.get(), resource.url);
    }
  }
  var getResourceContent = function(url, ignoreCache) {
    if (ignoreCache || !resourceContentCache.hasOwnProperty(url)) {
      var resourceContent = "";
      if (!NODE_ENV) {
        var req = new XMLHttpRequest;
        req.open("GET", url, false);
        req.setRequestHeader("If-Modified-Since", (new Date(0)).toGMTString());
        req.setRequestHeader("X-Basis-Resource", 1);
        req.send("");
        if (req.status >= 200 && req.status < 400) resourceContent = req.responseText; else {
          consoleMethods.error("basis.resource: Unable to load " + url + " (status code " + req.status + ")");
        }
      } else {
        try {
          resourceContent = process.basisjsReadFile ? process.basisjsReadFile(url) : require("fs").readFileSync(url, "utf-8");
        } catch (e) {
          consoleMethods.error("basis.resource: Unable to load " + url, e);
        }
      }
      resourceContentCache[url] = resourceContent;
    }
    return resourceContentCache[url];
  };
  var createResource = function(resourceUrl, content) {
    var contentType = pathUtils.extname(resourceUrl);
    var contentWrapper = getResource.extensions[contentType];
    var isVirtual = arguments.length > 1;
    var resolved = false;
    var wrapped = false;
    var wrappedContent;
    if (isVirtual) resourceUrl += "#virtual";
    var resource = function() {
      if (resolved) return content;
      var urlContent = isVirtual ? content : getResourceContent(resourceUrl);
      var idx = resourceResolvingStack.indexOf(resourceUrl);
      if (idx != -1) consoleMethods.warn("basis.resource recursion:", resourceResolvingStack.slice(idx).concat(resourceUrl).map(pathUtils.relative, pathUtils).join(" -> "));
      resourceResolvingStack.push(resourceUrl);
      if (contentWrapper) {
        if (!wrapped) {
          wrapped = true;
          content = contentWrapper(urlContent, resourceUrl);
          wrappedContent = urlContent;
        }
      } else {
        content = urlContent;
      }
      resolved = true;
      applyResourcePatches(resource);
      resource.apply();
      resourceResolvingStack.pop();
      return content;
    };
    extend(resource, extend(new Token, {
      url: resourceUrl,
      type: contentType,
      virtual: isVirtual,
      fetch: function() {
        return resource();
      },
      toString: function() {
        return "[basis.resource " + resourceUrl + "]";
      },
      isResolved: function() {
        return resolved;
      },
      hasChanges: function() {
        return contentWrapper ? resourceContentCache[resourceUrl] !== wrappedContent : false;
      },
      update: function(newContent) {
        if (!resolved || isVirtual || newContent != resourceContentCache[resourceUrl]) {
          if (!isVirtual) resourceContentCache[resourceUrl] = newContent;
          if (contentWrapper) {
            if (!wrapped && isVirtual) content = newContent;
            if (wrapped && !contentWrapper.permanent) {
              content = contentWrapper(newContent, resourceUrl, content);
              applyResourcePatches(resource);
              resource.apply();
            }
          } else {
            content = newContent;
            resolved = true;
            applyResourcePatches(resource);
            resource.apply();
          }
        }
      },
      reload: function() {
        if (isVirtual) return;
        var oldContent = resourceContentCache[resourceUrl];
        var newContent = getResourceContent(resourceUrl, true);
        if (newContent != oldContent) {
          resolved = false;
          resource.update(newContent);
        }
      },
      get: function(source) {
        if (isVirtual) if (source) return contentWrapper ? wrappedContent : content;
        return source ? getResourceContent(resourceUrl) : resource();
      },
      ready: function(fn, context) {
        if (resolved) {
          fn.call(context, resource());
          if (contentWrapper && contentWrapper.permanent) return;
        }
        resource.attach(fn, context);
        return resource;
      }
    }));
    resources[resourceUrl] = resource;
    return resource;
  };
  var getResource = function(resourceUrl) {
    var resource = resources[resourceUrl];
    if (resource) return resource;
    if (!/^(\.\/|\.\.|\/)/.test(resourceUrl)) consoleMethods.warn("Bad usage: basis.resource('" + resourceUrl + "').\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.");
    resourceUrl = pathUtils.resolve(resourceUrl);
    resource = resources[resourceUrl];
    return resource || createResource(resourceUrl);
  };
  extend(getResource, {
    isResource: function(value) {
      return value ? resources[value.url] === value : false;
    },
    isResolved: function(resourceUrl) {
      var resource = getResource.get(resourceUrl);
      return resource ? resource.isResolved() : false;
    },
    exists: function(resourceUrl) {
      if (!/^(\.\/|\.\.|\/)/.test(resourceUrl)) consoleMethods.warn("Bad usage: basis.resource.exists('" + resourceUrl + "').\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.");
      return resources.hasOwnProperty(pathUtils.resolve(resourceUrl));
    },
    get: function(resourceUrl) {
      if (!/^(\.\/|\.\.|\/)/.test(resourceUrl)) consoleMethods.warn("Bad usage: basis.resource.get('" + resourceUrl + "').\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.");
      resourceUrl = pathUtils.resolve(resourceUrl);
      if (!getResource.exists(resourceUrl)) return null;
      return getResource(resourceUrl);
    },
    getFiles: function(cache) {
      return keys(cache ? resourceContentCache : resources).map(pathUtils.relative);
    },
    virtual: function(type, content, ownerUrl) {
      return createResource((ownerUrl ? ownerUrl + ":" : pathUtils.normalize(pathUtils.baseURI == "/" ? "" : pathUtils.baseURI) + "/") + "virtual-resource" + virtualResourceSeed++ + "." + type, content);
    },
    extensions: {
      ".js": extend(function(content, filename) {
        var namespace = filename2namespace[filename];
        if (!namespace) {
          var implicitNamespace = true;
          var resolvedFilename = pathUtils.dirname(filename) + "/" + pathUtils.basename(filename, pathUtils.extname(filename));
          for (var ns in nsRootPath) {
            var path = nsRootPath[ns] + ns + "/";
            if (resolvedFilename.substr(0, path.length) == path) {
              implicitNamespace = false;
              resolvedFilename = resolvedFilename.substr(nsRootPath[ns].length);
              break;
            }
          }
          namespace = resolvedFilename.replace(/\./g, "_").replace(/^\//g, "").replace(/\//g, ".");
          if (implicitNamespace) namespace = "implicit." + namespace;
        }
        if (requires) arrayFunctions.add(requires, namespace);
        if (!namespaces[namespace]) {
          var ns = getNamespace(namespace);
          var savedRequires = requires;
          requires = [];
          ns.exports = runScriptInContext({
            path: ns.path,
            exports: ns.exports
          }, filename, content).exports;
          if (ns.exports && ns.exports.constructor === Object) complete(ns, ns.exports);
          ns.filename_ = filename;
          ns.source_ = content;
          ns.requires_ = requires;
          requires = savedRequires;
        }
        return namespaces[namespace].exports;
      }, {
        permanent: true
      }),
      ".css": function(content, url, cssResource) {
        if (!cssResource) cssResource = new CssResource(url);
        cssResource.updateCssText(content);
        return cssResource;
      },
      ".json": function(content, url) {
        if (typeof content == "object") return content;
        var result;
        try {
          content = String(content);
          result = basis.json.parse(content);
        } catch (e) {
          consoleMethods.warn("basis.resource: Can't parse JSON from " + url, {
            url: url,
            content: content
          });
        }
        return result || null;
      }
    }
  });
  function compileFunction(sourceURL, args, body) {
    try {
      return new Function(args, body + "\n\n//# sourceURL=" + pathUtils.origin + sourceURL);
    } catch (e) {
      if (document && "line" in e == false && "addEventListener" in global) {
        global.addEventListener("error", function onerror(event) {
          if (event.filename == pathUtils.origin + sourceURL) {
            global.removeEventListener("error", onerror);
            consoleMethods.error("Compilation error at " + event.filename + ":" + event.lineno + ": " + e);
            event.preventDefault();
          }
        });
        var script = document.createElement("script");
        script.src = sourceURL;
        script.async = false;
        document.head.appendChild(script);
        document.head.removeChild(script);
      }
      consoleMethods.error("Compilation error at " + sourceURL + ("line" in e ? ":" + (e.line - 1) : "") + ": " + e);
    }
  }
  var runScriptInContext = function(context, sourceURL, sourceCode) {
    var baseURL = pathUtils.dirname(sourceURL) + "/";
    var compiledSourceCode = sourceCode;
    if (!context.exports) context.exports = {};
    if (typeof compiledSourceCode != "function") compiledSourceCode = compileFunction(sourceURL, [ "exports", "module", "basis", "global", "__filename", "__dirname", "resource", "require" ], '"use strict";\n' + sourceCode);
    if (typeof compiledSourceCode == "function") compiledSourceCode.call(context.exports, context.exports, context, basis, global, sourceURL, baseURL, function(relativePath) {
      if (!/^(\.\/|\.\.|\/)/.test(relativePath)) consoleMethods.warn("Bad usage: resource('" + relativePath + "').\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.");
      return getResource(pathUtils.resolve(baseURL, relativePath));
    }, function(relativePath, base) {
      return requireNamespace(relativePath, base || baseURL);
    });
    return context;
  };
  var namespaces = {};
  var namespace2filename = {};
  var filename2namespace = {};
  var nsRootPath = {};
  iterate(config.modules, function(name, module) {
    nsRootPath[name] = module.path + "/";
    namespace2filename[name] = module.filename;
    filename2namespace[module.filename] = name;
  });
  (function(map) {
    var map = typeof __namespace_map__ != "undefined" ? __namespace_map__ : null;
    if (map) {
      for (var key in map) {
        var filename = pathUtils.resolve(key);
        var namespace = map[key];
        filename2namespace[filename] = namespace;
        namespace2filename[namespace] = filename;
      }
    }
  })();
  var Namespace = Class(null, {
    className: "basis.Namespace",
    init: function(name) {
      this.name = name;
      this.exports = {
        path: this.name
      };
    },
    toString: function() {
      return "[basis.namespace " + this.path + "]";
    },
    extend: function(names) {
      extend(this.exports, names);
      return complete(this, names);
    }
  });
  function resolveNSFilename(namespace) {
    if (namespace in namespace2filename == false) {
      var parts = namespace.split(".");
      var namespaceRoot = parts.shift();
      var filename = parts.join("/") + ".js";
      if (namespaceRoot in nsRootPath == false) nsRootPath[namespaceRoot] = pathUtils.baseURI + namespaceRoot + "/";
      if (namespaceRoot == namespace) filename = nsRootPath[namespaceRoot].replace(/\/$/, "") + ".js"; else filename = nsRootPath[namespaceRoot] + filename;
      namespace2filename[namespace] = filename;
      filename2namespace[filename] = namespace;
    }
    return namespace2filename[namespace];
  }
  function getRootNamespace(name) {
    var namespace = namespaces[name];
    if (!namespace) {
      namespace = namespaces[name] = new Namespace(name);
      namespace.namespaces_ = {};
      namespace.namespaces_[name] = namespace;
      if (!config.noConflict) global[name] = namespace;
    }
    return namespace;
  }
  function getNamespace(path) {
    path = path.split(".");
    var rootNs = getRootNamespace(path[0]);
    var cursor = rootNs;
    for (var i = 1, name; name = path[i]; i++) {
      if (!cursor[name]) {
        var nspath = path.slice(0, i + 1).join(".");
        cursor[name] = new Namespace(nspath);
        rootNs.namespaces_[nspath] = cursor[name];
      }
      cursor = cursor[name];
    }
    namespaces[path.join(".")] = cursor;
    return cursor;
  }
  var requireNamespace = function() {
    if (NODE_ENV) {
      var moduleProto = module.constructor.prototype;
      return function(filename, dirname) {
        if (!/[^a-z0-9_\.]/i.test(filename) || pathUtils.extname(filename) == ".js") {
          var _compile = moduleProto._compile;
          var namespace = getNamespace(filename);
          moduleProto._compile = function(content, filename) {
            this.basis = basis;
            content = "var __nodejsRequire = require;\n" + "var basis = module.basis;\n" + 'var resource = function(filename){ return basis.resource(__dirname + "/" + filename) };\n' + "var require = function(filename, baseURI){ return basis.require(filename, baseURI || __dirname) };\n" + content;
            _compile.call(extend(this, namespace), content, filename);
          };
          var exports = require(__dirname + "/" + filename.replace(/\./g, "/"));
          namespace.exports = exports;
          if (exports && exports.constructor === Object) complete(namespace, exports);
          moduleProto._compile = _compile;
          return exports;
        } else {
          filename = pathUtils.resolve(dirname, filename);
          return require(filename);
        }
      };
    } else {
      return function(filename, dirname) {
        if (!/[^a-z0-9_\.]/i.test(filename) && pathUtils.extname(filename) != ".js") {
          filename = resolveNSFilename(filename);
        } else {
          if (!/^(\.\/|\.\.|\/)/.test(filename)) consoleMethods.warn("Bad usage: require('" + filename + "').\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.");
          filename = pathUtils.resolve(dirname, filename);
        }
        return getResource(filename).fetch();
      };
    }
  }();
  function patch(filename, patchFn) {
    if (!/[^a-z0-9_\.]/i.test(filename) && pathUtils.extname(filename) != ".js") {
      filename = resolveNSFilename(filename);
    } else {
      if (!/^(\.\/|\.\.|\/)/.test(filename)) consoleMethods.warn("Bad usage: basis.patch('" + filename + "').\nFilenames should starts with `./`, `..` or `/`. Otherwise it will treats as special reference in next minor release.");
      filename = pathUtils.resolve(filename);
    }
    if (!resourcePatch[filename]) resourcePatch[filename] = [ patchFn ]; else resourcePatch[filename].push(patchFn);
    var resource = getResource.get(filename);
    if (resource && resource.isResolved()) patchFn(resource.get(), resource.url);
  }
  complete(Function.prototype, {
    bind: function(thisObject) {
      var fn = this;
      var params = arrayFrom(arguments, 1);
      return params.length ? function() {
        return fn.apply(thisObject, params.concat.apply(params, arguments));
      } : function() {
        return fn.apply(thisObject, arguments);
      };
    }
  });
  complete(Array, {
    isArray: function(value) {
      return toString.call(value) === "[object Array]";
    }
  });
  function arrayFrom(object, offset) {
    if (object != null) {
      var len = object.length;
      if (typeof len == "undefined" || toString.call(object) == "[object Function]") return [ object ];
      if (!offset) offset = 0;
      if (len - offset > 0) {
        for (var result = [], k = 0, i = offset; i < len; ) result[k++] = object[i++];
        return result;
      }
    }
    return [];
  }
  function createArray(length, fillValue, thisObject) {
    var result = [];
    var isFunc = typeof fillValue == "function";
    for (var i = 0; i < length; i++) result[i] = isFunc ? fillValue.call(thisObject, i, result) : fillValue;
    return result;
  }
  complete(Array.prototype, {
    indexOf: function(searchElement, offset) {
      offset = parseInt(offset, 10) || 0;
      if (offset < 0) return -1;
      for (; offset < this.length; offset++) if (this[offset] === searchElement) return offset;
      return -1;
    },
    lastIndexOf: function(searchElement, offset) {
      var len = this.length;
      offset = parseInt(offset, 10);
      if (isNaN(offset) || offset >= len) offset = len - 1; else offset = (offset + len) % len;
      for (; offset >= 0; offset--) if (this[offset] === searchElement) return offset;
      return -1;
    },
    forEach: function(callback, thisObject) {
      for (var i = 0, len = this.length; i < len; i++) if (i in this) callback.call(thisObject, this[i], i, this);
    },
    every: function(callback, thisObject) {
      for (var i = 0, len = this.length; i < len; i++) if (i in this && !callback.call(thisObject, this[i], i, this)) return false;
      return true;
    },
    some: function(callback, thisObject) {
      for (var i = 0, len = this.length; i < len; i++) if (i in this && callback.call(thisObject, this[i], i, this)) return true;
      return false;
    },
    filter: function(callback, thisObject) {
      var result = [];
      for (var i = 0, len = this.length; i < len; i++) if (i in this && callback.call(thisObject, this[i], i, this)) result.push(this[i]);
      return result;
    },
    map: function(callback, thisObject) {
      var result = [];
      for (var i = 0, len = this.length; i < len; i++) if (i in this) result[i] = callback.call(thisObject, this[i], i, this);
      return result;
    },
    reduce: function(callback, initialValue) {
      var len = this.length;
      var argsLen = arguments.length;
      if (len == 0 && argsLen == 1) throw new TypeError;
      var result;
      var inited = 0;
      if (argsLen > 1) {
        result = initialValue;
        inited = 1;
      }
      for (var i = 0; i < len; i++) if (i in this) if (inited++) result = callback.call(null, result, this[i], i, this); else result = this[i];
      return result;
    }
  });
  var arrayFunctions = {
    from: arrayFrom,
    create: createArray,
    flatten: function(this_) {
      return this_.concat.apply([], this_);
    },
    repeat: function(this_, count) {
      return arrayFunctions.flatten(createArray(parseInt(count, 10) || 0, this_));
    },
    search: function(this_, value, getter_, offset) {
      this_.lastSearchIndex = -1;
      getter_ = getter(getter_ || $self);
      for (var index = parseInt(offset, 10) || 0, len = this_.length; index < len; index++) if (getter_(this_[index]) === value) return this_[this_.lastSearchIndex = index];
    },
    lastSearch: function(this_, value, getter_, offset) {
      this_.lastSearchIndex = -1;
      getter_ = getter(getter_ || $self);
      var len = this_.length;
      var index = isNaN(offset) || offset == null ? len : parseInt(offset, 10);
      for (var i = index > len ? len : index; i-- > 0; ) if (getter_(this_[i]) === value) return this_[this_.lastSearchIndex = i];
    },
    add: function(this_, value) {
      return this_.indexOf(value) == -1 && !!this_.push(value);
    },
    remove: function(this_, value) {
      var index = this_.indexOf(value);
      return index != -1 && !!this_.splice(index, 1);
    },
    has: function(this_, value) {
      return this_.indexOf(value) != -1;
    },
    sortAsObject: function() {
      consoleMethods.warn("basis.array.sortAsObject is deprecated, use basis.array.sort instead");
      return arrayFunctions.sort.apply(this, arguments);
    },
    sort: function(this_, getter_, comparator, desc) {
      getter_ = getter(getter_);
      desc = desc ? -1 : 1;
      return this_.map(function(item, index) {
        return {
          i: index,
          v: getter_(item)
        };
      }).sort(comparator || function(a, b) {
        return desc * (a.v > b.v || -(a.v < b.v) || (a.i > b.i ? 1 : -1));
      }).map(function(item) {
        return this[item.i];
      }, this_);
    }
  };
  if (![ 1, 2 ].splice(1).length) {
    var nativeArraySplice = Array.prototype.splice;
    Array.prototype.splice = function() {
      var params = arrayFrom(arguments);
      if (params.length < 2) params[1] = this.length;
      return nativeArraySplice.apply(this, params);
    };
  }
  var ESCAPE_FOR_REGEXP = /([\/\\\(\)\[\]\?\{\}\|\*\+\-\.\^\$])/g;
  var FORMAT_REGEXP = /\{([a-z\d_]+)(?::([\.0])(\d+)|:(\?))?\}/gi;
  complete(String, {
    toLowerCase: function(value) {
      return String(value).toLowerCase();
    },
    toUpperCase: function(value) {
      return String(value).toUpperCase();
    },
    trim: function(value) {
      return String(value).trim();
    },
    trimLeft: function(value) {
      return String(value).trimLeft();
    },
    trimRight: function(value) {
      return String(value).trimRight();
    }
  });
  complete(String.prototype, {
    trimLeft: function() {
      return this.replace(/^\s+/, "");
    },
    trimRight: function() {
      return this.replace(/\s+$/, "");
    },
    trim: function() {
      return this.trimLeft().trimRight();
    }
  });
  var stringFunctions = {
    toObject: function(this_, rethrow) {
      try {
        return (new Function("return 0," + this_))();
      } catch (e) {
        if (rethrow) throw e;
      }
    },
    repeat: function(this_, count) {
      return (new Array(parseInt(count, 10) + 1 || 0)).join(this_);
    },
    qw: function(this_) {
      var trimmed = this_.trim();
      return trimmed ? trimmed.split(/\s+/) : [];
    },
    forRegExp: function(this_) {
      return this_.replace(ESCAPE_FOR_REGEXP, "\\$1");
    },
    format: function(this_, first) {
      var data = arrayFrom(arguments, 1);
      if (typeof first == "object") extend(data, first);
      return this_.replace(FORMAT_REGEXP, function(m, key, numFormat, num, noNull) {
        var value = key in data ? data[key] : noNull ? "" : m;
        if (numFormat && !isNaN(value)) {
          value = Number(value);
          return numFormat == "." ? value.toFixed(num) : numberFunctions.lead(value, num);
        }
        return value;
      });
    },
    capitalize: function(this_) {
      return this_.charAt(0).toUpperCase() + this_.substr(1).toLowerCase();
    },
    camelize: function(this_) {
      return this_.replace(/-(.)/g, function(m, chr) {
        return chr.toUpperCase();
      });
    },
    dasherize: function(this_) {
      return this_.replace(/[A-Z]/g, function(m) {
        return "-" + m.toLowerCase();
      });
    },
    isEmpty: function(value) {
      return value == null || String(value) == "";
    },
    isNotEmpty: function(value) {
      return value != null && String(value) != "";
    }
  };
  if ("|||".split(/\|/).length + "|||".split(/(\|)/).length != 11) {
    var nativeStringSplit = String.prototype.split;
    String.prototype.split = function(pattern, count) {
      if (!pattern || pattern instanceof RegExp == false || pattern.source == "") return nativeStringSplit.apply(this, arguments);
      var result = [];
      var pos = 0;
      var match;
      if (!pattern.global) pattern = new RegExp(pattern.source, /\/([mi]*)$/.exec(pattern)[1] + "g");
      while (match = pattern.exec(this)) {
        match[0] = this.substring(pos, match.index);
        result.push.apply(result, match);
        pos = pattern.lastIndex;
      }
      result.push(this.substr(pos));
      return result;
    };
  }
  if ("12".substr(-1) != "2") {
    var nativeStringSubstr = String.prototype.substr;
    String.prototype.substr = function(start, end) {
      return nativeStringSubstr.call(this, start < 0 ? Math.max(0, this.length + start) : start, end);
    };
  }
  var numberFunctions = {
    fit: function(this_, min, max) {
      if (!isNaN(min) && this_ < min) return Number(min);
      if (!isNaN(max) && this_ > max) return Number(max);
      return this_;
    },
    lead: function(this_, len, leadChar) {
      return String(this_).replace(/\d+/, function(number) {
        return (len -= number.length - 1) > 1 ? (new Array(len)).join(leadChar || 0) + number : number;
      });
    },
    group: function(this_, len, splitter) {
      return String(this_).replace(/\d+/, function(number) {
        return number.replace(/\d/g, function(m, pos) {
          return !pos + (number.length - pos) % (len || 3) ? m : (splitter || " ") + m;
        });
      });
    },
    format: function(this_, prec, gs, prefix, postfix, comma) {
      var res = this_.toFixed(prec);
      if (gs || comma) res = res.replace(/(\d+)(\.?)/, function(m, number, c) {
        return (gs ? basis.number.group(Number(number), 3, gs) : number) + (c ? comma || c : "");
      });
      if (prefix) res = res.replace(/^-?/, "$&" + (prefix || ""));
      return res + (postfix || "");
    }
  };
  complete(Date, {
    now: function() {
      return Number(new Date);
    }
  });
  var ready = function() {
    function isReady() {
      return document.readyState == "complete" && !!document.body;
    }
    var fired = !document || isReady();
    var deferredHandler;
    function runReadyHandler(handler) {
      handler.callback.call(handler.context);
    }
    function fireHandlers() {
      if (isReady()) if (!(fired++)) while (deferredHandler) {
        runReadyHandler(deferredHandler);
        deferredHandler = deferredHandler.next;
      }
    }
    function doScrollCheck() {
      try {
        document.documentElement.doScroll("left");
        fireHandlers();
      } catch (e) {
        setTimeout(doScrollCheck, 1);
      }
    }
    if (!fired) {
      if (document.addEventListener) {
        document.addEventListener("DOMContentLoaded", fireHandlers, false);
        global.addEventListener("load", fireHandlers, false);
      } else {
        document.attachEvent("onreadystatechange", fireHandlers);
        global.attachEvent("onload", fireHandlers);
        try {
          if (!global.frameElement && document.documentElement.doScroll) doScrollCheck();
        } catch (e) {}
      }
    }
    return function(callback, context) {
      if (!fired) {
        deferredHandler = {
          callback: callback,
          context: context,
          next: deferredHandler
        };
      } else runReadyHandler({
        callback: callback,
        context: context
      });
    };
  }();
  var documentInterface = function() {
    var timer;
    var reference = {};
    var callbacks = {
      head: [],
      body: []
    };
    function getParent(name) {
      if (document && !reference[name]) {
        reference[name] = document[name] || document.getElementsByTagName(name)[0];
        if (reference[name]) {
          var items = callbacks[name];
          delete callbacks[name];
          for (var i = 0, cb; cb = items[i]; i++) cb[0].call(cb[1], reference[name]);
        }
      }
      return reference[name];
    }
    function add() {
      var name = this[0];
      var node = this[1];
      var ref = this[2];
      remove(node);
      var parent = getParent(name);
      if (parent) {
        if (ref === true) ref = parent.firstChild;
        if (!ref || ref.parentNode !== parent) ref = null;
        parent.insertBefore(node, ref);
      } else callbacks[name].push([ add, [ name, node, ref ] ]);
    }
    function docReady(name, fn, context) {
      if (callbacks[name]) callbacks[name].push([ fn, context ]); else fn.call(context, reference[name]);
    }
    function remove(node) {
      for (var key in callbacks) {
        var entry = arrayFunctions.search(callbacks[key], node, function(item) {
          return item[1] && item[1][1];
        });
        if (entry) arrayFunctions.remove(callbacks[key], entry);
      }
      if (node && node.parentNode && node.parentNode.nodeType == 1) node.parentNode.removeChild(node);
    }
    function checkParents() {
      if (timer && getParent("head") && getParent("body")) timer = clearInterval(timer);
    }
    if (document && (!getParent("head") || !getParent("body"))) {
      timer = setInterval(checkParents, 5);
      ready(checkParents);
    }
    return {
      head: {
        ready: function(fn, context) {
          docReady("head", fn, context);
        },
        add: function(node, ref) {
          add.call([ "head", node, ref ]);
        }
      },
      body: {
        ready: function(fn, context) {
          docReady("body", fn, context);
        },
        add: function(node, ref) {
          add.call([ "body", node, ref ]);
        }
      },
      remove: remove
    };
  }();
  var cleaner = function() {
    var objects = [];
    function destroy(log) {
      var logDestroy = log && typeof log == "boolean";
      result.globalDestroy = true;
      result.add = $undef;
      result.remove = $undef;
      var object;
      while (object = objects.pop()) {
        if (typeof object.destroy == "function") {
          try {
            if (logDestroy) consoleMethods.log("destroy", "[" + String(object.className) + "]", object);
            object.destroy();
          } catch (e) {
            consoleMethods.warn(String(object), e);
          }
        } else {
          for (var prop in object) object[prop] = null;
        }
      }
      objects.length = 0;
    }
    if ("attachEvent" in global) global.attachEvent("onunload", destroy); else if ("addEventListener" in global) global.addEventListener("unload", destroy, false); else return {
      add: $undef,
      remove: $undef
    };
    var result = {
      add: function(object) {
        if (object != null) objects.push(object);
      },
      remove: function(object) {
        arrayFunctions.remove(objects, object);
      }
    };
    result.destroy_ = destroy;
    result.objects_ = objects;
    return result;
  }();
  var CssResource = function() {
    var STYLE_APPEND_BUGGY = function() {
      try {
        return !document.createElement("style").appendChild(document.createTextNode(""));
      } catch (e) {
        return true;
      }
    }();
    var baseEl = document && document.createElement("base");
    function setBase(baseURI) {
      baseEl.setAttribute("href", baseURI);
      documentInterface.head.add(baseEl, true);
    }
    function restoreBase() {
      baseEl.setAttribute("href", location.href);
      documentInterface.remove(baseEl);
    }
    function injectStyleToHead() {
      setBase(this.baseURI);
      if (!this.element) {
        this.element = document.createElement("style");
        if (!STYLE_APPEND_BUGGY) this.element.appendChild(document.createTextNode(""));
        this.element.setAttribute("src", this.url);
      }
      documentInterface.head.add(this.element);
      this.syncCssText();
      restoreBase();
    }
    return Class(null, {
      className: "basis.CssResource",
      inUse: 0,
      url: "",
      baseURI: "",
      cssText: undefined,
      element: null,
      init: function(url) {
        this.url = url;
        this.baseURI = pathUtils.dirname(url) + "/";
      },
      updateCssText: function(cssText) {
        if (this.cssText != cssText) {
          this.cssText = cssText;
          if (this.inUse && this.element) {
            setBase(this.baseURI);
            this.syncCssText();
            restoreBase();
          }
        }
      },
      syncCssText: STYLE_APPEND_BUGGY ? function() {
        this.element.styleSheet.cssText = this.cssText;
      } : function() {
        var cssText = this.cssText;
        cssText += "\n/*# sourceURL=" + pathUtils.origin + this.url + " */";
        this.element.firstChild.nodeValue = cssText;
      },
      startUse: function() {
        if (!this.inUse) documentInterface.head.ready(injectStyleToHead, this);
        this.inUse += 1;
      },
      stopUse: function() {
        if (this.inUse) {
          this.inUse -= 1;
          if (!this.inUse && this.element) documentInterface.remove(this.element);
        }
      },
      destroy: function() {
        if (this.element) documentInterface.remove(this.element);
        this.element = null;
        this.cssText = null;
      }
    });
  }();
  var basis = getNamespace("basis").extend({
    filename_: basisFilename,
    processConfig: processConfig,
    version: VERSION,
    NODE_ENV: NODE_ENV,
    config: config,
    createSandbox: function(config) {
      return createBasisInstance(global, basisFilename, complete({
        noConflict: true
      }, config));
    },
    resolveNSFilename: resolveNSFilename,
    patch: patch,
    namespace: getNamespace,
    require: requireNamespace,
    resource: getResource,
    asset: function(url) {
      return url;
    },
    setImmediate: setImmediate,
    clearImmediate: clearImmediate,
    nextTick: function() {
      setImmediate.apply(null, arguments);
    },
    Class: Class,
    Token: Token,
    DeferredToken: DeferredToken,
    genUID: genUID,
    getter: getter,
    ready: ready,
    cleaner: cleaner,
    console: consoleMethods,
    path: pathUtils,
    doc: documentInterface,
    object: {
      extend: extend,
      complete: complete,
      keys: keys,
      values: values,
      slice: slice,
      splice: splice,
      merge: merge,
      iterate: iterate
    },
    fn: {
      $undefined: $undefined,
      $defined: $defined,
      $isNull: $isNull,
      $isNotNull: $isNotNull,
      $isSame: $isSame,
      $isNotSame: $isNotSame,
      $self: $self,
      $const: $const,
      $false: $false,
      $true: $true,
      $null: $null,
      $undef: $undef,
      getter: getter,
      nullGetter: nullGetter,
      wrapper: wrapper,
      lazyInit: lazyInit,
      lazyInitAndRun: lazyInitAndRun,
      runOnce: runOnce
    },
    array: extend(arrayFrom, arrayFunctions),
    string: stringFunctions,
    number: numberFunctions,
    bool: {
      invert: function(value) {
        return !value;
      }
    },
    json: {
      parse: typeof JSON != "undefined" ? JSON.parse : function(str) {
        return stringFunctions.toObject(str, true);
      }
    }
  });
  getNamespace("basis.dev").extend(consoleMethods);
  if (config.autoload) config.autoload.forEach(function(name) {
    requireNamespace(name);
  });
  return basis;
})(this);
}).call(this);